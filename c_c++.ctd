<?xml version="1.0" ?><cherrytree><node name="C++中const用法总结" prog_lang="custom-colors" readonly="False" tags="" unique_id="1"><rich_text scale="h3" weight="heavy">1. const修饰普通变量和指针</rich_text><rich_text>
const修饰变量，一般有两种写法： 
const TYPE value; 
TYPE const value; 
这两种写法在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。 
对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value只不可变。 
例如： 
const int nValue； //nValue是const 
int const nValue； // nValue是const 
但是对于指针类型的TYPE，不同的写法会有不同情况，例如： 
A. const char *pContent; 
B. char * const pContent; 
C. char const *pContent; 
D. const char* const pContent; 
对于前三种写法，我们可以换个方式，给其加上括号 
A. const (char) *pContent; 
B. (char*) const pContent; 
C. (char) const *pContent; 
这样就一目了然。根据对于const修饰非指针变量的规则，很明显，A=C. 
- 对于A,C, const修饰的类型为char的变量*pContent为常量，因此，pContent的内容为常量不可变. 
- 对于B,  
    含义为：const修饰的类型为char*的变量pContent为常量，因此，pContent指针本身为常量不可变. 
- 对于D, 其实是A和B的混合体，表示指针本身和指针内容两者皆为常量不可变 
总结: 
</rich_text><rich_text weight="heavy">(1) 指针本身是常量不可变</rich_text><rich_text> 
(char*) const pContent; 
 
</rich_text><rich_text weight="heavy">(2) 指针所指向的内容是常量不可变 </rich_text><rich_text>
const (char) *pContent; 
(char) const *pContent;
 
</rich_text><rich_text weight="heavy">(3) 两者都不可变 </rich_text><rich_text>
const char* const pContent;
 
还有其中区别方法： 
</rich_text><rich_text foreground="#ffff00000000">沿着*号划一条线， 
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 
</rich_text><rich_text>
</rich_text><rich_text scale="h3" weight="heavy">2. const修饰函数参数</rich_text><rich_text>
const修饰函数参数是它最广泛的一种用途，它表示函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)。它可以很好 
void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参) 
void function(const char* Var); //参数指针所指内容为常量不可变 
void function(char* const Var); //参数指针本身为常量不可变(也无意义， 因为char* Var也是形参) 
参数为引用，为了增加效率同时防止修改。 
修饰引用参数时： 
void function(const Class&amp; Var);//引用参数在函数内不可以改变 
void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变 

</rich_text><rich_text scale="h3" weight="heavy">3. const 修饰函数返回值</rich_text><rich_text>
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。 
(1) const int fun1() 这个其实无意义，因为参数返回本身就是赋值。 
(2) const int * fun2() 
调用时 const int *pValue = fun2(); 
我们可以把fun2()看作成一个变量，那么就是我们上面所说的1.(1)的写法，即指针内容不可变。 
(3) int* const fun3() 
调用时 int * const pValue = fun2(); 
我们可以把fun2()看作成一个变量，那么就是我们上面所说的1.(2)的写法，即指针本身不可变。 

</rich_text><rich_text scale="h3" weight="heavy">4. const修饰类对象/对象指针/对象引用</rich_text><rich_text>
const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。 
const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 
例如： 
class AAA 
{
    void func1(); 
    void func2() const; 
} 
const AAA aObj; 
aObj.func1(); × 
aObj.func2(); 正确 
const AAA* aObj = new AAA(); 
aObj-&gt;func1(); × 
aObj-&gt;func2(); 正确 

</rich_text><rich_text scale="h3" weight="heavy">5. const修饰成员变量</rich_text><rich_text>
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。 
class A 
{ 
    … 
    const int nValue; //成员常量不能被修改 
    … 
    A(int x): nValue(x) {}; //只能在初始化列表中赋值 
}
 
</rich_text><rich_text scale="h3" weight="heavy">6. const修饰成员函数</rich_text><rich_text>
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。 
class A 
{ 
    … 
    void function()const; //常成员函数, 它不改变对象的成员变量. 也不能调用类中任何非const成员函数。 
} 
对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。 

</rich_text><rich_text scale="h3" weight="heavy">7. const常量与define宏定义的区别</rich_text><rich_text>
</rich_text><rich_text weight="heavy">(1) 编译器处理方式不同</rich_text><rich_text> 
    define宏是在预处理阶段展开。 
    const常量是编译运行阶段使用。 
</rich_text><rich_text weight="heavy">(2) 类型和安全检查不同 </rich_text><rich_text>
    define宏没有类型，不做任何类型检查，仅仅是展开。 
    const常量有具体的类型，在编译阶段会执行类型检查。 
</rich_text><rich_text weight="heavy">(3) 存储方式不同 </rich_text><rich_text>
    define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。 
    const常量会在内存中分配(可以是堆中也可以是栈中)。
     </rich_text></node><node name="gcc" prog_lang="custom-colors" readonly="False" tags="" unique_id="3"><rich_text></rich_text><node name="GCC选项_-Wl,-soname " prog_lang="custom-colors" readonly="False" tags="" unique_id="2"><rich_text>-Wl选项告诉编译器将后面的参数传递给链接器。
-soname则指定了动态库的soname(简单共享名，Short for shared object name)

soname的关键功能是它提供了兼容性的标准：
当要升级系统中的一个库时，并且新库的soname和老库的soname一样，用旧库链接生成的程序使用新库依然能正常运行。这个特性使得在Linux下，升级使得共享库的程序和定位错误变得十分容易。
 
在Linux中，应用程序通过使用soname，来指定所希望库的版本，库作者可以通过保留或改变soname来声明，哪些版本是兼容的，这使得程序员摆脱了共享库版本冲突问题的困扰。
可以通过readelf -d来查看每个动态库的SONAME
 
</rich_text><rich_text scale="h3" weight="heavy">1. 声明libto.so.1，并生成libto.so.1.2</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.1 -o libto.so.1.2 to.c  
2. [root@localhost c]# ls -lh  
3. -rwxr-xr-x 1 root root 4268 Jan 10 17:22 libto.so.1.2  
4. [root@localhost c]# ldconfig -n ./  
5. lrwxrwxrwx 1 root root   12 Jan 10 17:23 libto.so.1 -&gt; libto.so.1.2  
6. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  

1. [root@localhost c]# readelf -d libto.so.1.2  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.1]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

</rich_text><rich_text scale="h3" weight="heavy">2. 声明libto.so.1，并生成libto.so.1.3</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.1 -o libto.so.1.3 to.c  
2. [root@localhost c]# ls -lh  
3. lrwxrwxrwx 1 root root   12 Jan 10 17:23 libto.so.1 -&gt; libto.so.1.2  
4. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
5. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
6. [root@localhost c]# ldconfig -n ./  
7. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  #重新ldconfig，指向新的库文件  
8. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
9. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  

1. [root@localhost c]# readelf -d libto.so.1.3  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.1]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

</rich_text><rich_text scale="h3" weight="heavy">3. 声明libto.so.2，并生成libto.so.1.4</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.2 -o libto.so.1.4 to.c  
2. [root@localhost c]# ls -lh  
3. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  
4. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
5. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
6. -rwxr-xr-x 1 root root 4.2K Jan 10 17:24 libto.so.1.4  
7. [root@localhost c]# ldconfig -n ./  
8. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  #重新ldconfig，不指向新的库文件，因为新库(1.4)的soname为libto.so.2  
9. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
10. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
11. -rwxr-xr-x 1 root root 4.2K Jan 10 17:24 libto.so.1.4  
12. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.2 -&gt; libto.so.1.4  

1. [root@localhost c]# readelf -d libto.so.1.4  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.2]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

总结：程式库主要的升级会破坏相容性；而次要的升级则可能不会；那麽以下面的方式来连结，所有的一切就都会相安无事了。 
gcc -shared -Wl,-soname,libfoo.so.major -o libfoo.so.major.minor
</rich_text></node></node></cherrytree>