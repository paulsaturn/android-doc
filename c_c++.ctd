<?xml version="1.0" ?><cherrytree><node name="C++中const用法总结" prog_lang="custom-colors" readonly="False" tags="" unique_id="1"><rich_text scale="h3" weight="heavy">1. const修饰普通变量和指针</rich_text><rich_text>
const修饰变量，一般有两种写法： 
const TYPE value; 
TYPE const value; 
这两种写法在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。 
对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value只不可变。 
例如： 
const int nValue； //nValue是const 
int const nValue； // nValue是const 
但是对于指针类型的TYPE，不同的写法会有不同情况，例如： 
A. const char *pContent; 
B. char * const pContent; 
C. char const *pContent; 
D. const char* const pContent; 
对于前三种写法，我们可以换个方式，给其加上括号 
A. const (char) *pContent; 
B. (char*) const pContent; 
C. (char) const *pContent; 
这样就一目了然。根据对于const修饰非指针变量的规则，很明显，A=C. 
- 对于A,C, const修饰的类型为char的变量*pContent为常量，因此，pContent的内容为常量不可变. 
- 对于B,  
    含义为：const修饰的类型为char*的变量pContent为常量，因此，pContent指针本身为常量不可变. 
- 对于D, 其实是A和B的混合体，表示指针本身和指针内容两者皆为常量不可变 
总结: 
</rich_text><rich_text weight="heavy">(1) 指针本身是常量不可变</rich_text><rich_text> 
(char*) const pContent; 
 
</rich_text><rich_text weight="heavy">(2) 指针所指向的内容是常量不可变 </rich_text><rich_text>
const (char) *pContent; 
(char) const *pContent;
 
</rich_text><rich_text weight="heavy">(3) 两者都不可变 </rich_text><rich_text>
const char* const pContent;
 
还有其中区别方法： 
</rich_text><rich_text foreground="#ffff00000000">沿着*号划一条线， 
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 
</rich_text><rich_text>
</rich_text><rich_text scale="h3" weight="heavy">2. const修饰函数参数</rich_text><rich_text>
const修饰函数参数是它最广泛的一种用途，它表示函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)。它可以很好 
void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参) 
void function(const char* Var); //参数指针所指内容为常量不可变 
void function(char* const Var); //参数指针本身为常量不可变(也无意义， 因为char* Var也是形参) 
参数为引用，为了增加效率同时防止修改。 
修饰引用参数时： 
void function(const Class&amp; Var);//引用参数在函数内不可以改变 
void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变 

</rich_text><rich_text scale="h3" weight="heavy">3. const 修饰函数返回值</rich_text><rich_text>
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。 
(1) const int fun1() 这个其实无意义，因为参数返回本身就是赋值。 
(2) const int * fun2() 
调用时 const int *pValue = fun2(); 
我们可以把fun2()看作成一个变量，那么就是我们上面所说的1.(1)的写法，即指针内容不可变。 
(3) int* const fun3() 
调用时 int * const pValue = fun2(); 
我们可以把fun2()看作成一个变量，那么就是我们上面所说的1.(2)的写法，即指针本身不可变。 

</rich_text><rich_text scale="h3" weight="heavy">4. const修饰类对象/对象指针/对象引用</rich_text><rich_text>
const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。 
const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 
例如： 
class AAA 
{
    void func1(); 
    void func2() const; 
} 
const AAA aObj; 
aObj.func1(); × 
aObj.func2(); 正确 
const AAA* aObj = new AAA(); 
aObj-&gt;func1(); × 
aObj-&gt;func2(); 正确 

</rich_text><rich_text scale="h3" weight="heavy">5. const修饰成员变量</rich_text><rich_text>
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。 
class A 
{ 
    … 
    const int nValue; //成员常量不能被修改 
    … 
    A(int x): nValue(x) {}; //只能在初始化列表中赋值 
}
 
</rich_text><rich_text scale="h3" weight="heavy">6. const修饰成员函数</rich_text><rich_text>
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。 
class A 
{ 
    … 
    void function()const; //常成员函数, 它不改变对象的成员变量. 也不能调用类中任何非const成员函数。 
} 
对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。 

</rich_text><rich_text scale="h3" weight="heavy">7. const常量与define宏定义的区别</rich_text><rich_text>
</rich_text><rich_text weight="heavy">(1) 编译器处理方式不同</rich_text><rich_text> 
    define宏是在预处理阶段展开。 
    const常量是编译运行阶段使用。 
</rich_text><rich_text weight="heavy">(2) 类型和安全检查不同 </rich_text><rich_text>
    define宏没有类型，不做任何类型检查，仅仅是展开。 
    const常量有具体的类型，在编译阶段会执行类型检查。 
</rich_text><rich_text weight="heavy">(3) 存储方式不同 </rich_text><rich_text>
    define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。 
    const常量会在内存中分配(可以是堆中也可以是栈中)。
     </rich_text></node><node name="减少C++代码编译时间的方法" prog_lang="custom-colors" readonly="False" tags="" unique_id="4"><rich_text>    c++的代码包含头文件和实现文件两部分， 头文件一般是提供给别人（也叫客户）使用的，  但是一旦头文件发生改变，不管多小的变化，所有引用他的文件就必须重新编译，编译就要花时间，假如你做的工程比较大（比如二次封装chrome这类的开 发）,重新编译一次的时间就会浪费上班的大部分时间，这样干了一天挺累的， 但是你的老板说你没有产出，结果你被fired， 是不是很怨啊，  如果你早点看到这段文章，你就会比你的同事开发效率高那么一些，那样被fired就不会是你了，你说这篇文章是不是价值千金！开个玩笑 ：）
    
言归正传，怎样介绍编译时间呢， 我知道的就3个办法：
1. 删除不必要的#include,替代办法 使用前向声明 (forward declared )
2. 删除不必要的一大堆私有成员变量，转而使用 “impl” 方法
3. 删除不必要的类之间的继承
为了讲清楚这3点，还是举个实例比较好,这个实例我会一步一步的改进（因为我也是一点一点摸索出来了，如果哪里说错了， 你就放心的喷吧，我会和你在争论到底的，呵呵）
现在先假设你找到一个新工作，接手以前某个程序员写的类，如下：
//  old.h: 这就是你接收的类            
//            
#include &lt;iostream&gt;            
#include &lt;ostream&gt;            
#include &lt;list&gt;                         

// 5 个 分别是file , db, cx, deduce or error ， 水平有限没有模板类            
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;  // class file            
#include &quot;db.h&quot;  // class db            
#include &quot;cx.h&quot;  // class cx            
#include &quot;deduce.h&quot;  // class deduce            
#include &quot;error.h&quot;  // class error         
                
class old : public file, private db {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx  get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;            
    
private:              
    std::list&lt;cx&gt; cx_list_;              
    deduce       deduce_d_;            
};
            
inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )            
{ 
    return old_val.print(os); 
}                        
这个类看完了， 如果你已经看出了问题出在哪里， 接下来的不用看了， 你是高手， 这些基本知识对你来说太小儿科，要是像面试时被问住了愣了一下，请接着看吧

</rich_text><rich_text scale="h3" weight="heavy">先看怎么使用第一条： 删除不必要的#include</rich_text><rich_text>
这个类引用 5个头文件， 那意味着那5个头文件所引用的头文件也都被引用了进来， 实际上， 不需要引用5 个，只要引用2个就完全可以了

</rich_text><rich_text scale="h3" weight="heavy">1.删除不必要的#include,替代办法 使用前向声明 (forward declared )</rich_text><rich_text>
1.1删除头文件 iostream， 我刚开始学习c++ 时照着《c++ primer》 抄，只要看见关于输入，输出就把 iostream 头文件加上， 几年过去了， 现在我知道不是这样的， 这里只是定义输出函数， 只要引用ostream 就够了

1.2.ostream头文件也不要， 替换为 iosfwd , 为什么， 原因就是， 参数和返回类型只要前向声明就可以编译通过， 在iosfwd 文件里 678行（我的环境是vs2013，不同的编译环境具体位置可能会不相同，但是都有这句声明） 有这么一句
typedef basic_ostream&lt;char, char_traits&lt;char&gt; &gt; ostream;

inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )
{ 
    return old_val.print(os); 
}

除此之外，要是你说这个函数要操作ostream 对象， 那还是需要#include &lt;ostream&gt; , 你只说对了一半， 的确， 这个函数要操作ostream 对象， 但是请看他的函数实现，
里面没有定义一个类似 std::ostream os, 这样的语句，话说回来，但凡出现这样的定义语句， 就必须#include 相应的头文件了 ，因为这是请求编译器分配空间，而如果只前向声明 class XXX; 编译器怎么知道分配多大的空间给这个对象！
看到这里， old.h头文件可以更新如下了：
//  old.h: 这就是你接收的类            
//            
#include &lt;iosfwd&gt;  //新替换的头文件            
#include &lt;list&gt;                         

// 5 个 分别是file , db, cx, deduce or error， 水平有限没有模板类            
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;  // class file，作为基类不能删除，                               
                            // 删除了编译器就不知道实例化old 对象时分配多大的空间了            
#include &quot;db.h&quot;  // class db，作为基类不能删除，同上            
#include &quot;cx.h&quot;  // class cx            
#include &quot;deduce.h&quot;  // class deduce            
// error 只被用做参数和返回值类型， 用前向声明替换#include &quot;error.h&quot;             
class error；                          
class old : public file, private db {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx  get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;            
    
private:              
    std::list&lt;cx&gt; cx_list_; //  cx 是模版类型，既不是函数参数类型                                      
                                      //  也不是函数返回值类型，所以cx.h 头文件不能删除              
    deduce       deduce_d_; //  deduce 是类型定义，也不删除他的头文件            
};            
inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )            
{ 
    return old_val.print(os); 
}                        
到目前为止， 删除了一些代码， 是不是心情很爽，据说看一个程序员的水平有多高， 不是看他写了多少代码，而是看他少写了多少代码。
如果你对C++ 编程有更深一步的兴趣， 接下来的文字你还是会看的，再进一步删除代码， 但是这次要另辟蹊径了


</rich_text><rich_text scale="h3" weight="heavy">2. 删除不必要的一大堆私有成员变量，转而使用 “impl” 方法</rich_text><rich_text>
2.1.使用 “impl” 实现方式写代码，减少客户端代码的编译依赖
impl 方法简单点说就是把 类的私有成员变量全部放进一个impl 类， 然后把这个类的私有成员变量只保留一个impl* 指针，代码如下：
// file old.h            
class old {              
    // 公有和保护成员              
    // public and protected members 
private:              
    // 私有成员， 只要任意一个的头文件发生变化或成员个数增加，              
    // 减少，所有引用old.h的客户端必须重新编译              
    // private members; whenever these change,              
    // all client code must be recompiled            
};                        
改写成这样：
// file old.h            
class old {              
    // 公有和保护成员              
    // public and protected members            
private:              
    class oldImpl* pimpl_;              
    //  替换原来的所有私有成员变量为这个impl指针，指针只需要前向声明就可以编译通过，              
    //  这种写法将前向声明和定义指针放在了一起，完全可以。              
    //  当然，也可以分开写              
    //  a pointer to a forward-declared class            
};                         

// file old.cpp            
struct oldImpl {              
    // 真正的成员变量隐藏在这里， 随意变化， 客户端的代码都不需要重新编译              
    // private members; fully hidden, can be              
    // changed at will without recompiling clients            
};                        
不知道你看明白了没有， 看不明白请随便写个类试验下，我就是这么做的，当然凡事也都有优缺点，下面简单对比下：
 
</rich_text><rich_text justification="left"></rich_text><rich_text>

改为impl实现后是这样的：
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;             
#include &quot;db.h&quot;             

class cx;            
class error；                         

class old : public file, private db {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx  get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;            
    
private:            
    class oldimpl* pimpl; //此处前向声明和定义            
};
            
inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )            
{ 
    return old_val.print(os); 
}                         

//implementation file old.cpp            
class oldimpl{            
    std::list&lt;cx&gt; cx_list_;            
    deduce        dudece_d_;            
};                        


</rich_text><rich_text scale="h3" weight="heavy">3. 删除不必要的类之间的继承</rich_text><rich_text>
面向对象提供了继承这种机制，但是继承不要滥用， old class 的继承就属于滥用之一， class old 继承file 和 db 类， 继承file是公有继承，继承db 是私有继承
，继承file 可以理解， 因为file 中有虚函数， old 要重新定义它， 但是根据我们的假设， 只有file 和 cx 有虚函数，私有继承db 怎么解释？! 那么唯一可能的理由就是：
通过 私有继承—让某个类不能当作基类去派生其他类，类似Java里final关键字的功能，但是从实例看，显然没有这个用意， 所以这个私有继承完全不必要， 应该改用包含的方式去使用db类提供的功能, 这样就可以
把”db.h”头文件删除， 把db 的实例也可以放进impl类中，最终得到的类是这样的：
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;             

class cx;            
class error;            
class db;            

class old : public file {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx   get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;
                
private:              
    class oldimpl* pimpl; //此处前向声明和定义             
};             

inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )             
{ 
    return old_val.print(os); 
}                         

//implementation file old.cpp            
class oldimpl {            
    std::list&lt;cx&gt; cx_list_;            
    deduce        dudece_d_;            
};                        

</rich_text><rich_text scale="h3">小结一下：</rich_text><rich_text>
这篇文章只是简单的介绍了减少编译时间的几个办法：
1. 删除不必要的#include,替代办法 使用前向声明 (forward declared )
2. 删除不必要的一大堆私有成员变量，转而使用 “impl” 方法
3. 删除不必要的类之间的继承
这几条希望对您有所帮助， 如果我哪里讲的不够清楚也可以参考附件，哪里有完整的实例，也欢迎您发表评论， 大家一起讨论进步，哦不，加薪。 呵呵，在下篇文章我将把impl实现方式再详细分析下，期待吧…
转自 </rich_text><rich_text link="webs http://blog.jobbole.com/85275/">http://blog.jobbole.com/85275/</rich_text><rich_text>
</rich_text><table char_offset="5246" col_max="400" col_min="40"><row><cell> </cell><cell>使用impl 实现类</cell><cell>不使用impl实现类</cell></row><row><cell>优点</cell><cell>类型定义与客户端隔离， 减少#include 的次数，提高编译速度，库端的类随意修改，客户端不需要重新编译</cell><cell>直接，简单明了，不需要考虑堆分配，释放，内存泄漏问题</cell></row><row><cell>缺点</cell><cell>对于impl的指针必须使用堆分配，堆释放，时间长了会产生内存碎片，最终影响程序运行速度， 每次调用一个成员函数都要经过impl-&gt;xxx()的一次转发</cell><cell>库端任意头文件发生变化，客户端都必须重新编译</cell></row><row><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell></row></table></node><node name="gcc" prog_lang="custom-colors" readonly="False" tags="" unique_id="3"><rich_text></rich_text><node name="GCC选项_-Wl,-soname " prog_lang="custom-colors" readonly="False" tags="" unique_id="2"><rich_text>-Wl选项告诉编译器将后面的参数传递给链接器。
-soname则指定了动态库的soname(简单共享名，Short for shared object name)

soname的关键功能是它提供了兼容性的标准：
当要升级系统中的一个库时，并且新库的soname和老库的soname一样，用旧库链接生成的程序使用新库依然能正常运行。这个特性使得在Linux下，升级使得共享库的程序和定位错误变得十分容易。
 
在Linux中，应用程序通过使用soname，来指定所希望库的版本，库作者可以通过保留或改变soname来声明，哪些版本是兼容的，这使得程序员摆脱了共享库版本冲突问题的困扰。
可以通过readelf -d来查看每个动态库的SONAME
 
</rich_text><rich_text scale="h3" weight="heavy">1. 声明libto.so.1，并生成libto.so.1.2</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.1 -o libto.so.1.2 to.c  
2. [root@localhost c]# ls -lh  
3. -rwxr-xr-x 1 root root 4268 Jan 10 17:22 libto.so.1.2  
4. [root@localhost c]# ldconfig -n ./  
5. lrwxrwxrwx 1 root root   12 Jan 10 17:23 libto.so.1 -&gt; libto.so.1.2  
6. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  

1. [root@localhost c]# readelf -d libto.so.1.2  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.1]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

</rich_text><rich_text scale="h3" weight="heavy">2. 声明libto.so.1，并生成libto.so.1.3</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.1 -o libto.so.1.3 to.c  
2. [root@localhost c]# ls -lh  
3. lrwxrwxrwx 1 root root   12 Jan 10 17:23 libto.so.1 -&gt; libto.so.1.2  
4. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
5. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
6. [root@localhost c]# ldconfig -n ./  
7. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  #重新ldconfig，指向新的库文件  
8. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
9. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  

1. [root@localhost c]# readelf -d libto.so.1.3  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.1]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

</rich_text><rich_text scale="h3" weight="heavy">3. 声明libto.so.2，并生成libto.so.1.4</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.2 -o libto.so.1.4 to.c  
2. [root@localhost c]# ls -lh  
3. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  
4. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
5. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
6. -rwxr-xr-x 1 root root 4.2K Jan 10 17:24 libto.so.1.4  
7. [root@localhost c]# ldconfig -n ./  
8. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  #重新ldconfig，不指向新的库文件，因为新库(1.4)的soname为libto.so.2  
9. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
10. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
11. -rwxr-xr-x 1 root root 4.2K Jan 10 17:24 libto.so.1.4  
12. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.2 -&gt; libto.so.1.4  

1. [root@localhost c]# readelf -d libto.so.1.4  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.2]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

总结：程式库主要的升级会破坏相容性；而次要的升级则可能不会；那麽以下面的方式来连结，所有的一切就都会相安无事了。 
gcc -shared -Wl,-soname,libfoo.so.major -o libfoo.so.major.minor
</rich_text></node></node></cherrytree>