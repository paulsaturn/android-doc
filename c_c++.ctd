<?xml version="1.0" ?><cherrytree><node name="C++中const用法总结" prog_lang="custom-colors" readonly="False" tags="" unique_id="1"><rich_text scale="h3" weight="heavy">1. const修饰普通变量和指针</rich_text><rich_text>
const修饰变量，一般有两种写法： 
const TYPE value; 
TYPE const value; 
这两种写法在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。 
对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value只不可变。 
例如： 
const int nValue； //nValue是const 
int const nValue； // nValue是const 
但是对于指针类型的TYPE，不同的写法会有不同情况，例如： 
A. const char *pContent; 
B. char * const pContent; 
C. char const *pContent; 
D. const char* const pContent; 
对于前三种写法，我们可以换个方式，给其加上括号 
A. const (char) *pContent; 
B. (char*) const pContent; 
C. (char) const *pContent; 
这样就一目了然。根据对于const修饰非指针变量的规则，很明显，A=C. 
- 对于A,C, const修饰的类型为char的变量*pContent为常量，因此，pContent的内容为常量不可变. 
- 对于B,  
    含义为：const修饰的类型为char*的变量pContent为常量，因此，pContent指针本身为常量不可变. 
- 对于D, 其实是A和B的混合体，表示指针本身和指针内容两者皆为常量不可变 
总结: 
</rich_text><rich_text weight="heavy">(1) 指针本身是常量不可变</rich_text><rich_text> 
(char*) const pContent; 
 
</rich_text><rich_text weight="heavy">(2) 指针所指向的内容是常量不可变 </rich_text><rich_text>
const (char) *pContent; 
(char) const *pContent;
 
</rich_text><rich_text weight="heavy">(3) 两者都不可变 </rich_text><rich_text>
const char* const pContent;
 
还有其中区别方法： 
</rich_text><rich_text foreground="#ffff00000000">沿着*号划一条线， 
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 
</rich_text><rich_text>
</rich_text><rich_text scale="h3" weight="heavy">2. const修饰函数参数</rich_text><rich_text>
const修饰函数参数是它最广泛的一种用途，它表示函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)。它可以很好 
void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参) 
void function(const char* Var); //参数指针所指内容为常量不可变 
void function(char* const Var); //参数指针本身为常量不可变(也无意义， 因为char* Var也是形参) 
参数为引用，为了增加效率同时防止修改。 
修饰引用参数时： 
void function(const Class&amp; Var);//引用参数在函数内不可以改变 
void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变 

</rich_text><rich_text scale="h3" weight="heavy">3. const 修饰函数返回值</rich_text><rich_text>
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。 
(1) const int fun1() 这个其实无意义，因为参数返回本身就是赋值。 
(2) const int * fun2() 
调用时 const int *pValue = fun2(); 
我们可以把fun2()看作成一个变量，那么就是我们上面所说的1.(1)的写法，即指针内容不可变。 
(3) int* const fun3() 
调用时 int * const pValue = fun2(); 
我们可以把fun2()看作成一个变量，那么就是我们上面所说的1.(2)的写法，即指针本身不可变。 

</rich_text><rich_text scale="h3" weight="heavy">4. const修饰类对象/对象指针/对象引用</rich_text><rich_text>
const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。 
const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 
例如： 
class AAA 
{
    void func1(); 
    void func2() const; 
} 
const AAA aObj; 
aObj.func1(); × 
aObj.func2(); 正确 
const AAA* aObj = new AAA(); 
aObj-&gt;func1(); × 
aObj-&gt;func2(); 正确 

</rich_text><rich_text scale="h3" weight="heavy">5. const修饰成员变量</rich_text><rich_text>
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。 
class A 
{ 
    … 
    const int nValue; //成员常量不能被修改 
    … 
    A(int x): nValue(x) {}; //只能在初始化列表中赋值 
}
 
</rich_text><rich_text scale="h3" weight="heavy">6. const修饰成员函数</rich_text><rich_text>
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。 
class A 
{ 
    … 
    void function()const; //常成员函数, 它不改变对象的成员变量. 也不能调用类中任何非const成员函数。 
} 
对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。 

</rich_text><rich_text scale="h3" weight="heavy">7. const常量与define宏定义的区别</rich_text><rich_text>
</rich_text><rich_text weight="heavy">(1) 编译器处理方式不同</rich_text><rich_text> 
    define宏是在预处理阶段展开。 
    const常量是编译运行阶段使用。 
</rich_text><rich_text weight="heavy">(2) 类型和安全检查不同 </rich_text><rich_text>
    define宏没有类型，不做任何类型检查，仅仅是展开。 
    const常量有具体的类型，在编译阶段会执行类型检查。 
</rich_text><rich_text weight="heavy">(3) 存储方式不同 </rich_text><rich_text>
    define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。 
    const常量会在内存中分配(可以是堆中也可以是栈中)。
     </rich_text></node><node name="GCC 编译优化指南" prog_lang="custom-colors" readonly="False" tags="" unique_id="11"><rich_text>
</rich_text><rich_text scale="h2" weight="heavy">前言</rich_text><rich_text>
网上关于编译优化的文章很多，但大多零零散散，不成体系，本文试图给出一个完整和清晰的优化思路，同时提供在实践中如何进行优化的详尽参考。但是， 在介绍所有优化知识之前首先引用LFS-Book中的一句忠告：“使用编译器优化得到的小幅度性能提升，与它带来的风险相比微不足道”。你还要进行优化 吗？
%@&amp;#=^%~*# ... 
OK, crazy guy! Let's Go!!
在继续之前，作者还是奉劝各位：如果追求极致的优化，那么它将是一件既耗时又麻烦的事情，你会陷入无止尽的测试、测试、再测试……另外  Gentoo wiki 上有这么一句话：&quot;GCC has well over a hundred individual optimization  flags and it would be insane to try and describe them  all.&quot;所以本文不会涉及全部GCC优化选项。最后作者还是再罗唆一句：优化应当适可而止为好，将精力留出来做一些其它事情会更有意义！

</rich_text><rich_text scale="h2" weight="heavy">先决条件</rich_text><rich_text>
本文的主要读者是 LFS/Gentoo 的玩家，基本上比较 crazy 的玩家都接触过，如果你之前从未使用过 LFS/Gentoo ，请先按照</rich_text><rich_text link="webs http://www.jinbuguo.com/lfs/lfs62/index.html">《Linux From Scratch 6.2 中文版》</rich_text><rich_text>做一遍 LFS ，然后再来阅读此文将会更有意义。另外，本文是建立在</rich_text><rich_text link="webs http://www.jinbuguo.com/linux/understand_package_install.html">《深入理解软件包的配置、编译与安装》</rich_text><rich_text>一文基础之上的，在开始阅读本文之前，请先阅读它。

</rich_text><rich_text scale="h2" weight="heavy">基本原理</rich_text><rich_text>
我们首先从三个方面来看与优化相关的内容：
1. 从运行时的依赖关系来看，对性能有较大影响的组件有 kernel 和 glibc ，虽然这严格说来这不属于本文的话题，但是经过精心选择、精心配置、精心编译的内核与C库将对提高系统的运行速度起着基础性的作用。
2. 从被编译的软件包来看，每个软件包的 configure 脚本都提供了许多配置选项，其中有许多选项是与性能息息相关的。比如，对于 Apache-2.2.6 而言，你可以使用 --enable-MODULE=static 将模块静态编译进核心，使用 --disable-MODULE 禁用不需要的模块，使用 --with-mpm=MPM 选择一个高效的多路处理模块，在不需要IPv6的情况下使用 --disable-ipv6 禁用IPv6支持，在不使用线程化的MPM时使用 --disable-threads 禁用线程支持，等等……这部分内容显然不可能在本文中进行完整的讲述，本文只能讲述与优化相关的通用选项。针对特定的软件包，请在编译前使用 configure --help 查看所有选项，并精心选择。
3. 从编译过程自身来看，将源代码编译为二进制文件是在 Makefile 文件的指导下，由 make 程序调用一条条编译命令完成的。而将源代码编译为二进制文件又需要经过以下四个步骤：预处理(cpp) → 编译(gcc或g++) → 汇编(as) → 连接(ld) ；括号中表示每个阶段所使用的程序，它们分别属于 GCC 和 Binutils 软件包。显然的，优化应当从编译工具自身的选择以及控制编译工具的行为入手。
大体上编译优化就这&quot;三板斧&quot;(其实是&quot;三脚猫&quot;)了，本文接下来的内容将讨论这只猫的后两只脚。

</rich_text><rich_text scale="h2" weight="heavy">编译工具的选择</rich_text><rich_text>
对于编译工具自身的选择，在假定使用 Binutils 和 GCC 以及 Make  的前提下，没什么好说的，基本上新版本都能带来性能提升，同时比老版本对新硬件的支持更好，所以应当尽量选用新版本。不过追新也可能带来系统的不稳定，这 就要针对实际情况进行权衡了。本文以 Binutils-2.18 和 GCC-4.2.2/GCC-4.3.0 以及 Make-3.81  为例进行说明。

</rich_text><rich_text scale="h2" weight="heavy">configure 选项</rich_text><rich_text>
这里我们只讲解通用的&quot;体系结构选项&quot;，由于&quot;特性选项&quot;在每个软件包之间千差万别，所以不可能在此处进行讲解。
这部分内容很简单，并且其含义也是不言而喻的，下面只列出常用的值：
• i586-pc-linux-gnu
• i686-pc-linux-gnu
• x86_64-pc-linux-gnu
• powerpc-unknown-linux-gnu
• powerpc64-unknown-linux-gnu
如果你实在不知道应当使用哪一个，那么就干脆不使用这几个选项，让 config.guess 脚本自己去猜吧，反正也挺准的。

</rich_text><rich_text scale="h2" weight="heavy">编译选项</rich_text><rich_text>
让我们先看看 Makefile 规则中的编译命令通常是怎么写的。
大多数软件包遵守如下约定俗成的规范：
#1,首先从源代码生成目标文件(预处理,编译,汇编)，&quot;-c&quot;选项表示不执行链接步骤。
$(CC) $(CPPFLAGS) $(CFLAGS) example.c   -c   -o example.o
#2,然后将目标文件连接为最终的结果(连接)，&quot;-o&quot;选项用于指定输出文件的名字。
$(CC) $(LDFLAGS) example.o   -o example

#有一些软件包一次完成四个步骤：
$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -o example
当然也有少数软件包不遵守这些约定俗成的规范，比如：
#1,有些在命令行中漏掉应有的Makefile变量(注意：有些遗漏是故意的)
$(CC) $(CFLAGS) example.c    -c   -o example.o
$(CC) $(CPPFLAGS) example.c  -c   -o example.o
$(CC) example.o   -o example
$(CC) example.c   -o example
#2,有些在命令行中增加了不必要的Makefile变量
$(CC) $(CFLAGS) $(LDFLAGS) example.o   -o example
$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -c   -o example.o
当然还有极个别软件包完全是&quot;胡来&quot;：乱用变量(增加不必要的又漏掉了应有的)者有之，不用$(CC)者有之，不一而足.....
尽管将源代码编译为二进制文件的四个步骤由不同的程序(cpp,gcc/g++,as,ld)完成，但是事实上 cpp, as, ld 都是由  gcc/g++ 进行间接调用的。换句话说，控制了 gcc/g++ 就等于控制了所有四个步骤。从 Makefile  规则中的编译命令可以看出，编译工具的行为全靠 CC/CXX CPPFLAGS CFLAGS/CXXFLAGS LDFLAGS  这几个变量在控制。当然理论上控制编译工具行为的还应当有 AS ASFLAGS ARFLAGS 等变量，但是实践中基本上没有软件包使用它们。
那么我们如何控制这些变量呢？一种简易的做法是首先设置与这些 Makefile 变量同名的环境变量并将它们 export 为全局，然后运行  configure 脚本，大多数 configure 脚本会使用这同名的环境变量代替 Makefile 中的值。但是少数 configure  脚本并不这样做(比如GCC-3.4.6和Binutils-2.16.1的脚本就不传递LDFLAGS)，你必须手动编辑生成的 Makefile  文件，在其中寻找这些变量并修改它们的值，许多源码包在每个子文件夹中都有 Makefile 文件，真是一件很累人的事！

</rich_text><rich_text scale="h3" weight="heavy">CC 与 CXX</rich_text><rich_text>
这是 C 与 C++ 编译器命令。默认值一般是 &quot;gcc&quot; 与  &quot;g++&quot;。这个变量本来与优化没有关系，但是有些人因为担心软件包不遵守那些约定俗成的规范，害怕自己苦心设置的  CFLAGS/CXXFLAGS/LDFLAGS 之类的变量被忽略了，而索性将原本应当放置在其它变量中的选项一股老儿塞到 CC 或 CXX  中，比如：CC=&quot;gcc -march=k8 -O2 -s&quot;。这是一种怪异的用法，本文不提倡这种做法，而是提倡按照变量本来的含义使用变量。

</rich_text><rich_text scale="h3" weight="heavy">CPPFLAGS</rich_text><rich_text>
这是用于预处理阶段的选项。不过能够用于此变量的选项，看不出有哪个与优化相关。如果你实在想设一个，那就使用下面这两个吧：
-DNDEBUG&quot;NDEBUG&quot;是一个标准的 ANSI 宏，表示不进行调试编译。-D_FILE_OFFSET_BITS=64大多数包使用这个来提供大文件(&gt;2G)支持。

</rich_text><rich_text scale="h3" weight="heavy">CFLAGS 与 CXXFLAGS</rich_text><rich_text>
    CFLAGS 表示用于 C 编译器的选项，CXXFLAGS 表示用于 C++  编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤。大多数程序和库在编译时默认的优化级别是&quot;2&quot;(使用&quot;-O2&quot;选项)并且带有调试符号来编 译，也就是 CFLAGS=&quot;-O2 -g&quot;, CXXFLAGS=$CFLAGS  。事实上，&quot;-O2&quot;已经启用绝大多数安全的优化选项了。另一方面，由于大部分选项可以同时用于这两个变量，所以仅在最后讲述只能用于其中一个变量的选 项。[提醒]下面所列选项皆为非默认选项，你只要按需添加即可。

先说说&quot;-O3&quot;在&quot;-O2&quot;基础上增加的几项：
-finline-functions
    允许编译器选择某些简单的函数在其被调用处展开，比较安全的选项，特别是在CPU二级缓存较大时建议使用。-funswitch-loops将循环体中不改变值的变量移动到循环体之外。-fgcse-after-reload为了清除多余的溢出，在重载之后执行一个额外的载入消除步骤。另外：
-fomit-frame-pointer
    对于不需要栈指针的函数就不在寄存器中保存指针，因此可以忽略存储和检索地址的代码，同时对许多函数提供一个额外的寄存器。所有&quot;-O&quot;级别都打开它，但仅在调试器可以不依靠栈指针运行时才有效。在AMD64平台上此选项默认打开，但是在x86平台上则默认关闭。建议显式的设置它。-falign-functions=N
-falign-jumps=N
-falign-loops=N
-falign-labels=N
    这四个对齐选项在&quot;-O2&quot;中打开，其中的根据不同的平台N使用不同的默认值。如果你想指定不同于默认值的N，也可以单独指定。比如，对于L2-cache&gt;=1M的cpu而言，指定 -falign-functions=64 可能会获得更好的性能。建议在指定了 -march 的时候不明确指定这里的值。调试选项：
-fprofile-arcs
    在使用这一选项编译程序并运行它以创建包含每个代码块的执行次数的文件后，程序可以再次使用 -fbranch-probabilities 编译，文件中的信息可以用来优化那些经常选取的分支。如果没有这些信息，gcc将猜测哪个分支将被经常运行以进行优化。这类优化信息将会存放在一个以源文件为名字的并以&quot;.da&quot;为后缀的文件中。全局选项：
-pipe
    在编译过程的不同阶段之间使用管道而非临时文件进行通信，可以加快编译速度。建议使用。目录选项：
--sysroot=dir
    将dir作为逻辑根目录。比如编译器通常会在 /usr/include 和 /usr/lib 中搜索头文件和库，使用这个选项后将在 dir/usr/include 和 dir/usr/lib 目录中搜索。如果使用这个选项的同时又使用了 -isysroot 选项，则此选项仅作用于库文件的搜索路径，而 -isysroot 选项将作用于头文件的搜索路径。这个选项与优化无关，但是在 CLFS 中有着神奇的作用。代码生成选项：
-fno-bounds-check
    关闭所有对数组访问的边界检查。该选项将提高数组索引的性能，但当超出数组边界时，可能会造成不可接受的行为。-freg-struct-return如果struct和union足够小就通过寄存器返回，这将提高较小结构的效率。如果不够小，无法容纳在一个寄存器中，将使用内存返回。建议仅在完全使用GCC编译的系统上才使用。-fpic生成可用于共享库的位置独立代码。所有的内部寻址均通过全局偏移表完成。要确定一个地址，需要将代码自身的内存位置作为表中一项插入。该选项产生可以在共享库中存放并从中加载的目标模块。-fstack-check为防止程序栈溢出而进行必要的检测，仅在多线程环境中运行时才可能需要它。-fvisibility=hidden设置默认的ELF镜像中符号的可见性为隐藏。使用这个特性可以非常充分的提高连接和加载共享库的性能，生成更加优化的代码，提供近乎完美的API输出和防止符号碰撞。我们强烈建议你在编译任何共享库的时候使用该选项。参见 -fvisibility-inlines-hidden 选项。硬件体系结构相关选项[仅仅针对x86与x86_64]：
-march=cpu-type
    为特定的cpu-type编译二进制代码(不能在更低级别的cpu上运行)。Intel可以用：pentium2, pentium3(=pentium3m), pentium4(=pentium4m), pentium-m, prescott, nocona, core2(GCC-4.3新增) 。AMD可以用：k6-2(=k6-3), athlon(=athlon-tbird), athlon-xp(=athlon-mp), k8(=opteron=athlon64=athlon-fx)-mfpmath=sseP3和athlon-xp级别及以上的cpu支持&quot;sse&quot;标量浮点指令。仅建议在P4和K8以上级别的处理器上使用该选项。-malign-double将double, long double, long long对齐于双字节边界上；有助于生成更高速的代码，但是程序的尺寸会变大，并且不能与未使用该选项编译的程序一起工作。-m128bit-long-double指定long double为128位，pentium以上的cpu更喜欢这种标准，并且符合x86-64的ABI标准，但是却不附合i386的ABI标准。-mregparm=N指定用于传递整数参数的寄存器数目(默认不使用寄存器)。0&lt;=N&lt;=3 ；注意：当N&gt;0时你必须使用同一参数重新构建所有的模块，包括所有的库。-msseregparm使用SSE寄存器传递float和double参数和返回值。注意：当你使用了这个选项以后，你必须使用同一参数重新构建所有的模块，包括所有的库。-mmmx
-msse
-msse2
-msse3
-m3dnow
-mssse3(没写错!GCC-4.3新增)
-msse4.1(GCC-4.3新增)
-msse4.2(GCC-4.3新增)
-msse4(含4.1和4.2,GCC-4.3新增)
    是否使用相应的扩展指令集以及内置函数，按照自己的cpu选择吧！
-maccumulate-outgoing-args
    指定在函数引导段中计算输出参数所需最大空间，这在大部分现代cpu中是较快的方法；缺点是会明显增加二进制文件尺寸。
-mthreads
    支持Mingw32的线程安全异常处理。对于依赖于线程安全异常处理的程序，必须启用这个选项。使用这个选项时会定义&quot;-D_MT&quot;，它将包含使用选项&quot;-lmingwthrd&quot;连接的一个特殊的线程辅助库，用于为每个线程清理异常处理数据。
-minline-all-stringops
    默认时GCC只将确定目的地会被对齐在至少4字节边界的字符串操作内联进程序代码。该选项启用更多的内联并且增加二进制文件的体积，但是可以提升依赖于高速 memcpy, strlen, memset 操作的程序的性能。
-minline-stringops-dynamically
    GCC-4.3新增。对未知尺寸字符串的小块操作使用内联代码，而对大块操作仍然调用库函数，这是比&quot;-minline-all-stringops&quot;更聪明的策略。决定策略的算法可以通过&quot;-mstringop-strategy&quot;控制。
-momit-leaf-frame-pointer
    不为叶子函数在寄存器中保存栈指针，这样可以节省寄存器，但是将会使调试变的困难。注意：不要与 -fomit-frame-pointer 同时使用，因为会造成代码效率低下。
-m64
    生成专门运行于64位环境的代码，不能运行于32位环境，仅用于x86_64[含EMT64]环境。
-mcmodel=small
    [默认值]程序和它的符号必须位于2GB以下的地址空间。指针仍然是64位。程序可以静态连接也可以动态连接。仅用于x86_64[含EMT64]环境。
-mcmodel=kernel
    内核运行于2GB地址空间之外。在编译linux内核时必须使用该选项！仅用于x86_64[含EMT64]环境。
-mcmodel=medium
    程序必须位于2GB以下的地址空间，但是它的符号可以位于任何地址空间。程序可以静态连接也可以动态连接。注意：共享库不能使用这个选项编译！仅用于x86_64[含EMT64]环境。其它优化选项：
-fforce-addr
    必须将地址复制到寄存器中才能对他们进行运算。由于所需地址通常在前面已经加载到寄存器中了，所以这个选项可以改进代码。
-finline-limit=n
    对伪指令数超过n的函数，编译程序将不进行内联展开，默认为600。增大此值将增加编译时间和编译内存用量并且生成的二进制文件体积也会变大，此值不宜太大。
-fmerge-all-constants
    试图将跨编译单元的所有常量值和数组合并在一个副本中。但是标准C/C++要求每个变量都必须有不同的存储位置，所以该选项可能会导致某些不兼容的行为。
-fgcse-sm
    在全局公共子表达式消除之后运行存储移动，以试图将存储移出循环。gcc-3.4中曾属于&quot;-O2&quot;级别的选项。
-fgcse-las
    在全局公共子表达式消除之后消除多余的在存储到同一存储区域之后的加载操作。gcc-3.4中曾属于&quot;-O2&quot;级别的选项。
-floop-optimize
    已废除(GCC-4.1曾包含在&quot;-O1&quot;中)。
-floop-optimize2
    使用改进版本的循环优化器代替原来&quot;-floop-optimize&quot;。该优化器将使用不同的选项(-funroll-loops, -fpeel-loops, -funswitch-loops, -ftree-loop-im)分别控制循环优化的不同方面。目前这个新版本的优化器尚在开发中，并且生成的代码质量并不比以前的版本高。已废除，仅存在于GCC-4.1之前的版本中。
-funsafe-loop-optimizations
    假定循环不会溢出，并且循环的退出条件不是无穷。这将可以在一个比较广的范围内进行循环优化，即使优化器自己也不能断定这样做是否正确。
-fsched-spec-load
    允许一些装载指令执行一些投机性的动作。
-ftree-loop-linear
    在trees上进行线型循环转换。它能够改进缓冲性能并且允许进行更进一步的循环优化。
-fivopts
    在trees上执行归纳变量优化。
-ftree-vectorize
    在trees上执行循环向量化。
-ftracer
    执行尾部复制以扩大超级块的尺寸，它简化了函数控制流，从而允许其它的优化措施做的更好。据说挺有效。
-funroll-loops
    仅对循环次数能够在编译时或运行时确定的循环进行展开，生成的代码尺寸将变大，执行速度可能变快也可能变慢。
-fprefetch-loop-arrays
    生成数组预读取指令，对于使用巨大数组的程序可以加快代码执行速度，适合数据库相关的大型软件等。具体效果如何取决于代码。
-fweb
    建立经常使用的缓存器网络，提供更佳的缓存器使用率。gcc-3.4中曾属于&quot;-O3&quot;级别的选项。
-ffast-math
    违反IEEE/ANSI标准以提高浮点数计算速度，是个危险的选项，仅在编译不需要严格遵守IEEE规范且浮点计算密集的程序考虑采用。
-fsingle-precision-constant
    将浮点常量作为单精度常量对待，而不是隐式地将其转换为双精度。
-fbranch-probabilities
    在使用 -fprofile-arcs 选项编译程序并执行它来创建包含每个代码块执行次数的文件之后，程序可以利用这一选项再次编译，文件中所产生的信息将被用来优化那些经常发生的分支代码。如果没有这些信息，gcc将猜测那一分支可能经常发生并进行优化。这类优化信息将会存放在一个以源文件为名字的并以&quot;.da&quot;为后缀的文件中。
-frename-registers
    试图驱除代码中的假依赖关系，这个选项对具有大量寄存器的机器很有效。gcc-3.4中曾属于&quot;-O3&quot;级别的选项。
-fbranch-target-load-optimize
-fbranch-target-load-optimize2
    在执行序启动以及结尾之前执行分支目标缓存器加载最佳化。
-fstack-protector
    在关键函数的堆栈中设置保护值。在返回地址和返回值之前，都将验证这个保护值。如果出现了缓冲区溢出，保护值不再匹配，程序就会退出。程序每次运行，保护值都是随机的，因此不会被远程猜出。
-fstack-protector-all
    同上，但是在所有函数的堆栈中设置保护值。
--param max-gcse-memory=xxM
    执行GCSE优化使用的最大内存量(xxM)，太小将使该优化无法进行，默认为50M。
--param max-gcse-passes=n执行GCSE优化的最大迭代次数，默认为 1。

</rich_text><rich_text weight="heavy">传递给汇编器的选项：</rich_text><rich_text>
-Wa,optionsoptions
    是一个或多个由逗号分隔的可以传递给汇编器的选项列表。其中的每一个均可作为命令行选项传递给汇编器。
-Wa,--strip-local-absolute
    从输出符号表中移除局部绝对符号。-Wa,-R合并数据段和正文段，因为不必在数据段和代码段之间转移，所以它可能会产生更短的地址移动。
-Wa,--64
    设置字长为64bit，仅用于x86_64，并且仅对ELF格式的目标文件有效。此外，还需要使用&quot;--enable-64-bit-bfd&quot;选项编译的BFD支持。
-Wa,-march=CPU
    按照特定的CPU进行优化：pentiumiii, pentium4, prescott, nocona, core, core2; athlon, sledgehammer, opteron, k8 。仅可用于 CFLAGS 的选项：
-fhosted
    按宿主环境编译，其中需要有完整的标准库，入口必须是main()函数且具有int型的返回值。内核以外几乎所有的程序都是如此。该选项隐含设置了 -fbuiltin，且与 -fno-freestanding 等价。
-ffreestanding
    按独立环境编译，该环境可以没有标准库，且对main()函数没有要求。最典型的例子就是操作系统内核。该选项隐含设置了 -fno-builtin，且与 -fno-hosted 等价。
    
</rich_text><rich_text weight="heavy">仅可用于 CXXFLAGS 的选项：</rich_text><rich_text>
-fno-enforce-eh-specs
    C++标准要求强制检查异常违例，但是该选项可以关闭违例检查，从而减小生成代码的体积。该选项类似于定义了&quot;NDEBUG&quot;宏。-fno-rtti如果没有使用'dynamic_cast'和'typeid'，可以使用这个选项禁止为包含虚方法的类生成运行时表示代码，从而节约空间。此选项对于异常处理无效(仍然按需生成rtti代码)。
-ftemplate-depth-n
    将最大模版实例化深度设为'n'，符合标准的程序不能超过17，默认值为500。
-fno-optional-diags
    禁止输出诊断消息，C++标准并不需要这些消息。
-fno-threadsafe-staticsGCC
    自动在访问C++局部静态变量的代码上加锁，以保证线程安全。如果你不需要线程安全，可以使用这个选项。
-fvisibility-inlines-hidden
    默认隐藏所有内联函数，从而减小导出符号表的大小，既能缩减文件的大小，还能提高运行性能，我们强烈建议你在编译任何共享库的时候使用该选项。参见 -fvisibility=hidden 选项。

</rich_text><rich_text scale="h3" weight="heavy">LDFLAGS</rich_text><rich_text>
LDFLAGS 是传递给连接器的选项。这是一个常被忽视的变量，事实上它对优化的影响也是很明显的。
-s
    删除可执行程序中的所有符号表和所有重定位信息。其结果与运行命令 strip 所达到的效果相同，这个选项是比较安全的。
-Wl,options
    options是由一个或多个逗号分隔的传递给链接器的选项列表。其中的每一个选项均会作为命令行选项提供给链接器。
-Wl,-On当n&gt;0时将会优化输出，但是会明显增加连接操作的时间，这个选项是比较安全的。
-Wl,--exclude-libs=ALL
    不自动导出库中的符号，也就是默认将库中的符号隐藏。
-Wl,-m&lt;emulation&gt;
    仿真&lt;emulation&gt;连接器，当前ld所有可用的仿真可以通过&quot;ld -V&quot;命令获取。默认值取决于ld的编译时配置。
-Wl,--sort-common
    把全局公共符号按照大小排序后放到适当的输出节，以防止符号间因为排布限制而出现间隙。
-Wl,-x
    删除所有的本地符号。
-Wl,-X
    删除所有的临时本地符号。对于大多数目标平台，就是所有的名字以'L'开头的本地符号。
-Wl,-zcomberloc
    组合多个重定位节并重新排布它们，以便让动态符号可以被缓存。
-Wl,--enable-new-dtags
    在ELF中创建新式的&quot;dynamic tags&quot;，但在老式的ELF系统上无法识别。
-Wl,--as-needed
    移除不必要的符号引用，仅在实际需要的时候才连接，可以生成更高效的代码。
-Wl,--no-define-common
    限制对普通符号的地址分配。该选项允许那些从共享库中引用的普通符号只在主程序中被分配地址。这会消除在共享库中的无用的副本的空间，同时也防止了在有多个指定了搜索路径的动态模块在进行运行时符号解析时引起的混乱。
-Wl,--hash-style=gnu
    使用gnu风格的符号散列表格式。它的动态链接性能比传统的sysv风格(默认)有较大提升，但是它生成的可执行程序和库与旧的Glibc以及动态链接器不兼容。最后说两个与优化无关的系统环境变量，因为会影响GCC编译程序的方式，下面两个是咱中国人比较关心的：
LANG
    指定编译程序使用的字符集，可用于创建宽字符文件、串文字、注释；默认为英文。[目前只支持日文&quot;C-JIS,C-SJIS,C-EUCJP&quot;，不支持中文]
LC_ALL
    指定多字节字符的字符分类，主要用于确定字符串的字符边界以及编译程序使用何种语言发出诊断消息；默认设置与LANG相同。中文相关的几项：&quot;zh_CN.GB2312 , zh_CN.GB18030 , zh_CN.GBK , zh_CN.UTF-8 , zh_TW.BIG5&quot;。</rich_text></node><node name="list" prog_lang="custom-colors" readonly="False" tags="" unique_id="9"><rich_text>struct list_head {
	struct list_head *next, *prev;
};

</rich_text><node name="hlist" prog_lang="custom-colors" readonly="False" tags="" unique_id="10"><rich_text>/*
 * Double linked lists with a single pointer list head.
 * Mostly useful for hash tables where the two pointer list head is
 * too wasteful.
 * You lose the ability to access the tail in O(1). 只能通过next指针一个一个往下访问。
 */
</rich_text><rich_text justification="left"></rich_text><rich_text>
struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next, **pprev;
};

hlist_head结构体只有一个域，即first。 
    </rich_text><rich_text foreground="#ffff00000000">first指针指向该hlist链表的第一个节点。</rich_text><rich_text>
hlist_node结构体有两个域，next 和pprev。 
    </rich_text><rich_text foreground="#ffff00000000">next指针很容易理解，它指向下个hlist_node结点，倘若该节点是链表的最后一个节点，next指向NULL。
    pprev是一个二级指针， 它指向前一个节点的next指针; 如果是第一个hlist_node, 其pprev指向hlist_head的first指针。</rich_text><rich_text>
    为什么我们需要这样一个指针呢？它的好处是什么？
    在回答这个问题之前，我们先研究另一个问题：为什么散列表的实现需要两个不同的数据结构？
    散列表的目的是为了方便快速的查找，所以散列表通常是一个比较大的数组，否则“冲突”的概率会非常大，  这样也就失去了散列表的意义。如何做到既能维护一张大表，又能不使用过多的内存呢？就只能从数据结构上下功夫了。所以对于散列表的每个entry，它的结构体中只存放一个指针，解决了占用空间的问题。现在又出现了另一个问题：数据结构不一致。显然，如果hlist_node采用传统的next,prev指 针， 对于第一个节点和后面其他节点的处理会不一致。这样并不优雅，而且效率上也有损失。
    hlist_node巧妙地将pprev指向上一个节点的next指针的地址，由于hlist_head和hlist_node指向的下一个节点的指针类型相同，这样就解决了通用性！

#define HLIST_HEAD_INIT { .first = NULL }
#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)
static inline void INIT_HLIST_NODE(struct hlist_node *h)
{
	h-&gt;next = NULL;
	h-&gt;pprev = NULL;
}

static inline int hlist_unhashed(const struct hlist_node *h)
{
	return !h-&gt;pprev;
}
这个函数的目的是判断该节点是否已经存在hash表中。这里处理得很巧妙。 判断前一个节点的next指向的地址是否为空。

static inline int hlist_empty(const struct hlist_head *h)
{
	return !h-&gt;first;
}

static inline void __hlist_del(struct hlist_node *n)
{
	struct hlist_node *next = n-&gt;next;          //结构体指针变量next存储的值
	struct hlist_node **pprev = n-&gt;pprev;   //pprev = &amp;prev-&gt;next, 结构体指针变量next的地址
	*pprev = next;                          //相当于prev-&gt;next = next
	if (next)
		next-&gt;pprev = pprev;            //相当于next-&gt;pprev=&amp;prev-&gt;next
}
__hlist_del用于删除节点n。
    首先获取n的下一个节点next， n-&gt;pprev指向n的前一个节点的next指针的地址，  这样×pprev就代表n前一个节点的下一个节点（现在即n本身），第三行代码*pprev=next;就将n的前一个节点和下一个节点关联起来了。至 此，n节点的前一个节点的关联工作就完成了，现在再来完成下一个节点的关联工作。如果n是链表的最后一个节点，那么n-&gt;next即为空，  则无需任何操作，否则，next-&gt;pprev = pprev。

static inline void hlist_del(struct hlist_node *n)
{
	__hlist_del(n);
	n-&gt;next = LIST_POISON1;
	n-&gt;pprev = LIST_POISON2;
}

static inline void hlist_del_init(struct hlist_node *n)
{
	if (!hlist_unhashed(n)) {
		__hlist_del(n);
		INIT_HLIST_NODE(n);
	}
}

给链表增加一个节点需要考虑两个条件：(1)是否为链表的首个节点(2)普通节点
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
	struct hlist_node *first = h-&gt;first;
	n-&gt;next = first;
	if (first)
		first-&gt;pprev = &amp;n-&gt;next;
	h-&gt;first = n;
	n-&gt;pprev = &amp;h-&gt;first;               </rich_text><rich_text foreground="#ffff00000000">//等于head-&gt;first的地址</rich_text><rich_text>
}
首先讨论条件（1）。
first = h-&gt;first; 获取当前链表的首个节点；
n-&gt;next = fist;  将n作为链表的首个节点，让first往后靠；
先来看最后一行 n-&gt;pprev - &amp;h-&gt;first; 将n的pprev指向hlist_head的first指针，至此关于节点n的关联工作就做完了。
再来看倒数第二行 h-&gt;first = n; 将节点h的关联工作做完；
最后我们再来看原先的第一个节点的关联工作，对于它来说，仅仅需要更新一下pprev的关联信息： first-&gt;pprev = &amp;n-&gt;next;

接下来讨论条件（2）。 这里也包括两种情况：a)插在当前节点的前面b)插在当前节点的后面
/* next must be != NULL */
static inline void hlist_add_before(struct hlist_node *n,
					struct hlist_node *next)
{
	n-&gt;pprev = next-&gt;pprev;
	n-&gt;next = next;
	next-&gt;pprev = &amp;n-&gt;next;
	*(n-&gt;pprev) = n;
}
先讨论情况a) 将节点n 插到next之前  （n是新插入的节点)
还是一个一个节点的搞定（一共三个节点）， 先搞定节点n
n-&gt;pprev = next-&gt;prev;   将 next 的pprev 赋值给n-&gt;pprev  n取代next的位置
n-&gt;next = next;   将next作为n的下一个节点， 至此节点n的关联动作完成。
next-&gt;pprev = &amp;n-&gt;next; next的关联动作完成。
*(n-&gt;pprev) = n;   n-&gt;pprev表示n的前一个节点的next指针； *(n-&gt;pprev)则表示n的前一个节点next指针所指向下一个节点的内容， 这里将n赋值给它，正好完成它的关联工作。

static inline void hlist_add_after(struct hlist_node *n,
					struct hlist_node *next)
{
	next-&gt;next = n-&gt;next;
	n-&gt;next = next;
	next-&gt;pprev = &amp;n-&gt;next;

	if(next-&gt;next)
		next-&gt;next-&gt;pprev  = &amp;next-&gt;next;
}
再来看情况b) 将结点next插入到n之后 (next是新插入的节点）

/* after that we'll appear to be on some hlist and hlist_del will work */
static inline void hlist_add_fake(struct hlist_node *n)
{
	n-&gt;pprev = &amp;n-&gt;next;
}

/*
 * Move a list from one list head to another. Fixup the pprev
 * reference of the first entry if it exists.
 */
static inline void hlist_move_list(struct hlist_head *old,
				   struct hlist_head *new)
{
	new-&gt;first = old-&gt;first;
	if (new-&gt;first)
		new-&gt;first-&gt;pprev = &amp;new-&gt;first;
	old-&gt;first = NULL;
}

在遍历上，如果使用hlist_hode, list_node指针进行遍历，两者过程大致相似。
#define hlist_entry(ptr, type, member) container_of(ptr,type,member)

#define hlist_for_each(pos, head) \
	for (pos = (head)-&gt;first; pos ; pos = pos-&gt;next)
	
#define hlist_for_each_safe(pos, n, head) \
	for (pos = (head)-&gt;first; pos &amp;&amp; ({ n = pos-&gt;next; 1; }); \
	     pos = n)

/**
 * hlist_for_each_entry	- iterate over list of given type
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &amp;struct hlist_node to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(tpos, pos, head, member)			 \
	for (pos = (head)-&gt;first;					 \
	     pos &amp;&amp;							 \
		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
	     pos = pos-&gt;next)

/**
 * hlist_for_each_entry_continue - iterate over a hlist continuing after current point
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &amp;struct hlist_node to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_continue(tpos, pos, member)		 \
	for (pos = (pos)-&gt;next;						 \
	     pos &amp;&amp;							 \
		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
	     pos = pos-&gt;next)

/**
 * hlist_for_each_entry_from - iterate over a hlist continuing from current point
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &amp;struct hlist_node to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_from(tpos, pos, member)			 \
	for (; pos &amp;&amp;							 \
		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
	     pos = pos-&gt;next)

/**
 * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &amp;struct hlist_node to use as a loop cursor.
 * @n:		another &amp;struct hlist_node to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_safe(tpos, pos, n, head, member) 		 \
	for (pos = (head)-&gt;first;					 \
	     pos &amp;&amp; ({ n = pos-&gt;next; 1; }) &amp;&amp; 				 \
		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
	     pos = n)

    如果使用其寄生结构的指针进行遍历，则hlist与list也略有不同，hlist在遍历时需要一个指向hlist_node的临时指针，该指针的引入，一是为了遍历，而list的遍历在list_entry的参数中实现了，更主要的目的在于判断结束，因为hlist最后一个节点的next为NULL，只有hlist_node指向NULL时才算结束，而这个NULL不包含在任何寄生结构内，不能通过tpos-&gt;member的方式访问到，故临时变量pos的引入时必须的。

    另外，list和hlist的遍历都实现了safe版本，因在遍历时，没有任何特别的东西来阻止对链表执行删除操作（通常在使用链表时使用锁来保护并发访问）。安全版本的遍历函数使用临时存放的方法使得检索链表时能不被删除操作所影响。
    
</rich_text><encoded_png char_offset="220">iVBORw0KGgoAAAANSUhEUgAAAm0AAAD8CAIAAACqzAQmAAAAA3NCSVQICAjb4U/gAAAgAElEQVR4nOydWXPjxnr3GwDBfaekWbzG55ykKqnKB8j3r8pVLnKSSiq2j2OP7RmNxJ0gFmLp9+IXPG+bGsmWRHGR+n+hokgQbPTy7IujtVYWFhYWFhYWD4J76AFYWFhYWFicMCwftbCwsLCweDgsH7WwsLCwsHg4LB+1sLCwsLB4OCwftbCwsLCweDgsH7WwsLCwsHg4LB+1sLCwsLB4OA7JR7Msi+N4s9nwb5IkvMjzPI7jPM/lyqIobrtJURRyh6IosixTSt2RFMtHWZbJPTebzR33t7CwsLCwuAPOoeowxHFcr9eVUlrrzWbj+77ruuv12vM8eT8Igmaz6XneZrOpVqt33C3LMsdxHMdxXTeO42q16rqfFhHgu/V6vSgKrbXWulKpPMUDWlhYWFi8BBxMH4V7xXEcRVGtVptOp1mWtVqter2epmkYhkEQdDodrrmDiaKMVioVz/OQCebz+W1MVCnluu58PldKaa09z2MYotFaWFhYWFjcCwfTR5VSq9UKTlkUBZzv6urq4uKCT1FYkySpVqta6ztYo1Iqz3P0y7vVVhObzQb91fO8xz2HhYWFhcXLxSH9o41Ggxfr9VoplaYpTPTq6kprjWKqlHIcx/SV3kSe53me+75frVa51c8//3zbxXy0Xq+r1arv+3x3d89kYWFhYfGycDB9dLlctlotz/PSNEUpTNPU9325QJRU8aR+EnBB0Sm11o7j/O6vm5dt3cHCwsLCwuKP42D6aLfb9TyvKIowDD3Pm0wmvu+v12tclev12nXdIAi4+A6V0fM8ePBmswmCwHGc77///u6f/v777x3HCYJgs9mkacoddvhoFhYWFhYvB4f0j0ZR1O/3i6JYLBb9fj9NUwbjOE6tVovjOMsyrbXv+3fE66LFii6b53mz2dxsNrc9l+M41WoV5n3z6xYWFhYWFvfCwfTRoijq9Xqz2cyyDFco+S2onr7vO45TqVQkqVQpRWaL7/u+79dqNcdxPM9rNpuO47TbbaXUYrHgJkThSjpplmV5CaXUZrPxPG+1WvFDV1dXvu+j+wZBgFM2iqIDTIqFhYWFxanhYKmTrVYrjmOlVL1ehx2GYdjv95MkqdfrQRBorfM8b7fb6/W61WoppYqicBxnuVw2Go1qtVqr1ZbLJXrq5eWlKgOXKpVKlmVBELTbbdd1SYlJ07TX683n81qtliTJcDiczWbVarVSqTiOs16vtdZRFDUaDc/zkiSBE/POoabIwsLCwuL4cTC7LizKcZxGozGZTJrNZq1WWywW1Wq10WikaUogkpkbo8qkTxyrWussy7DHStzQarXqdrsUWMBayw/FcbxYLF69euW6rtZ6sVh0u90wDGu1mpRimM/n/X5fKQUPPsi0WFhYWFicFg7GR/M8D4IAviVcUGs9nU6/+eabxWKhlOr3+4vFghGuVivhbY7j1Ov1OI5RPXmz3W5vNhvU2SRJzOeCEwdB4LouSi26abvdDoKgVqvN53OttaieUjvQ87y781YtLCwsLF44DsZHq9Wq4zhFURRFgd1VKdVut2u12mQy0VrjGcXqC7MMw1AphUNUldzOcZy3b9/++OOPGHhhyfKVLMsmk8mrV6/Ehlyr1YqiWC6XnudVq1UUU7nher2GW6OSSu6NhYWFhYXFJ3HIeN0kSWq1mlJqsVg4jtPtduM43lIKiSGaz+dxHOMldRznzZs379+/p778aDQKw1BrjdK5Wq2wFUtlwVevXn38+FE011arhcN1vV5TZZfCRo7jkMn63Xff/eUvf1F/OBXVwsLCwuIl45B8FC7V6XRWq5Vpwn379u18Pp/NZq1Wq9vtXl5e+r4/nU6HwyEpMaS1ZFk2GAxWq5VwXKVUkiRv376dTCbUvl8ul91ul+8qpXCOjkajH3/8sd1uZ1lmFqnP81wSSSn+YB2lFhYWFhZ348B8FNMuCiKq52q1ms1mZ2dnlAMk+IhuMCS9xHFMwC2mWryb9XpdbLNyH5NNSkQSmij5qap0taIQ+76vtQ7DEMVXQpwsLCwsLCxuw+H1UaWU7/tFUZDcaSqXtVotyzLav7RarTzP4aYwSKJwSY/xPM9xnH6/Px6P4Z04O1utFjUc0ERVyWhrtVoYhmmaDgaDKIpg51LtYTabUW7pUDNjYWFhYXEqOFgQTRzHnU6HXi7z+VwCfAgvotx8URQ///yz4zgoiHmew18rlUpRFJheiarlnjREGw6HsFJChKjYIOomNZKSJPE87/Xr11EUaa25G8UClVKDwcDzPD46yORYWFhYWJwKjkIf7ff7VE5QRs5Jo9GA581ms3q9XqlUfN8fj8fD4VBrbXpG1+s1zV6UUuS9KCNKqF6vo3HW6/XpdNpoNNA7KcXAHa6urvr9PncIw5CiELVazaqkFhYWFhZ342D1jDabDdmcaIcwQpyXzWZTfJmO8xtOf3Z2pkoGjC+zUqnU63W5Bk307OwMbZJSDCiyruuimyqlrq+vp9MpzHW5XF5cXHC3JEkGg0Ge53Ecw02bzeb+J8fCwsLC4lRwyOTITqcjUT+UqqeGURzH2GbX6/VgMMiyLEmSPM+vr69VGRkE46TtqOd54lWtVCrD4XA8HqN9wo9xjoZh2G63e72e1rrX64mBt1arua47GAw2m81gMBiPx57nofUecHIsLCwsLE4CB7brYqq9uLggleXVq1eXl5emuolntNPpEPuDAvrhw4dKpdJqtWCT79+/f/v2LdZaiQHmJyR0yHEc9MvFYlGr1QgAXiwWvV6Pn0MP5ltZlsVxbDNeLCwsLCx+FwfmoySoKKXgYe/evTs/P3/9+vWHDx8wycIXKZVA7A8pLqKP8v5kMhmNRuITpdC853nT6bTb7eJbRQHlp/M8T9O0Xq+bllvpnkbkEUWRzARTCwsLCwuLLRyMj5KdSbAuxltyV/iU+gn8FVZHiV3HcSg9z6dSPGGrKK5oolhuSY+hERstXyilpMrAIhkYbdcwBdt6RhYWFhYWd+OQ+qiFhYWFhcWpwxZht7CwsLCweDgsH7WwsLCwsHg4LB+1sLCwsLB4OCwftbCwsLCweDgsH7WwsLCwsHg4LB+1sLCwsLB4OCwftbCwsLCweDjuzUcpP5SmqfnvC0SWZVEUKaU2mw2dU/lrYWFhYfGi8JA6DOPx+M9//vN6vc6yrF6vU2PvKQZ3zKAoUrVaDYKAaoJZllGk8NBDs7CwsLDYH+7NR6nJR8E8eMnTDOw0UK1WkyT58ccfX7161Wg0pEihhYWFhcULwQPrAjqO8/bt27/97W80zZ7NZoPBYNdjO3ZIXxr+tc1KLSwsLF4gHshHK5UKza6TJOl2u0opaVX2QuC6ruM4r1+//p//+R/f9xuNhtY6yzJsvBYWFhYWLwSP4qN8d7VaVSqVRqOx67EdNYRlaq2lM4zts2ZhYWHx0vAQPpqmKR2zaf/Jmy+tb4zjOLVajfbjquzOduhBWVhYWFjsG/fOeyGUhg6djuMsFgul1GazeYKxHTs2m02z2QyCQCnl+34URS9NmLCwsLCwuDcfdRzHdd0sy0iXbLVaSinU0xcFZiMMQ2ZAKVWv152n7/u9Xq95kWUZL2Dkt6EoCnqYY39+6uH9cZB5zODlWU4CxKgXRXFbTEAYhr871Twyj7/PJGzGTOrz1psnAfY/f/M8N6eO7DvyuaFOPFdRFGEYRlHEv4j+qlyCLMtms5lcLFvRvDOHSJUKg6gNXDydTpVxMCUJcLlcKqXCMFRKxXEsd5Of4KOjTXkQwsKMMVoGz4wpY87NyeeJWAJ2mhjtVqvV3qgQA5blvptOPhK2ntGJAbbNxmXvttvtO+ig67rr9drzPNj/YrE4LNEUctPpdFarVbvdZpAHHNJ9gQE/CAKGLXRhuVxyVpvN5u9ONd9tt9ur1arT6fCmTM7TAbJSrVblnTzPT2j+W63WDz/8QJpAlmWdTgd2dX197ft+EATVapXcsyRJXNdlmZrNZqPRcF13s9n0er04joUXVioVcg3W63UQBFprjhWLcn19zWVa6ziOyRdn9qbTaaVSSdN0OBymaUq0RJIksugEYDabzSiKGHAYhsvlUkIoms1mmqae5+1h3e8LrTVnM8uyXq/37t07RktkDDMWRZHv+1dXV9Vq1ff9xWLB5NdqNTHOETeDUFKr1SqViuM4exAd0jRtNpvv3r3r9Xrw/na7/XQs/N7+0aIosOgqpYhQfbGRNUxCURSO4/B3D/qoUirLMq015xYqvFgser3eJy++urq6uLjYbDZFUXieB63hhBwKoor1+32l1HK5hOKcBMifNnOc4jiu1Wqy9Og35+fnv3srefD5fM6K7O0oZVm2Wq2ghqfl2nddF0aF6gOZhgo5joPRxXVdyBpbfTqdDofDd+/effnll6pcwTiO6/V6FEW1Wi1N081mI9IMxpsoisx34M1xHFcqFVlfbqW1DoKg0+nIycqyDKfPZDJptVpYqoTSRlHEfTqdjjDgI0SSJJVKxfO8zWZTrVbZrkwFT5okida6Xq/DFLgsSZL1ej0cDpVSTGO9XkdQYyH2lh/IgBlVnudZlj3dPj8ZOdRC4DgO+7IoCujIbUxUKXVxcaG19jyvXq8jBh6WiSqlXNetVCowUaVUo9E4Ibsi1Taq1ep8PldKXV1diT0fc26lUhEmimXpk5C1U0r1+30CDp5++CoIgsViIUrYZrM5LaM63AjVR1wDIn8sFgvHcWTa2epQ7S+//HI8HgdB0Gg0ZrPZcDiczWaipMIyMVeidaFBKqUuLy9hoovFol6vs77oqayg1pqvt9tt9LAkSfjR0WhkykZMted5g8Gg3W6Px2OYKCr1UWG1WtVqNc/zmI35fI7AgbW23W7PZrNqtVqr1SaTCYoEarrrusPhcD6fI440m00Ra7jAtIU8HdI0rdVq8/kcmwFa8tM5UKw++nAcRB+VCR+Px9DfMAwrlcptu7MoiiiKWq0WYiDKBzLaUw/1k1iv1+JRHo/HvV7vGFTkPw7mXzKdlKGsYBJkYnki87ItcEGapovF4uzsjDfNyXk6EGbvuq458v2YUh6PRqMRBIFUDWM5eCLP80wbNUphURSQctGWUEpQEDkU3ATlku+iJk4mk9FoxDtc3Gq1rq+vRU5ar9f1et3zPK216Mcyk9PpdDAY5HleqVQg4ihGor/yFMe8+dM01VoLrWDDiB1FyEhRFFmWVatV8hdM5R6g/Sulfv755y+++GIPIzdLy202G8dxnlTvt/roiUHSds/OzmCoIgl+Eq7rQpoRkGu12t3XPzUYTJqm19fXZ2dnaKJHS0duApXCcZxffvmFheARVquV4zgoqWmattttdKPb7sMjF0VxdnZ2fX2NT24PTBTtCsuERMSckEoax7E4+zudTqVSybIMTtZqtYgGcBwH1thsNtvtNu4MbO+1Wu3jx4/1et33fcdxmPBKpYKeul6vtdbL5RKaOxqNJpPJcDhEg+90OqPRSPbqYrFotVpYPl3X9X2/2WyuVquiKHCTj0YjxMTFYrHZbDitXHx2dsZ41ut1u90+zvkPgiCKomq1GsdxGIY4hpRSnucRNlWpVDabzWq1gokqparVKhOFnSPLsjAM0zSFieZ5/sUXX+ynGLvnecSX4dWOosjGGVn8f3D8oNdKqSzL2u32HXahKIrEzBXH8XK5PHhQSZIkvu+PRiNsL6fVMqherzP5//Iv/6KU+u///m9oLmrNxcUFJkellPiwbwOmszRNR6OR7/v7idv853/+56urKxQv13WTJFksFkfrovskHMdBTxqPx47jCCuVaJ1Go1GpVMbjsVKq1WqtVqs0TYkqcBzn1atX6/WaOyAJIfdwcZ7n3W53MpkopYIgGI1GWZaxV4uieP/+PfKo1rrRaGByQAmDx3S73cVi0W630Xf/9re/LZfLf/iHf6hWq8y2UsrzvCzL4jjO85zfPcK8QZ4CvTPLsq+//prQuTRN8fj+8MMPrutWq9XPP/+8UqkgviilmBBsuYgyvu/TywQBzvf9PcgNSLFff/01v9XtdhFtn+jnrF334TiIXRfrE4FFWJ+Wy+Xnn39+GyvF2IUsKfrT3kKiPgmpxuw4DoY4NtWhxnMvYMtCjZCzwymI49j3fbQlaLSI8DfBI5vrsp8i1YxNAmHUqcV5MX70JJlqpVSe58Ph8McffxwMBkSEYkTFCC+Ga0y1mGQIN5XHz7IM6r+1ZGaIkFIK62WSJN98882///u/n52dScR1pVL58OHD+fk5GxsxUSmFFVfiV9frdVEUmKPNRzhC4GiIoqjZbMogcZF6nic9S/iICXRdF7qECZ0JRwfFBrDZbPYmt+EsZ86f1NhzGsTLQkB8IIFFHPhWqxUEgSSooX2KrF0URZqmZsqvxCip3ybJhWEIrRG5nmu44ZY1xoygKYqCr6Rpygu+yAAYCe/zjnmKJDNBlecTUV0dpZCulCJwkTNJniJyNx9hTfJ9n6wkUZJEEJYJl4fFCBbH8WAwMLMMtyCkiu8yw5IoaX5k/pU80a3MCrgLr80gryiKzLS/I0Sv14N8m9sD5XK1WklwkPjtarUaDQ2Z29FotFgs8A2zapVKRWbAdV3P81ijzWZjTkKWZaYxvFarvX//Hsc2yj0xOOfn55K0ChNF8JJYG5ZMsi3vkLSOAa1Wi4A4uCNvLpdLmKgcZD4qioKp831/vV7jQhqNRvP53Pd9UUN9379DbmBZhZ4opbANSPYq38UmZLZ85hCpMlVXfgKCWa1WuRtfYebVb/N6HwV9T4h/TpWBFfe9w7MBkyCFDnixB8gPsRaQCd7BPaO1poWA1tr3/dVqRShpHMfaWDIuCIIgDENeEzq7WCz4l9daa/xGODzIpOaGWLS4WGtNsKLWerlcyvtcw6dZljG81WpFQLzcihOyXq+lZMTV1dUTTN5uQMiJ1lqVwdK8L2lzXKNKM5fW+urqig1DRAzXQ/f7/X6tVqOh722/CBXg5mg/TLLg5olmoWezmed5Ek8EB2VZtdbEMVarVeQt+W4QBJvNZusnjgFbJMv8V5UWMlWme2qt4YUS0M6VJH1OJhOtNdSfHR4EAZtWdnIYhhcXF6wLH1UqFY4A+i4hNtfX16vV6uLigrA+aLc2Nj+BrxJu83d/93fKCAt4qsl6BJgBMoJ0ObdKKQKv2CpJkozHY0SEJEmw0EynU631er2WEPSLiwvelLQTWOndECbHbtflgsIvuVWn0xFyIZAEYgRZ4hjknuaEr9dria9+5HRZPvpwHBUfRQAkpCLPczLKSUWX0codsEAy/sFgoEtXE1QeG5TWGnrx8eNHfYNZyrnCyH99fc2ny+WSQHmlFNwCE6LWej6fayMulK/DRKHXSilCRaIo4qf5e4SAOkvMpzaml77uWmscnzJv6D3CKbk+CALmn/W6GzJv1IVpNBq4/Qig0KUs4rou88k9TV7OHaBHusyw5BEg9FmWUT5CnuvYgOwVxzH7kCVIkkSkljiOpfkSXyFfU5R4bQgl2mB1QpF5Zzwe8++WaMKujuOY+CB+BTKojFJWYRhmWYbsKMYYlCGtdRiG4qOFnR8hkiSR7aGU+tOf/jSfzznFJvGvVCqwSaXUbDbTWss8M6WbzYZJG4/HLA2XfRJXV1eyV1lrubku5W8Je0Z51VoHQYBVrNFoXF1d8alkJWmtr6+vseTzL2ZqrTUb4/FzZfnow3FUfJRoC97Huqi1xsyitSbmQms9nU6n02mn05GbhGFYrVZ5jbIym83kU3be1dXV1tZHqAyCgHPV7/ffvXuntU7TFMetXMapEIOMNmg6apDsqDRNTdIvm/6oIKNC2lgsFqgywsnwvckz5nmOkm0yWl7IgzOHd+uj8hOyNHJDXnATlqlWq/ERwZYYEmGfwmxkaQRi1ZDH3LrgGCByoTnt2mBRupx2rCwEmsrXtyaNa4Qrg+VyyULw+KPRSGsdBIGs19atuBjvINewN0Re0QYbQMzlTUzHorweFeRgwthImOajJEmwq2ut4zhm22BU5wJijkQI5kqRv1m4O35Xl5w4iiK+ay7ucDikmpvWmnhg0UrJDJZbTSYTKNtkMhkMBuZm/vXXXwnSNkf4GFg++nAcFR/V5bllQxNeqI3T3mw2OQlXV1cQI7SWMAzzPF8ul1EUib1RlzYu3EK8s1wuEdLRfeVK6p7oUsxPkkR2xWq1IhWB4KY8z6fTKaK6NtgqgVrcQcj9TuTEpwAGZ1MF1Fp3Oh1TgxEqz1OYhEBrHccxqkxRFN1ul5v8rvL95s0bKgnwLxFkMhLqmmKKEEHKVAtMPhoEQa/X0yV1Mz/Ksmw6nQpvePx07RZKKXOiTN5PqJeUyeVNiPv19TUCjVBn0ezl6xwEpkImWazE5gCw0FCOY0tASdMUxizyyocPHyqVyps3b0S/l0cg7RW1dcfT9GiYTpkwDCkMxEeENGqtUamFRRF7r7UmeJCLOQjyXWLr7vYXrNdrXNHyc0y1NjRdcw9sSTaz2Uzmk7gQbZhehHjir9Wlve2RsHz04TgqPspOxUYktrtffvmFMBbc8kmScDxu0nSt9YcPH6QwpilKkwFG+I+8Qzq2CIaqDFGR8yOuJnOXC3XjVpQck2uKohAzi0zssYFHgC9CI6IoQgDXWhdFMZ1OcZ1OJhMMvOPxWLiahCULBUcRRzG6Q3QQHiD/IrtMp9N+v4/iJRdzT4yQQibwdlPWjghMpRRVpXDUdbtdXUpX+k7j2wHB3DJIdrUuib7sNGGuFG+ivi4OCF0q7vgpCSiVnUbWI69nsxl7G+XS5IK6dDCTdSrEUN+g79KiWEy+Jv2kWq951o4KURSJH53zmOe5HFjZHqp0lzK9oqfipGSeuZJyUb/rdGc5uNv79+9lxm7SLjFf4TExP1qtVkEQyKlUZXoFAdKyZByox8uLlo8+HEfFR7XWeNQp0SIE19RHtdYUQOB9vJjIZWxuMUiKRUUETG4iJl/TnrbZbPr9vtZaHHUmNanX6+/fvze/QgyLqGjX19cSZin5MJ999pmc4aPClqEpz/PLy0ttnHOJm5WeJBK0laapnFsxIZg29rtP09bcKqXEdST+6clksmXh5IV447Y+kuVmiZfLJUnGXHOELlL8wdpQI8wYOj5aLpfmyDebTRiGPOlisWDS5F++Zerfs9mMJWPSZB8yLWb4lWkPzPOcVeAvCy0HhxeLxUIK5unSC6D/mHd8z2Aj6VJNl/Qh0/OitS6KQsIp5E0mX+IEca+yb4fDob7TjsrMUwpDZM3xeMwAcFQRGi2TJr9br9eZ/A8fPshHvCZgmzdlQbn/TuRFy0cfjqPio7JLoiiS4AtMprok7uhPbGhTBBODHi84ALjuTYuTODYkbsJ0ZnB4SAvRBh3ZItzCbHTp6zKvwZKc57mofbuduscDErBcLpvNpsQzx3FMYgDBDuIoUoZ1WiZc2gxI4BVzcrfcQFbSTZebmCjDMGQJxPY1nU4JA+ZbWNdFncIyXxTFlsOVi8UZdmwwg4AkxphJhkHKjkW5lIAUfSPyiDuwqxF3zKBlyLSY5SWOVzguX7ypTYr9cCtcS+7MCAk12vX07BgMPkkSSijwCBQilRh+13XJDuh2u/KwYjDgHeoySl7K3T8qntS8bBigjUgL0SPhpmEY1ut107Qus7parXBUSZjIZDIxH4Gva8MG82DY/NHTg0QAsoPZK7VajSTF/7+0ruv7PuXpwzB89epVo9GgtYhZIotsSDxD2PfOz8/pOiTlGjDpSMENiV/n0+vr616vRyZoo9HAlsXFmFbkt3RZq5OSXTQ/F1Pner0mEk+VBrEjLM6gS/MsjI0UfpYAHzC9RKRii1SxkQBpJoS6MMqYE0lNkcJGugwIItDf932ZEAr5kquqteZ3pbgg4cSMpNvtSnpur9cjYASS55TAAcb+Mef8CLNIpWKfUorwOlWOGWOG2DaoicFHfEsyNev1OufFcRzKJnieh+2XwgKVSuXVq1eSUa3KhFSq6XIrKbS5NUKWVc6OGH7l+DDCRqOxn7Ynj4GZpkzNP1WWNsTolec5uaEI0DzsdDr94osvoijq9Xq8w0Zlrmq1mpn3eRPseeIqlFK05aH4iSqrQ9MwII5jhiEdDPmI16PRiBRquhNWq9XhcAhHHwwGpK0T5LWDuqT3ZbxWHxXIVtP71UdBGIZi4ut2u6iP/CtR3dIlWxs+SBooUnASOY49qksXpqhQ+FNliXk/TVPi3+TXRcvRZagRmsF0OiWuLwgCdDV0L7PNtTyOvOZkiqb7BDP3WGAI+uKLL4qi+K//+i/eFG/lYrHAyv3TTz8RQyRVW1VJdsVKNh6PP/vsM5kKUZjIzNt6fGV4VSUQI89zLJxyohGuCZ+Oomg+n5M9SZyXMvIEdJldUK/X0YZlrY/TObpDhGFIMIG4KtAjZQnEinuExu09wDRIrFYr6kvM53NxUm5lcIldRGy2siExzzCfyBa0WvsksApog15he7ht3+rfGs/NcjHL5fLNmzfmg6hShCI9T2wSj58uy0cfjoPwUbEsye759ttvhQn98ssvhGuKpUKVdrwtmYmarpB1bjiZTNrtNnW3JdxXGwmgppVVHhyCS8lfXRph3r59y5Y1rcdMkeu6SH/aCL6Qwyn76mjzLsRs+PPPPzMDZlg/mM/n/CvcSNJjtOFhlb+QjziOzQQMMdp///33uqTvsii8+GR8hBxJrhHWK3IPewMzL1LR1gXy9aMNgdkVTIOeWZ/ELD+id5Gnf4pYrVbMA5F0W/m12qjSsFqtTOJwM/yYjbpYLCQi+jaYxE2uFKepvrFvWaOiKOSsmaUViqKQFjTArEWTpinferyB3dbXfTgOUl9XGb2isrIzLXlU2BilM7C5NNL/CAsJnRcJJcdgJd2gyBUjrY1byQ3NBry05KU+i3RIBgTxYt3CVCsmTUL8pUAJZ4ZuVr7vbzYbMnayLJMawnuYz3shu71vGpjP59JadVMaxwQAACAASURBVOvfy8vLwWBAUHStVsOy7TiO2LoxT8laMMlyK4QbLqYUODFitN3IsgwxX5f18Vkd+QhFn1tJB+aty6i2P5/PqXj3jE+3VDOm8iqLSElY2fBIflIq9tBDPgBu9k1TSslEcUEURVKfmahDfA1UUiM1iM6sUjjzbn8NxOfjx4+vXr3aaip3c9+q8gDKqs1ms1qtZtrMcX5R9JFfJ6aEY/vjjz9+/fXXj5woy0cfjkPx0SAIKF3EhiDmu9lskndlUt6tLYscZ1IEMlUYNpkt7Hi6VUspanbzzUaJCHqQHjqhkpbADa+uri4uLpRSOGXNfYKLjtJF9MFmqFh1Go0Gtb/lbBwV8rKFZL/fl2dUZes0uoqa3Svl0aTWq8l3sc+3Wq1Op9PtduM4lsqx/X5/Pp93Op0ff/yx0WiIp03A6oiwgmiMA0mi/M0lhqlDoVRJX4qiwAihjFLjQjGfejIPhbwsjMzqUIUKYY6iYKzXMTcHfVJI8X2yp/B9IrqpstqwVH4n2Ge9XvMV6eUgF3z48OHNmzeqlPIl7eqTIDrSlFb5+if3LU3ZOGumoK+UoiJmt9uFlOmybwThk6Z8v/XFB8Dy0YfjIHwUcY8fwlKBy12V25c9QRcLESclRlQphcIBu3Vdd7VaVSoVMw0OXz36rlKKKttxHEPWJ5NJt9ulGohJYjg2FICmuVi/3xeNyuTov/76K05B1FDXdYXRiltUIkSODbAu8+ARBITrt1arEbvLJHABxSigC8QWonYrpXzfF7Falef5NkGbsyZf5F/pB06csNyK69FEcZNXKhX5lPTTLMugdDhxe72eST0liue5Ap0+TVM2v6l0RlFUFIXYVDzPMyf2hYD6KiR5E0aEv192RZIkED1hSLoMZfd9H7MKueYyseZuvw0S1iQ/IQrxzX1LuWNkbqUU5aKQ/zBoySHK8xyDjRCW77///s9//rO6YVJ6ACwffTgOpY+qMgRcducW/f3f//1fCmHLO1B/01qrfqsnsRdlk9EaU7YvB8kkNMh07Gb5FbFhbu0KXaYBYLDlTYaBIajRaHBKGQDcF+PncXJTZbQbQ/KA8aDMFWXeN08nHFemxTSeq5KCm7YyFkiU9SzLIPeyQLzgDqbpmFHN5/Nms5nnudgSROsSewPXX15evnr1SuwB/HqWZZ7nHbDZ+x4gsy00FH8Eoadcg2aP3nPIsR4CoguyafHdiDbZaDQwXUD0giBASiNIYjAY8C3zUBPAyD6/Yz6p86dKhZjVwQj/yX2LKxRBVswzzWaTgHbMRfJFqDRVU4R2Edf9yOmyfPThOJQ+KuecdBTx5bAbhKux6eVfU4US6yIkWFRSbi5rah4bURPZpqTBiPWPm4uvjhEiD97cIVBzk0jxdZOv8475sMcDRgizNOsToYya4nZRNhlF7+90Ojy76V6F1uiyhwxvyoNvzZ68Ly9Yd1E9lUEBAYu4NZOMU/YM14iBQX70qbs2HhCmsCJ+BD7iqVlf8dkfoX/hqSH7gYMsBMTcS+Zr2TaLxaLb7Qp5lDOytetug2kU2dq6N/ctXk9ROk1vLmDYJoXhfY4J72wdmQfA8tGH41D6qMnelFKbzUZaFD1LmJ2WTQZ/kMFsBXnJObzvOTo2QErMPDyxVx92VMhbnufFcXyEQtUOAc/GcWuWrzsI0PNILBFC93h+c3BkWSaSKA6yrcDAh8Hy0YfjIHyUVUdGQwoTk+xT//RBQHMJdh0BOAcnpnLwbppJTxfo0+Px2IzU/d3QyqeGWEFkYM8bPKYZGnYoiDEW8s7Ank3c8pb7/494be+G5aMPx6H0UcojdLvd9XpNSQ7TKvUsYR5giSk91GDa7TalVTqdDiXHnhPwo0vI7gGxXC7r9Xq1Wl2tVmdnZ1If+LmCgJ3xeExvCWpRHXZIRLeyJQ47kqdDq9WSKjQPhuWjD8cB/aNb03636/6k4Xme+FmJcT+4nO55XqPRoMRoURR4X049RcTkmtIr++D+UfF4IbtQ6OqA43k6EDncarXo4mAGwR4ELD3HjUJ94NT3Oa04pCgSOQhENjzmtpaPPhwH4aNiajML3koexfNDnuedTufXX38VhZvqXwfMQ5CkI5JzcBodXHt7JIQ+EuioyoJTh8JisSBmmME4jkOG9KnP823wPK/VaknJTFLaKIl8wFHJVhemfurzT66dPM5yuXz79u3j9dEXygJPF8JE0zQdDofT6ZTkzkOP6wkhEfDECHied0ChmCJEBDrhKJWA+0MNaSeQ+j5kvmZZJmnvB4Hwj8Vi0el0zs/Pr6+vJeLs+YFeb5SxXa1WdBQ47JA+fvxYqVRwk/OObJLTxVYSmnjHHnlbq48+HIfyj8JX1ut1u93G7PlckxOUUuSKELcJ+yQP9YBUhoWGuFxeXr5+/VqVnTFOF5KZs16vB4MBBtXDVvORoleqPGu6bIrw/GASVaVUURTL5fLxcaQPBkuPeXk2m7VarecRz0jlNaneValUHMehIcxjbvtCWeBJA9ZCX7M8z2Gip76/bwPn2cwhk/oPBwE2LqzoURTBRNVRtni7F8h/Z27FR3DYkniSzUWctpSCOuCQng48GlUhqSB2WP1Elh6vLWWxH18/7+CgIy8EhGT3rT6SD8OjDn+n0yEFRwpbvBxgXyI6QCm1XC6d3zrknxT1eh3PHP9KTQCgy54M/EuSPu8Th0lFNBq5SPir4zjSXhv6xYswDLmYO2CQkOYtTw3HcWj0ppSiTuFhLajU3VZKaa1JyJFVmE6nSilCeZVS0j1YWkrJTXhNjW8eiq5qrCP3j+M4DENVcpGnBvRxK7blsMKZFEMwy+4Lj5cOr0ydKlv+8ZqTSAcbuaG4HnXZhI73IaPy72QyUUbzeaUUC/GkgImq8mGlKuGhsLX0jIpSBkqp2Wz2yW/psv82q8Ny0KFMGSciDEPM10qp6XTKZXvzvEJApOjpVo/kh+HefBTCqpTqdrsfPnxgt73AvkK//PLL69evaQehyg10QGFZNi7VXGk4vMXXXdedzWY091YlYWInaa2paQnVpuQ6pwXJVNJVuZXv+1S23PNjHi0mkwm1DIX6o96RC6iUCoIgz3N4LSTDdV3iflerFY21IeiwCimWS82NAz7aUYHjRsilUqooim63y/wsl0uKwVJPERWKqYZYM71IgVSZgGWyw6miNZ/PR6ORLus/RFFkVna0YHMOBoP5fK6UyvN8sVhAfKAG0hBQGUQJ3bper9ManZbpnU5nNpsNh0P6YVAN/4CP9hjc2z9KJh9h6FprWjq7ZU3RlwP3t/4MVXZj3Y/fTiz7qnQaua4rtSJXqxU9K262fCJAZr1eU2i3VqtJVYEwDGl5v5XtsF6v4bi8SQeSvUX6uEa1oCMpDuDc4hfXZfcbwo4kKEbm06xzRsFhmW1ZBbMnj+M4ZqjkHvDJfbW3X98C6y52FBmSWfBWtre5pZl5aYPDhEsNLGmUZlakooMmS9DpdH766Sf6K+zTknnbvjoIbouDyfM8iqKb3Z+oSm++KW2jENDNHHd2u9YaSQW5/76c6JGPJk/EPD+Sfz2Qj5osRJ9+sagHAIpJ56zVasWpe3zfgD+Im/ROlWT3ZpVXpdRyuex0OtPplE5e5pJBKTgGWmvCl5IkgdZL2WhV6q98N0kSt2yi9KQ4FT4KsZZenkEQDIdDKYDMyOkwLHWDzaIqWmt8Y8SpBkHQ7XY7nc5iscAIvx9v2fHzUfkIqbFSqXyyT63IJdIEyXEcqqvTM8fkqUL96edFpVZkYpjBViPYJ8JJ8FFlpN6h00tdaAnwlhWReaaCt+u6JnWSOtsIQEj/e/DaPAUfvfchEeUGesE49uA/ODagus3nc9d1h8MhfXkOmI+BGUopRW6l1vrq6oqPIMqO48BExR+wWCxU6RiDTGRZxs5GVLq6uoKJ4jrCO4UIib770owQd6BarTqOA/kYDod/+ctfHMfBi6yUcl13vV6/efOm1Wq5ZQ81kgrE495oNN6+fes4jta60+lorXG6W6OiiTiO2epiEv/iiy/YzzKTSikp3Aj5brVab968kQyHoihoJQQl7XQ6mJGazWa/30d/arVai8UCsr4HJnpCcMtoGKI0mH+xfmNpJ4KEWU3TtNPpNBqNTqdDEAZ9Mv785z+bMcmdTuft27eHfLBH4N76KJ35RqOR53nX19ekyatDhyTsH8vlcjgciqq0N/0M3GbXRdAz1QgcPL1eD9nwZp4SHXqlXyBb3HGc6XR6dnYm/UQrlcrV1ZVJULTWd/fj3QlORR/lfUiMREyInLvZbAaDAeKmxNwXRTGbzf7u7/5utVpJUXi8d/AJtC61x5IIJ6SP0p7BrOd+fn6+XC7pL/3+/ftOpxPHMdSJFWk2m7PZTAo7yE/Qc1CMNK1WK0kSYu5QrfbTd+hU9FEcz71eD2e/KqtkBEGAtZJGDryI4/jDhw/n5+dc1u/3x+MxFTbSNJWJpTif2stWfwp9VD0gxEYCCDlp0NMH3Oekkef5cDhsNBpJksRxzDncG8xaowwmyzJWgRhFQock/ms2m3EZ41ytVovFQi4W4PPWZbgvIIiD3l7T6ZTLNpuNXPykMOkdT00gwwEhp5HB8GK9XiNZ12o1LkND1Vpj41VKsQraWDitNd4m3mk2m1prlkauwd67n0e7ua/287ufBFZxbeSMaq2TJJFRweqUUu12Gx4pha64QGzmWmuC5obDIUcDRiW17+VH+Qp3Jo6SGkN7wCf31aHAJMvksDEEvE9A1mKxMOdZKVWtVnk9n889z2u32x8/ftRaS5yXUgqB2PR27/nR5IlgpY+8572FTbNllS5dZc+jCcC94LrudDqNoohYBmbggHGVdHsXOjIajRzHgZT3+32UIfwTeZ63221MiPgzsJUppVqtlmkcdhwnTVOswcvlslarYcEm3I46bYd63mNDs9kkghG2R06RW9YQIBCRzsOO4/i+32g0wjCkaeh8PnfKhHdid9frNaxXa12r1V5g88vbgM+S10TnEvMyHo+pLSXl3YnRJTFPtjqmcqWU4ziXl5c0PJf9H8cxrebRR0kO1s+6OP4DgB7VarW+++47pRSduvEliYOPOad3TZ7nFxcXfAX7liijXElYr5m2dHK4Nx81XYBMAfYoSRUSc4TkGBEqTQ0aPsJyJVYLiWJnZhFbTFHljuKxEm5groEkGADIvSScTSYTbriVtiFZIvK+2NmUYbjeOldaa8KVtdYPcJLzyLgqIRAyDMkOXi6X4mlDmJLnlTJp1Wp1MpngcqMhjCotRdyHWAD2uvi2wzBk+TAzSuY7TyQOYPz/WNKoQsCAD166bCcwEzRheFmW8QIVX5ULBOB5fEvMnrjceC2B/qwRfQX4Cj45iqqIg5nNI746amtMp9NarZam6bPxmJhRFGKvvg1xHCPGqT/GyRqNxmw2w8zL2uF2odWzrBfRc3xlNBphxVElWWMFURVESTqsE+EIwanHE8E7RVGwoMyVBJwLyZKlT9OUsiocAa01ZJlGFCdcBP++Cuwd+r6QA8/zzIzSxWIhOUYXFxdYZrj4+voaM8t8Pjfvg6VUYhfvHpJSiiWJ4xjDI4AGydf5CdNKg0KgS3Ol/m0iLNWwnLI6gViTxN7CJDzSDiMGYdOGRp6y1vr6+lre0Ybd9erqSmuN70eeVIa3Wq3w2AtP/eKLL1RpV1RKNRqNOI5ZO9d1xQ5DBp4qM+oY22KxEOOqWIYZzB5MT3uz6zIhbADzJ2Sr//rrr2bVBT7F4ioGRtd1uQO73fO8rZtgKozj+PLyUpd7iWRfVaYwaq0JoiYAWO/Rb/Kkdt3lcimv4zjGfH0H2O2cX6VUt9tdLBa32XWZSWR3YoWSJKGyHQ+yRalwfDplQRVdHjHCl7iMxSUTaVeTcAd2Qk92hTvofBzH4q7WZTScKt2oIq+zOrokVlrr6+tr2ery9aIoML1wIvb2aLu16+6MjyZJgjlL/BNbrHq1WqGu6ZLKXFxcaK1FGVW/df7zDnGhsrM//QylmxoDpir10SRJOBsIUJjLeIczLOHyvV6Pd4SO4OVSpc6tn4yPaq0nk4kunY6onryPjphlmfB7WBe01fRSr1Yrzrww2q2ZV2XAzi+//IKNhZMgUUJxHMMA4jh+8+YNDJiv08WJ0ppYwJBICFF+2CP/ceyBj04mk5trhyhDTi1T9Pnnn2ut1+s1GjwjMXlDs9lko0rFHGX4RKmw3+/3MdLib5bLpOOE7/u69EmzOsRE7PaRb8PT8VGZYdnMILsFm80mDEOOhgxJ/MRsReGjytAHzDOLpR0yIltday2lizhK8j6+DyFc0IrfleN3hZPgo5AF/MosB7l2quxRw7cgMuxh7DEYBS8uLtjq8ILlcilWN8IL9vZoR8pHeUGPQNmI/X4fzUZGTH663MGUKCFY8DatNfz4ZiDAFrAYbBkYRQ/QBjsXGQoljzfNggO6DI+UuA+8jE/NR6Ea5gyHYSh6s7BGeRHHsWiW1WqV+WSQSZKsVqskSURVBciAnAEWqFKpiBgBTY+iiO/ypqxsFEWcE7nbPk/4U/PRyWTSaDQk+F52LzJyvV7fajDCv6PRSKTsoiiiKBqPx+wllpJpdMtKitIPSyDRLmxCXfJOKmOY/AzOuh/sgY9qrVer1R8P3hmPx0VZHVBrTSVF+ZTEaCiyLueTSl5iODFXVpfiqbmllREWzr+cF22Yi/aAXdGTneAOfVQq6slCqN9aYvRvqat8HVEmjuPlcomxna9TbMQ86Xt4tCPloyAIAt/3hWOJo1Fr/eHDB3mtta7VapAM826wCiiR+ERv/sr2MxjMQJeLinJs/uJ8PhcmjaEMmVdr3Wq1KEMjZE6XjPyp+eh4POZFGIYYo7TWxABrrVETeXwRrrle4rblViK8Iw1gFTR1I3PY0HHi6KIoEroGuRHpR5a72WzmeS68HFlkD/auPeijVKggOhSrgDYimXl2IbvihudTlk+MsbwpGgxbQoIVZbpEbGK5i6KQiTV3EZWQtWEie2o8qV13sViY7hut9Xq9vk0flTGIi1r9VpILw1DOBW8S0iITyMERgwEODv3bycQKhZWF8bx7907/1tuyWq2sXfem/w57ABZyXc4Ycx7HMYtiPkIURWKb0VrjmWZxMVFs5Q489aMdLx9lmqQJsNaahH20QxJFzEitWq0m5dS5oZDvoijm8/n5+bnoW7dhNpvxLbHicjdWxbTSSCVuFo9DpQxorev1OhGtIlXtQR+9LYdEHEjCa2EqsM+rq6tarUZ4kfmtyWRikiGIC88eRZEQSmam3W5vGQzq9bqZd0HnZEJ2TdImpt2HPfIfxx74qLohBcuRFkMfeyDLsiRJ/vSnP1EBQBvcMUkSUnW37mACF6ywW86LSVyCIGAnpGl6dXUlNvz90HH9lHzUFB14RvPBbwJVhhg3rXWlUqnVaiSsb/nqeGFyu+vrazlQvCk0hOq75kfsZN7kWxy3/RcPPxU+ul6vRXZhWVmFrRmjqpfWOooiWY7ZbMb+l1mVk0Jgx1M/lz5+PirD4qOff/5Zl3TwplZk6lLE1kr9OWGlW0Lorc+g1Nu3b1nL6XQqBhw+Qgc1ywXo8sDIDGLES5KE0UI0f/nll8FgsB+7rtbarNEskcwQcbN3rnz05s0bVaZqBUEg+iv3FPazRRk3mw2bVUKLJd9R/5ZpyVeIBZMBiJK0H5PX3vgoPEyIrAgxHHh0Si6QeeAC6II5NqEa/CvBYkiH5s1Z+tVqtUVBzL20JSc9KfaQP8oMYzIhvPaTkM3JC/NQa0O5ZIQswZayG8exOatRFEHWp9NpmqYiCIpYI/4R2dgSYbSfJTgVPiqQaRHPRZ7nwk0ZfxiGIsSIPiCzylTzW3szoZ8AH0XR7HQ6bFPJL5QRqxv2Xl3OINSHel2IMIPBwPf9u+d3sVigLUGS0jTlcLKuZlK2OK54berNQhnhW57nSRD2HvhokiR8VxT3rSmVO0vbBGVEcrEEoriI400bNIvXXFkUBXHnctvNZiMFXORbvGPaG7m+KApiyvReUtSfmo8GQUD9Gkn5l49k423tQOg7Fi1z/5sGYSZZG1OEDVMb1AfeLDtHqDZ8V5RRvUeV6En5qJi7mRnyH4pbIHIbzemUUm/fvp3P56LXysybEYJpmkodIv5lM8tPm5xV4mKkaAmLxR3ws+jf05t3iFPho+xGeUcsunLBlptj61umAiq/xaf7KXnxFHz03nUBi9vrRVH0WT7iX7gRsTMEa+Fh8jyPNhdSh0yVaYtUaVqtVl999ZUkod42zjzPyQnTWlMYT5I+GYBr9OlkyoTX+r7PGEajEdRts9k0Gg0iJLvdLjqiLkOBUGqlj4fjOJVKhUAn3/fJVbjvfPLs1LLwPG86nfZ6vTiOceMTN4vuOJlM3r59Syhyt9tNkqTf72dZBu04bNffpwOhwj/99JMo5RyAXZUmQPvRJXHntlJkUcr1sUBQ3m+++eb6+ppS/lu9cU4dHA3P87rd7k8//URTjp3cWUqvkWIuxZ5uu78kfVIjXqjKTgZznNgJPXnAj0preonWhMjP5/OvvvqKDII8z59NMZDiGOrU3wYyh6SGQBzHrVYLRzRDlPI3sOF6vU5Mh1IqSZLBYNDr9XhCmGin0/mP//gPjL2S4PhJ4UKSf+v1+mQyoYK8+m35BeGvVHcUW9x8Pvd9/8cffySZjC6bWZa9evXqu+++833//Pz86uqqUqnQpsP0qsKhyabH6VuUVTH/OJgcSVvGCk0B6Gq1SovK6+vrLMtGoxFOOBLpNpuN6PHPlYkqpRqNxmq1golKcQmo8E4gvuRqtYotBPoOE2XbBEFQq9UWi0W1Wm2329fX16ps6A1xkSDn04UwOU4TBcTxdOwEWmvHcaioJfQ6K4s5f/L6yWSSJAk+F0poPe/6WTuhJ/cFegh/gyAQqoKYjiLhui5Rn49kNs8YO6O/RF7Qp4J3tv4Vf4YqY4KcUg2tVqs//fSTHDDpv9PpdFjIvGxmchOQM15TaZ1AMlXWfMD/B4fmME8mEzEFS1LwbDbDkoZxFRq6Xq8nk8nFxQXtk4qiIBCJXa5LJ26tVsuyTHIn7gUq3TAq3pGuQwyj0WhQ5TkIgmazCeFuNBpwWQ6AfgGt6yiS4HneboWGSqUyGAw+fvzo+/5wOFwul6SBqjKZCn1IRBwBqb3Y2J9BXUwsRgSdeZ7HOc13V6fNcRwyobvdLh7KwWBw91IiQyOsoKU9J9V/CzhQHk9P7gsIIHXNpHkchXTMCyhDj6C5h1GdHHY2KZvNhn2P7Usp1el0pM4fCVsSyINZlVOKjAkTxYp7fn7OfpLUvTvq1q7X6+VyyfXn5+diFfn111+5Lc4PeK3jOHEco9hJSTAScpDO6vU6TVEYVZqmr1+/zvMcQimWjUql0mq1ONVw3wcT92q1yiwNBgNEbxg2t6Xpx8ePH5VS7XZbulsQxsxTU/H5Yb9+/BALh+/73W6XeTZjsh4JZPCLiwtUXn4C5zHGn9evXzuOI0HgSFTD4RBTgTg1dzWeQ0Eq4UmxWaXUDptBUgeOEz0YDC4uLojnvO16ziNSJu+8fft2q5Dnc8Ku6Ml9AfGh05loqMpYekqYKaWoZLmfUZ0cdukf5V/mmmOzpSSJ7xMZRzp2ZVkmGet4aPBF5Xler9ep3H2bviXjX6/XnueZ/avh6O12W9S11WoFvahUKiij8j4lxCDQ7XZbxK4gCPI8F12ECJ1Wq5WXNVQxQI1Gow8fPrx580bshH8Q6/Vabu44znq9bjabxaf6VS2Xy8FgIKbvMAwJ2SVt/7luccdxKOmOPNTpdDBX3HeebwO7VGsNgxyPx1L6Q5WNnfv9Psm7uoxKkNdidDl1ewC2HDYSZSODIJAYn8eDw8L0MtVM+23rSDN5pdRwOPzpp586nQ7RfzsZzBFiV/TkvqhUKsvlEornOI7neTREy/OcTkT1ep0QRWmt+KTj2QOewj+6Mz4qEadF2bgYY6wYiHzf/2QZ4vF4zGqZfWMwAgtTzO9skY1DXv4NgqBarVarVQyk8/kcT4/0B6WRNVGa8ivSvFOVfWzIVONN0oTFS8c4HceBHzcajSiK/vKXv3z33Xf3LbU8HA7xtwGaVzSbzTAMMa9BbpRS1KbXWpvXqDKW9dTp+G2QnqlZlg0Gg9ls9tlnn/3666+7KmmttW40GnR4xnhr1tvyfT8vOwQopegEUhTFcDj813/917//+79Xv+32etK4vLx8/fo1+5yk4clksqt5Zifj2meqW61WFEW37VtkaMKelVLdbpdU3ecx1Z/ETujJfQH/hltjMpSPZAPMZrNOp8P2eNLB7AdHzUeVwWA++S8SDc5ziYoU3VSVsqpSilpfjuMIR1ytVrf1i06SxPd9bigKLh8JdxFGu1gs6Idn3sFkQlh0URAZ/2w2g6zIOHnNyKkZtFgsiEKiXva95nOxWNDvSSmF6Meiuq67Wq2IN0YDo40lQfmff/75v/3bv9GH6xkbdVVJXMjzQ4n59ddfP/vss109dZIkzWaTgBfiKUzNHn0Uular1ZbLpfQs4uCgWm1JcqcIHgH5jAZ8URRJtbbHQ4IBiaPRWhObeptrmYq4XEDvl2q1Oh6PzSzz54Rd0ZP7QuQSzGyU96vVauv1Ok1TyGkcx/jOn8E+V0fORz+ZesGbzL4cIdin1A4kYId69Iif9XodboE2ID93G/BmcSAlPogCKFrr6XQ6Go0IIBISGQQBMbHm8SaihGGzhzAyk89q+ooYv9TklPcf1orVXFFddnpaLBY0fsJUjn9Xcl4xJ/b7fRrpnHC/od8DTmt6SmCD2ip4u5OfYJtJohGBHuxAx3GopCNhL41Ggwr1vMNa7HZIB0EQBO12O8sygmNxguzw/jKxePQJ6Lvt4larJdmcnG7pffZcsSt6ci+IhhBF0Wg0It0W+pamKd0pwjCsVCpsjycdzH5w1Hz0BYJJmx39VAAAIABJREFUEKcv6/HguxVFgTRKz5DbbiWihjIO3t1275OGSVyEBO/WuCfLx/1NJ+ht1+8/z++p4ZR5zCiCVNtQv+03/BjIrMokbyV2fxKk59JR5Pz8/IcffniuIbvr9fqo8pLxxxGgS0kKKTF9wFE9HqQvi4A4m82++uorSkM85raWjz4cB+GjAN5JKy48ds91FY6QjxKeRq1dkhq73e4z8NuZjn+169N9Xz4qhS+geqYt/blCnpEI8Gq1ugd99DawTOa0H3Awu4VpdlJGJONj7vk8ie8zBsuPSqTLkq0kOB56aC8Ch8rze2ogE2y9eUDhTDLN8Mgcahj7x5HkJd9cenGdHmQ8OwRxVWbk6Q7uuZO7WOwNYl2RCiP4dJ+BPnQSIM+PlGgxsD8DsK/IqCbzO4oiyjkdZDxowyTpKqWGwyFttnaY0npU4NEoSooDHiPTAeefopjVapVd8TxmngALSWUGkqT+YFg+enogEIk6djixfvrpp6+++urQ43oRyPOc6gFYdOv1+n7y/J4a5A5SDe6O8Ph9wvd9ieGiJVSj0Tj1eb4NxIRLwZkwDM1icIeC53mr1arRaMznc7j7wYf0SHS7XdIfVquV4zjtdpuZf+RtLR89MUiVf2WUbfvqq6+sXXc/YOZRFPaZ5/fUIL8TnxyJg4fVP3Baw0S//fbb4XA4nU6lcMrzA/xpOBx+++23f//3f0+g7AGNTOI1HI1GhKxLYsWhhrQT5HlOAjrJ6Nh4H++/sHFGD8cB44wopl+v1zudzn/+539+8cUXz5W+HFuc0aHy/J4aZu6snO4dRo3eN86IKGgx5MqQTn2eb4NJVNUR5CVvNe9SRu7vQcazK7iuSwI6JcyoWE6S22Nu+0JZ4OlCOqfWajV6A/zTP/3THXVKTx3HJh9A74gjJcLosHGVu4IwUWkYR8mhQ42n2WyKUZeyup7nPeP6l6Sq53nOU9Pm6IB5ya1WC5YpjY/IYn8G8//ZZ5/hJaXHiZRzegzuLdebLSAoSmK2EnuBkPJDjuM83s7+u5BSDKpsCbdarXbbb/mo8NTz+QAwKv5SmgcmKjXVaD4lhzPLsjiOpYYAl4VhSP0QbsWb7J8sy0wBWWu9XC7l68SXrVar3WoG0EeMHIRdUC9lhz9xX4iWT/o/tUWlUqAqQ1tVGXa3RQ2ZUi5mSlV5ZMzvchmbLc/z2+ZZG5F9T7EtqTkjD1sUxWGLHojVBybKXMkmudd+VuW0yypsNhvKa6iyTwnvyE8jOUkjr93W3yiKotvtYhchIPzxwvq9+ajU1lFl/Z2tqowvBATKNhoNKtczA88jpM3iAViv17VajfIFvu/X6/VKpRLHMYZ6xHkyfSm6hkGJ0sqIYnmeUyCePgp5nl9dXWmtKUtrlq4kCIUS1gd96AOACLssy3h2JllrTf+J+XwuLY3x5MEMpFAJfyeTCUXKlFIsh+M4JNjcNs+SvI/7Jk1Tk5e8HNx3P9MOUiafVXNdlx0+m82weUhkMpXFOp1OGIbCWY/NKHUT9+ajURRRXoTql1gUqSj9orBcLmezWRRFxM0qQ3qyeIGga/10Oq3ValEUSaspaUZGhd7pdErHe0jwq1ev4jgmJJKQVFEHK5XKxcUFdCeOY9/36TnTaDSoNxQEwakHfTwAzFulUpGygvP5nDJvWut+v0+eRlEUVJEsykxfEu0dx7m8vByNRuv1utPpBEGQJAmkHCH4jnlOkmQ+n8NEXdelsOjhZuIwuO9+Ho1Gl5eXUuccUlkUBSZiGljRgcDzvM1m43keSWXUtVZKzefz4zcm3zvO6P++5jj1en2xWGBmfB71i+8LHNSUt+VoPYauFfeJM9qqNlI8l5YjN3FscUbqlviyq6uri4sLZRjETPceL+Sjq6urZrNJ3x7Md+L2ltcEekjNZ2VUgYb60Edst1F+T7ev9D3jjFRpa+UyKcfNR6RXaq1l0kAURev1mnYX4syTSV6v1+iyYjeSnxiPx/1+nzP4yXmmn4HsCrM91K6w27jFR6K4PZ70vvs5iqJKpbLZbJBX5Br6cZk/N5/P2+02qqrrurPZbDgc7twpWzxBfd17HxIx4cZxLL66F8hEMehz9qbTKV3hXqCdzQJcXFxgkMDfowwjv7yQ5vAXFxftdjvPc/5mWcZRWi6XHCutNX39YKI03ICaDIdD8cS/zFD5PM/xlSJtKKV+/vlnrTUNU2Gi+PCUUtKohH4mdFell+1sNiNk7OPHj2dnZ0zmbfNM8GqWZVdXV0qper2OvvUCca/9zKL4vt9qtejaxHIopRBEqPgBP+73+6wCba/Y/JSwPtCz/lHcWx8lNLHdblMgbTKZDAaDg4ck7B9bceqqjETYEpD/OKw++kmcij6qSgUIVYkXEJpWq2VaLLgM1gil2HoiVp/L8LYWZf1kVAG8fU9RZeb49VEzf1r9tunhlp6BpLsl4mutp9Npr9cz59N8dl5/cp4lC+iJ2kKchD66XC7vtZ+zLKN11SefxWwBNJlMer0ewig1H6gCsfOg5aPQR/E0UJs7CILRaETmmfvCsFwu6WoLLUC2fTATtTh1rNdr3/fpexyGIfbAbrfb7XbpVktj9slk4vs+hZCGw+F4PJY7LJdLVYY4EjiTZRkNNwjNL4qi0+mMx2OIOA1ZD/W8h4LnedDuzWYTBIHjON9//70qi3wtl0tRaKrVaqPRwPy7Xq9x4DmOMxqNYOSEEUlNuKIoVqvVbfOMG3UymWitPc9DQhLbw8vBffdzpVKhkoNSarPZSHlqInK11lh9F4sF6yIl4z3Po91sUUZWHzXum4dgloaSyOzjj6faOZCSXNcl7Wc2m7En7juf5sRCINhnd1/MZYxEFuVZQiRiXT71zh9WlckMMvl3zz/TzjXiqON9aEqlUqlWq7TP1FqHYVitViuVCrxWHofQGNfw/EHfLy8vm82mFFIuikIij5bLpdaasCPi5Hc7FU+3r2RWZZLV7xGfoigYgOgKumxXzF+ttZgQdTn//AT0Wr7leV6r1dJawwiJZ1G/NSbBVu+YZ6h5s9nksO988m/bVweBSed1uWrgXvuZlWLaUWT5qF6vJ0kiFfl7vR6/iIaKgqu1FsFo548mT6TKxJPH4FFGm9Vq9Qfp/vMD0hYWPKVUt9vVWh+2anlRFDByVQYPs7OJP4SQqbIoM3+RClUZBsnpvVm1Wd7cyq7Tv6VxEJpff/31iR/0SOG6Lk64LMs2mw0WRfp+I1O/evWKeePc4mBjArlYa73ZbL7++uswDFGAcODBU1utVr1eJ+iRyJcXaP/Ayo2yrpQiyBPTHCl5tELCbAaz5NP1eu26LoEtRLIopSTpQilFaapms5llWbfbZdolwUYpFQQB9B0zQLVafWnOLHX7flZlkihzwhRhV0+SBL9pkiR0e8TrobWWgPbFYsELqppgiQnDsF6vn0TH2efpVHuBgII0Gg1odLVahaC4rvvNN9+sVqvFYoGo2Gg0qtUqrTw+//xzCDqbGCMM6cmO4xBT5jiO53lnZ2fI/mEYOo6D5B7Hseu6TtkhEl772WefkUb2ooCYAvnQWkOvO52OpK5XKhXCWySv8fz8nO9+8cUXCECTyaTdbiOJa61JKjs/P0+ShPB43/ebzSba0sEe9SjRarUwKrLz0zRtNpvYeGq1GuTe8zz869B9NnOappydXq8XBMF4PGZuR6MRq8C232w2eO+KopDeOC8wrvC2/dxqtcyoN+qQUMBhOBzSKRlGm6Ypab4koTLh+rdBCSgq5KQuFovj76pk+egzAZxsPp+T4iZVSWu12mw2+/zzzweDgVwM4VBKLZdL13WHw6HruuxssrWyLMOi5TgO6Rxiw2k2m1izuZUkViul2u12FEVpmgqHeDlgBoqi+Pjxo1IKG0AQBEJqtdb4Pj98+CB65HK59H2fcNP5fN7r9ZwbWK1W5KSq0lD25s0bYnoXi8VBHvYIMZvNYJybzcY1YqOotKdKe4kkkr5+/RqTIxXZ4KmIKQigMAmtNb3D4ATYjaMoWi6X9Dg72AMfCLftZ7wYSinP84hCJUpIlTbeH374AeFSlP7BYEBJB2R6rXWj0VgsFqgBb9682Ww24u0+1PP+Qby4ffBckSRJmqb9fr/f76/X6yiKPvvsM6UUOs1yuYRxsrPpvadLRwVRlEQLK6XOzs4wMMKP3717B0Hp9/sSUsiPNhoNz/OGw6H4q4hxf4H0HVqcJAlix2azkaQ3rXW73a5Wq9Cg8/NzMY9XKpU0TZnwfr8PG6jVarSihLj4vh8EwXK55IIoisIw5A6SfmdBPaPJZEJkCobcRqPR6/WktIJSKk1TpL3Ly0sWaDweo4yis8rRcBwHNsnJQhPlmjzPuewF1nFTt+/nSqVyeXnJFm02m2KqzbIsCIJvvvkGWuT7/vv375MkoY4NN3Rd9+3bt1EUCa8NwxCNv9/v40Q7atzXL3iH//mlgUnYVVzA4+OMcD+sVivzIxlqrVbDYCgfES6hSncdjrd6vc7rJEnevHnDxYjkSqler8cN2e7QEaJjZBiEeOwKJxdnpEo5o16vNxoNrbU4oZWREkCkqNaarzBpm80GIZ1/cW/zV2uNMMSiUFZs53EJxx9npG+JE2FOms2mGZbCtzDzqjIukhtKTQBdFoOl3+dms0EohNBzn2azKXFJAjFI7gq7pSePxB10/pP72ZxzsaNgFXNdV5dRGltE6dWrV7okdz/88AOvyShVSr1588ZxHLwYO3+03cYZvcQ87mcJKQ4iapDUu5E4I3Sder1OzgDtSpRS+N7a7baUnCbs5cOHD0qpXq+HfonVhSw63jF7iY/HY4T0F1isTgBBd10X5T6O49lshkWdKXVdl3m+vr7GxognD5uk67o///xzu91utVrtdhua3mq1qFMPof/w4QNFP8guPfU+M7tCvV4fDAYYVHTpWsavibVWKZUkyWQygfTjp4CbYiS/ma+ptZ7P5/1+H1MwyTD4QSS496Xhtv1MOQts3a7rZln25z//meyjjx8/Mue4iigoiBApc+66Lm7sIAjY0r7vQ3+QOI/dRfowZi7ftfro8eijeZ5Pp1NdytfsaV0GoIvMxb9b3QW01tPpFKus1loiWbgDYvtms+Ex+RfBnwu2ZPMd7orT0keZZAm+RZWUntjmd+UpzGMoOVQSVkqewHw+16U7Sm6+Wq1eYN6LvkWfwLRI2LzsRsdxut0ubWJVGb4uBhvmln8vLy+11kTYKaXglGRrFGXrFSk+w1eeYh/ukJ48EnfQ+U/uZ7aovENcrlJKUoa01lRp0CV9Q5r8+uuvmVvXdTGDyQKxao9JJrzj0Xarj9o+3g/HbuuPPL6ekdRbCcOQDiEEyKFQ6rLbFwJjURS9Xg9Bm8LQOErVb9v28lCotp7n1ev1yWRCh4d2u12v16VpQ57n+JAkTvLBU2HCPZF6RlEUffnll+PxmHdQjBCiqclAwJfjOPV6XSofeZ6HTklDRFX2T06ShLIeN3cCg3wiTfT46xmpO+vRUI1BlTxSviU1Wq+vr8/Pz+mSvVqtMKjIJMvzmjVdoXI4WfHVdbtdLtht6dfd0pNH4g46f9t+ltbfjJ9/mVtemwWh0jTldKBrbtUtMuscPdGjHbiekcXRgmJaUoabpE9ia/EPETqkSiqDbZb4RtlG7C2JziUuEX6MrwLy3Wg0aFkFK+XnOFFq1/0CTwKNRoOIFZioeJqV0bpL1B2h9Uop5hMmqsqMRnFI36SkLNCLNecS8qPKOdSlZqnK4GdEkyzLzKlzHAeR8fz8nC2tlOp0OkyjXClCg8kdnbJjGn4QVop3jr8PyVPgtv0sMMUj5pZdLZmgSOS85sWWkZx1OSENzfLR5wN6LqJPSOZcnuc//fST5DjjjYMYaa1JuRMVBJutKi0qSZLQWwrNAI5LixvyZLTWv/zyC01xpbKJeql9WNFsVqsVHBRpXZdB0Sj0nuddXl6+ZBfyI4GPTQS15XI5Go2kmzeOOqKNrq6uzs/Pz8/Pr66uKpUKZRYwMx70CU4bt+1nuqdJCZc4jilIctDB7g+Wjz4foFPSfFEpVa1WYYpkYqiy+hL1QqkLAwtUStGQnBCAxWIBWyUoAFmeFxhDKPeKMZMyyyI59vt9XTpoXxTEbdzpdGgTPRgMdOnowsdDwaPXr1+/wDo4uwJOYimI0+v1vv32Wyy3vV6PVupcdnFx8de//vWvf/3rxcUF36KEgqS4WDwAt+3nSqUiEqTWGlPtCSmUj4Tlo88E0t6PvDd8EsRHUENOlb5G+J/WGkuX5HjRYRF6pJQicABbMT11SYsOwzAMQwoC8CZWnSzL0G7xpx5uJg4D13XzPCc+azQaKaUQNcgQxdcoleosHX8wcCI4ZQmtLMukKC4XYBfBEvP69evXr1/neS4hoFzzcuj7znHbfiaeXClFkLlSqtPpvBz/juWjzwTVapW8LpyUhJUnSQLPEyHdcRzUJsdxSEgX0660A1yv16vVqt/vm+SeOgMUzKQcCWUHqtUq/7que3Z2Rm/Il0mnarUa4V1YFxE1Pnz4QFko13Wxlktkv8UDIOlA7HZcdBLMIgXoXdcNDIhDmu19wPidU8dt+5mYOBpH4j/SN7qsP2NYPvpMUBQFlVyUUrQ4JtqFvc6Gxm3p+/5sNiMSnb7HURRFUeT7Ps0FG40GoiUdNE3lUqqCyQuClaQTLxHt+3zw48FisUDygJTwgrIJEhe92Wykj7HFA0APgGq12ul0pF4rfJE2O0optnev12u32+12u9frZVk2m82UUjQqOewjnDRu28/kNeEtMl8cerx7guWjzwQSNGv6R7GrzGYzOibSYCRNU4rmOI5DwWgyTWlzgW9PKcX7RK4Thg5jJs5I/oXjdjqdNE0xF79YOkUJOqXUer2WClOUNJP6w1gLtppLW/xxkPpsJv/dtNYOBgM462w2g306jiP1pV/s/twJbtvPEBA+EkfPy6k//FKe89mDLUsjXNd1yXihBuZgMCBzizxoanCnaZplWb/fR4THn6SUwrdHc13aFDuOQySq2YVKGSl6UjYTPVi9yP7GaKLEK9JnEWmDNAmmZav3nMUDQGS49GyRXl0kNcplUn9Y6rXKR7Sh3ve4nwtu28/sdvNKZO5DjPEAsHUYHo5jq8Pw4J8+ZhxbHQYUbgg3NP0Eipb9MUilDimYvMM6A/etw0CpBNZ6Npt99dVXlLl5rl4D8kbQs3GvHDZYzyzDIsm4z8OvjFIRBAFhmPh6H9kC74WyQAuLh0GkJTIRJRX91EE64GazwUyHReGAIjK+/DiOm83mYDAgp+LZiCw3QXUkZRTKTpLE9/1Dycey9M1mk45yhBmeutaU5zl5DZLLoH5bOOJhOO1JsbDYM/B9Sngz5u5n4ArioWq1GmHGqqzNdqjxjMfjs7MzZXRNeB7yym2gH6f0GlNKhWFo9gzeMwg7V2WcBMoxrRQONaSdgAdZLBb0STWrYj0Glo9aWNwDrVaLkAoKPEHspJTr6QIXeBiGUsKNmgaHeq6zszPCPim5oJRarVa9Xu95e5dbrVaz2aSnymAwOKD+R82KVqtFKtF6vW42m88gX4u5lca9bKfHb3LLRy0s7gFq8asy/EoKgT7Sv3JweJ7nOA5MVGrYbjabQ9lRx+Mx9W+lBQ0GxoMMZg+g/xIpsKiheIgPNR6WXgIGpTTuqe/zwWCQJAmdHnzfl04Sj7yt5aMWFvcAx6/dbk8mk3a7LYXOn00JpyzL8ESqg/pHMerigaaSM1WjT13vvw2m6kkIzGGjOOV3KaUr/z6DfZ6mqSTWZ1k2HA5JCHwMLB+1sLgH8KnMZrN//Md/nE6nzyayX7KNR6MRSVNKqTRND0XH0zT1PI9h1Gq1b7/99uzsjCpaBxnPU8N1XRRQaShWr9cPKDSw9GTQvX79ejKZKGOTnDokqqvb7S6Xy8e3ZLd5Lw+HzXvZA44t72W9Xo9GI6y7nufRr1ga0p0uJPY4iiKzYe0O76/u2X9UKRXHcVEUjUaDw/WM817YP2iiRHgdw6F2HIfNAIPf6kZ3iiBaTaQBtqLZtPxheKEs8HRBQzRxyFEtQbwXzw9U8VWGu+iwxIUm2/fq+23xAJj9uaT9nHru80wyBs6Cw+5z4eL0q0DWPDhfP1pYPnpiwD8hvDPLsq+//ppa888bKH+Ym16sCcTCwuIIYeWLEwNqKFoRWQHj8fi5JqeDL7/8cjabVatVz/Pq9XpRFC+wv6mFhcXRwsr1JwbP82iuUqvV3r179/r160OP6Gmhtb6+viZanVplzyCJzcLC4jnB8tETw2w2a7VaRC2+fv2aNtqPDHE6ZriuS6EDk4MettSOhYWFhQnLR08MWznaxKY/7xAAs78HYVbPNfnBwsLiFGH56IkhiqJ6vZ4kiRm8+kdSCE4UPBeyAhHqVN459LgsLCws/g/PVol5riCRq9/v07eLUi+HHtQTAg6qyv7ApH894/pwFhYWJ4d766Na6yiKWq0WtCwIgn6//7xJ+SeBStRqtXhBCZgHx82Sx0IuvCqtl7dd7Ps+GV2e53HZM55/GqqYD6i1bjQau3pkaayIXEJ1izAMbytt6jhOpVKhbF6j0dhsNkVR2FSc3wXTS29nsp/b7fYdVVykYn6aps+p7OLJQXxGRPk9Y//RY3Dvekb/9zXHofTJVjrji4LneUVRzGazRqNB2MsDqjvleR7HMbPnOM50Oj1gs6QXiPV6/erVq8vLS1Lgf9fTPJ/PiXtSSk2n0+FwyPuPL3X9vCGWeQLOKVF0R30iPqVTulJqsVi8fv3648eP3W53vwN/oaBTfbvdDsMQqd1y0Dtwbz5K5SqpSEdqfL1eP/U+APeFWyLP86IoaDiMyHbfW0kVQKnb8pKrLe4fjuNQZvOPXNzpdPI8xxhDyTRWzSpMdwM+Wq1WoyhSZfOWO0izyCVM73A4nM/nnLU9jfhlw3Xd8Xj89u3bMAyFFtk4+dtwb2JN+Uel1Pn5+WQyGY1Gnuc94z71tyFJki+//PLdu3fv379/+/YtdIEeAvfCZrOh9J1s0DzPLR/dJ77//vs//elPSikqPNzdrGo6nV5cXEjEE+0MEd73Nd6TRJZleZ7TJ5zd7vv+Hd59WOx6veYrSqnvvvtOHbpa3ovC2dlZmqbUnsXfYZnobbi3PgrLrFar9AUMgqDZbKKWPdEQjxNJkmCMZQJXq9VjmgZgIRwMBh8/fsTr+WwaiRw5IO4wQokEHo/H9O36JBzHoa0xcmSe51EUYRa2+F2s1+tqtRoEwV/+8peff/75Nqlly2Zuuuj2N9YXjHfv3n355ZemhUwdtI/ekeOx/V7UC97cvu9nWWZOwgO4KQqNKhuJSMU7ayfcD/I8x6iL4RHHv+/70sH4k2DRkR1xk1s96XexFUUhHtBPXrxFsjlfcRzb1OH9gP1sdgigYYClS5/EveULSd0jUuDm+y8EqOBnZ2cfP3589eoVYcwPUEkHg0EYhnmedzqd+XwukZ/WTrgf5HmOgRECXRTFer3+3XXEho8F/jFx2i8HaZrCRDebTZ7njUbD8zyZ9k8iCAKJhwdUHdnHcC2U+vHHH/v9/ur/tXdvu2ljbQCGl8HsE0iCegW9/4vqcZVmVzY22J6D1UFzMpqf708CrZ/nABEkS0uOkpfPG3h7m0wm+TumLr2i6xW5Xne3293d3eVzG/nSu9PHzfTH8Xi8v7/fbDZ5B+b/CIHzxKc7XvIOzKeO+nn986V0/1CWZf5V/tvfxWn0rKpqOp2efnF/8K1H76Ioirqu67qeTqdlWZ6OhP/b+8U8CeXLDk4v/jHfI/1byDv/dOjlP9/39Jnv8Y573+/xBuB35CAJAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMTpKADE6SgAxOkoAMSd3dHj8fhry8EgpVSWZV3X77yo38dkMkkpvb6+tm1bFMWllwPAZyvP3WA8HjdNM5/Pu66rqqqqquVyWdf1aDT6iPVdraqq8mPXdcvlMqW02+1ms9ml1wXApzq7oyml5+fn7Xa7WCyapskJ6bqub9PYYDD4+vXrt2/fttvtzc3NZrPJsykAvVJ0XXfWBofDYTQazefz3W7Xdd3z8/NoNFosFh+0vqvVtu1wOEwp5R34+Pi4Xq+NpAB9c/Y8muOx2+1Go1FRFKvV6uXl5QMWdu3yIL5er79///7ly5f1et3DoRyAs+fRX5sVRVEUbdvmH+u6Ho/H77qwa7fdbh8eHuq6btu2bdvNZnN7e3vpRQHw2c7u6OPj4+3t7Wq12u/3Xdf9+PHj4eEhpdQ0zces8EoNh8M8feYdmA93N02T53UAeiI+j+Y7XnJL9vv9dDp977Vdu8FgUJbl29tbvsLIcV2AHjq7o23bDgaD0yh2PB7LMnLR7x8g74R852h+1FGAvvF5RgAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQp6MAEKejABCnowAQV567Qdd1KaXBYNC2bdd1ZVlut9v5fN627Qcs73oNBoOU0nA4LIpiu93OZrOiKNq2za8D0BNF7uL/LqeiKIr0d1N76/b29ufPn5vNZj6fbzabxWKx3++n0+ml1wXA5zl7Hm2a5tTR4XCYs9q3YfRksVjM5/Onp6ebm5uU0ng8vvSKAPhUZ8+jvzYrivxktVq9vLyMRqO+pXQ8HrdtW1VVVVU5nw7qAvTQ2R09HA6j0Wi3281ms7qui6LIP/ZtFHt9fb2/v8/Pm6apqmo2mx0Oh77tB4CUQKxJAAAApklEQVSeC3Y0pXQ6F/j09HQqSq/882xoXddvb2/r9fqySwLgk0WO6x6Px7Ztx+Px8/Pz3d1dSqnrur5dc9Q0zen9RF3Xy+WyaZqU0nA4vPTSAPg8Z3e0qqrJZHJ6kq9T/Zi1Xbt8w08e0PPzpml0FKBXgtcZAQDJ5xkBwP9DRwEgTkcBIE5HASBORwEgTkcBIE5HASBORwEgTkcBIE5HASBORwEg7i93oYa689g5ewAAAABJRU5ErkJggg==</encoded_png></node></node><node name="每个程序员需掌握的20个代码命名小贴士" prog_lang="custom-colors" readonly="False" tags="" unique_id="8"><rich_text>
</rich_text><rich_text scale="h2">1.使用能够表达意图的名字</rich_text><rich_text>
名字得能告诉我们它要做什么，为什么存在，以及是如何工作的。选择能够表达意图的名字，将更有利于我们理解代码。
int d; // elapsed time in days

int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
在上面的片段中，我们只能从注释中知道变量d指的是什么。于是阅读代码的人为了知道它的含义就不得不去寻找它的实例以获取线索。所以，要是我们能够好好命名这个变量，阅读代码的人就能够瞬间知道这变量的含义。

</rich_text><rich_text scale="h2">2.不要怕在选择名字上花时间</rich_text><rich_text>
你应该多试几种不同的名字，直至足以描述其含义，千万不要害怕在这上面花时间。以后阅读你代码的人（包括你自己）将会因此而受益。此外，一个描述性的名称甚至还能有助于你在心中理清模块的设计。良好的命名的确需要花费时间，但是从长远来看，利大于弊。

</rich_text><rich_text scale="h2">3.重构名字</rich_text><rich_text>
如果你在后面的开发过程中想到了一个更好的名字，那就不要犹豫，马上去改吧。现在的IDE使得重构名字变得异常容易。

</rich_text><rich_text scale="h2">4.避免在名字中出现干扰词</rich_text><rich_text>
比如Manager、Processor、Data、Info以及“我不知道这叫什么”的同义词，都是干扰词。如果你需要使用上面这些干扰词的话，那么说明你的命名可能太累赘了。

</rich_text><rich_text scale="h2">5.小心难以命名的类/功能</rich_text><rich_text>
一个很难命名的类或函数很有可能是一个代码异味。这说明：
• 代码做得太多。
• 代码做得还不够。
• 你对此问题理解得还不够透彻，需要先获取更多的信息。

</rich_text><rich_text scale="h2">6.类名</rich_text><rich_text>
类应该有个名词或名词词组的名字，如Customer、WikiPage、Account和AddressParser。继承性父类应该给个又短又有冲击力的名字。子类的名字应该长点，通过形容词来描述其不同于它的父类之处，如SavingsAccount衍生于Account。

</rich_text><rich_text scale="h2">7.变量名</rich_text><rich_text>
变量名也应该是名词。它们大多是由其指向的类衍生出去的。布尔变量应写成谓词的形式，如isEmpty和isTerminated，这样放到if语句才便于理解。

</rich_text><rich_text scale="h2">8.方法名</rich_text><rich_text>
方法名应该是一个动词或动词词组，如postPayment()、deletePage()和save()。访问器和调整器应该分别前缀get和set。返回布尔值的方法应该前缀‘is’，如isPostable()，这样在if语句中才便于理解。

</rich_text><rich_text scale="h2">9.范围大小与变量名的长度</rich_text><rich_text>
变量名的长度应和它的范围大小相匹配。如果变量的范围很短，那么变量名的长度也应该很短。反之，变量名则应该长一点，更有描述性。

</rich_text><rich_text scale="h2">10.范围大小与方法/类名的长度</rich_text><rich_text>
对于方法和类名的长度则应该与其范围成反比。对于公共方法，短一点的名字会比较好，这是因为它们会被调用多次。私有方法只在类的范围内被调用，长一点的名字反而可以作为文档使用。此条规则的例外是派生类的名字。类越派生，基类前所加的形容词就越多，名字也就越长。

</rich_text><rich_text scale="h2">11.一个概念一个词</rich_text><rich_text>
为某个抽象概念选定一个词，然后就不要变了。例如作为不同类中的等效方法，get()、fetch()和retrieve()会让人混淆起来。保持一致的词汇是程序员驾驭代码的重要工具。

</rich_text><rich_text scale="h2">12.不要将同一个词用于两个不同的概念</rich_text><rich_text>
如果你遵循第11点——一个概念一个词的原则，那么就可以避免许多有着相同方法名的类。只要参数列表和各种方法的返回值在语义上是等价的就没问题。只有当你将同一个词用于两个不同的概念时才会出现问题。
例如，我们可以在多个类中使用add()方法，通过添加或连接两个现有的值来创建一个新的值。如果我们之后又需要在类中引入一个add方法用于添加参数到集合中，这就会因为语义不同而导致问题。这种新方法最好是改叫为insert()。

</rich_text><rich_text scale="h2">13.使用解决方案领域的名字</rich_text><rich_text>
我们编写的代码今后可能会有其他程序员来阅读，所以我们使用一些技术术语进行</rich_text><rich_text link="webs http://www.codeceo.com/article/code-name.html">代码命名</rich_text><rich_text>会带来很大的好处。比如适当地使用算法名字、设计模式名字以及数学术语，这些命名方式很可能会让其他程序员更容易理解程序，引起共鸣。

</rich_text><rich_text scale="h2">14.使用问题领域的名字</rich_text><rich_text>
如果实在找不到易于理解的技术术语来命名，那么也可以从问题领域来寻找合适的代码命名。当未来阅读你代码的程序员不确定代码意义的时候，这将为他们提供一些问题的线索。

</rich_text><rich_text scale="h2">15.添加有意义的语境</rich_text><rich_text>
大多数名字其本身是没有意义的，并且需要放到语境（类/函数/命名空间）中，才能让阅读代码的人理解它们指代的是什么。在某些情况下，可能需要前缀名称以补充语境。例如，假设我们有一些用来表示地址的变量：firstName、lastName、street、houseNumber、city、state和zip。如果只看state这个变量，我们是很难推断出它指的是什么意思，一个比较好的解决办法就是将这些变量封装到Address类中。

</rich_text><rich_text scale="h2">16.不要添加没来由的语境</rich_text><rich_text>
只要意思明确，短一点的名字通常比长的好，所以不要多此一举地添加语境。名字前不应该被加缀一些可以从类/包/命名空间中推断的不必要的信息。

</rich_text><rich_text scale="h2">17.避免编码</rich_text><rich_text>
鉴于现在的IDE的强大，我们已经不需要编码类型和范围信息到变量名和类名中。这包括不必添加I至接口，因为使用代码的用户不需要知道他们的类正在向接口传递。所以如果你一定要使用编码，那么最好是对实现进行编码而不是接口。

</rich_text><rich_text scale="h2">18.避免错误的信息</rich_text><rich_text>
不要给一些错误的信息，因为这样会误导阅读代码的人。如果你将一个实际支持数组的变量命名为accountList，那就很容易让人得出错误的结论。

</rich_text><rich_text scale="h2">19.使用读不出来的名字</rich_text><rich_text>
编程是一个社会化的活动，使用那些读不出来的名字只会阻碍我们的讨论。

</rich_text><rich_text scale="h2">20.使用易搜索的名字</rich_text><rich_text>
使用短而通用的名字会妨碍我们在代码库中搜索事物。这对我们操纵代码和重构很有影响。
最后，如有不同意见，欢迎不吝赐教。
</rich_text></node><node name="减少C++代码编译时间的方法" prog_lang="custom-colors" readonly="False" tags="" unique_id="4"><rich_text>    c++的代码包含头文件和实现文件两部分， 头文件一般是提供给别人（也叫客户）使用的，  但是一旦头文件发生改变，不管多小的变化，所有引用他的文件就必须重新编译，编译就要花时间，假如你做的工程比较大（比如二次封装chrome这类的开 发）,重新编译一次的时间就会浪费上班的大部分时间，这样干了一天挺累的， 但是你的老板说你没有产出，结果你被fired， 是不是很怨啊，  如果你早点看到这段文章，你就会比你的同事开发效率高那么一些，那样被fired就不会是你了，你说这篇文章是不是价值千金！开个玩笑 ：）
    
言归正传，怎样介绍编译时间呢， 我知道的就3个办法：
1. 删除不必要的#include,替代办法 使用前向声明 (forward declared )
2. 删除不必要的一大堆私有成员变量，转而使用 “impl” 方法
3. 删除不必要的类之间的继承
为了讲清楚这3点，还是举个实例比较好,这个实例我会一步一步的改进（因为我也是一点一点摸索出来了，如果哪里说错了， 你就放心的喷吧，我会和你在争论到底的，呵呵）
现在先假设你找到一个新工作，接手以前某个程序员写的类，如下：
//  old.h: 这就是你接收的类            
//            
#include &lt;iostream&gt;            
#include &lt;ostream&gt;            
#include &lt;list&gt;                         

// 5 个 分别是file , db, cx, deduce or error ， 水平有限没有模板类            
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;  // class file            
#include &quot;db.h&quot;  // class db            
#include &quot;cx.h&quot;  // class cx            
#include &quot;deduce.h&quot;  // class deduce            
#include &quot;error.h&quot;  // class error         
                
class old : public file, private db {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx  get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;            
    
private:              
    std::list&lt;cx&gt; cx_list_;              
    deduce       deduce_d_;            
};
            
inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )            
{ 
    return old_val.print(os); 
}                        
这个类看完了， 如果你已经看出了问题出在哪里， 接下来的不用看了， 你是高手， 这些基本知识对你来说太小儿科，要是像面试时被问住了愣了一下，请接着看吧

</rich_text><rich_text scale="h3" weight="heavy">先看怎么使用第一条： 删除不必要的#include</rich_text><rich_text>
这个类引用 5个头文件， 那意味着那5个头文件所引用的头文件也都被引用了进来， 实际上， 不需要引用5 个，只要引用2个就完全可以了

</rich_text><rich_text scale="h3" weight="heavy">1.删除不必要的#include,替代办法 使用前向声明 (forward declared )</rich_text><rich_text>
1.1删除头文件 iostream， 我刚开始学习c++ 时照着《c++ primer》 抄，只要看见关于输入，输出就把 iostream 头文件加上， 几年过去了， 现在我知道不是这样的， 这里只是定义输出函数， 只要引用ostream 就够了

1.2.ostream头文件也不要， 替换为 iosfwd , 为什么， 原因就是， 参数和返回类型只要前向声明就可以编译通过， 在iosfwd 文件里 678行（我的环境是vs2013，不同的编译环境具体位置可能会不相同，但是都有这句声明） 有这么一句
typedef basic_ostream&lt;char, char_traits&lt;char&gt; &gt; ostream;

inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )
{ 
    return old_val.print(os); 
}

除此之外，要是你说这个函数要操作ostream 对象， 那还是需要#include &lt;ostream&gt; , 你只说对了一半， 的确， 这个函数要操作ostream 对象， 但是请看他的函数实现，
里面没有定义一个类似 std::ostream os, 这样的语句，话说回来，但凡出现这样的定义语句， 就必须#include 相应的头文件了 ，因为这是请求编译器分配空间，而如果只前向声明 class XXX; 编译器怎么知道分配多大的空间给这个对象！
看到这里， old.h头文件可以更新如下了：
//  old.h: 这就是你接收的类            
//            
#include &lt;iosfwd&gt;  //新替换的头文件            
#include &lt;list&gt;                         

// 5 个 分别是file , db, cx, deduce or error， 水平有限没有模板类            
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;  // class file，作为基类不能删除，                               
                            // 删除了编译器就不知道实例化old 对象时分配多大的空间了            
#include &quot;db.h&quot;  // class db，作为基类不能删除，同上            
#include &quot;cx.h&quot;  // class cx            
#include &quot;deduce.h&quot;  // class deduce            
// error 只被用做参数和返回值类型， 用前向声明替换#include &quot;error.h&quot;             
class error；                          
class old : public file, private db {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx  get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;            
    
private:              
    std::list&lt;cx&gt; cx_list_; //  cx 是模版类型，既不是函数参数类型                                      
                                      //  也不是函数返回值类型，所以cx.h 头文件不能删除              
    deduce       deduce_d_; //  deduce 是类型定义，也不删除他的头文件            
};            
inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )            
{ 
    return old_val.print(os); 
}                        
到目前为止， 删除了一些代码， 是不是心情很爽，据说看一个程序员的水平有多高， 不是看他写了多少代码，而是看他少写了多少代码。
如果你对C++ 编程有更深一步的兴趣， 接下来的文字你还是会看的，再进一步删除代码， 但是这次要另辟蹊径了


</rich_text><rich_text scale="h3" weight="heavy">2. 删除不必要的一大堆私有成员变量，转而使用 “impl” 方法</rich_text><rich_text>
2.1.使用 “impl” 实现方式写代码，减少客户端代码的编译依赖
impl 方法简单点说就是把 类的私有成员变量全部放进一个impl 类， 然后把这个类的私有成员变量只保留一个impl* 指针，代码如下：
// file old.h            
class old {              
    // 公有和保护成员              
    // public and protected members 
private:              
    // 私有成员， 只要任意一个的头文件发生变化或成员个数增加，              
    // 减少，所有引用old.h的客户端必须重新编译              
    // private members; whenever these change,              
    // all client code must be recompiled            
};                        
改写成这样：
// file old.h            
class old {              
    // 公有和保护成员              
    // public and protected members            
private:              
    class oldImpl* pimpl_;              
    //  替换原来的所有私有成员变量为这个impl指针，指针只需要前向声明就可以编译通过，              
    //  这种写法将前向声明和定义指针放在了一起，完全可以。              
    //  当然，也可以分开写              
    //  a pointer to a forward-declared class            
};                         

// file old.cpp            
struct oldImpl {              
    // 真正的成员变量隐藏在这里， 随意变化， 客户端的代码都不需要重新编译              
    // private members; fully hidden, can be              
    // changed at will without recompiling clients            
};                        
不知道你看明白了没有， 看不明白请随便写个类试验下，我就是这么做的，当然凡事也都有优缺点，下面简单对比下：
 
</rich_text><rich_text justification="left"></rich_text><rich_text>

改为impl实现后是这样的：
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;             
#include &quot;db.h&quot;             

class cx;            
class error；                         

class old : public file, private db {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx  get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;            
    
private:            
    class oldimpl* pimpl; //此处前向声明和定义            
};
            
inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )            
{ 
    return old_val.print(os); 
}                         

//implementation file old.cpp            
class oldimpl{            
    std::list&lt;cx&gt; cx_list_;            
    deduce        dudece_d_;            
};                        


</rich_text><rich_text scale="h3" weight="heavy">3. 删除不必要的类之间的继承</rich_text><rich_text>
面向对象提供了继承这种机制，但是继承不要滥用， old class 的继承就属于滥用之一， class old 继承file 和 db 类， 继承file是公有继承，继承db 是私有继承
，继承file 可以理解， 因为file 中有虚函数， old 要重新定义它， 但是根据我们的假设， 只有file 和 cx 有虚函数，私有继承db 怎么解释？! 那么唯一可能的理由就是：
通过 私有继承—让某个类不能当作基类去派生其他类，类似Java里final关键字的功能，但是从实例看，显然没有这个用意， 所以这个私有继承完全不必要， 应该改用包含的方式去使用db类提供的功能, 这样就可以
把”db.h”头文件删除， 把db 的实例也可以放进impl类中，最终得到的类是这样的：
// 只用 file and cx 有虚函数.            
#include &quot;file.h&quot;             

class cx;            
class error;            
class db;            

class old : public file {            
public:              
    old( const cx&amp; );              
    db  get_db( int, char* );              
    cx   get_cx( int, cx );              
    cx&amp; fun1( db );              
    error  fun2( error );              
    virtual std::ostream&amp; print( std::ostream&amp; ) const;
                
private:              
    class oldimpl* pimpl; //此处前向声明和定义             
};             

inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,const old&amp; old_val )             
{ 
    return old_val.print(os); 
}                         

//implementation file old.cpp            
class oldimpl {            
    std::list&lt;cx&gt; cx_list_;            
    deduce        dudece_d_;            
};                        

</rich_text><rich_text scale="h3">小结一下：</rich_text><rich_text>
这篇文章只是简单的介绍了减少编译时间的几个办法：
1. 删除不必要的#include,替代办法 使用前向声明 (forward declared )
2. 删除不必要的一大堆私有成员变量，转而使用 “impl” 方法
3. 删除不必要的类之间的继承
这几条希望对您有所帮助， 如果我哪里讲的不够清楚也可以参考附件，哪里有完整的实例，也欢迎您发表评论， 大家一起讨论进步，哦不，加薪。 呵呵，在下篇文章我将把impl实现方式再详细分析下，期待吧…
转自 </rich_text><rich_text link="webs http://blog.jobbole.com/85275/">http://blog.jobbole.com/85275/</rich_text><rich_text>
</rich_text><table char_offset="5246" col_max="400" col_min="40"><row><cell> </cell><cell>使用impl 实现类</cell><cell>不使用impl实现类</cell></row><row><cell>优点</cell><cell>类型定义与客户端隔离， 减少#include 的次数，提高编译速度，库端的类随意修改，客户端不需要重新编译</cell><cell>直接，简单明了，不需要考虑堆分配，释放，内存泄漏问题</cell></row><row><cell>缺点</cell><cell>对于impl的指针必须使用堆分配，堆释放，时间长了会产生内存碎片，最终影响程序运行速度， 每次调用一个成员函数都要经过impl-&gt;xxx()的一次转发</cell><cell>库端任意头文件发生变化，客户端都必须重新编译</cell></row><row><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell></row></table></node><node name="protocol buffer" prog_lang="custom-colors" readonly="False" tags="" unique_id="5"><rich_text></rich_text><node name="Protocol Buffer技术详解(语言规范)" prog_lang="custom-colors" readonly="False" tags="" unique_id="6"><rich_text>该系列Blog的内容主体主要源自于Protocol  Buffer的官方文档，而代码示例则抽取于当前正在开发的一个公司内部项目的Demo。这样做的目的主要在于不仅可以保持Google文档的良好风格和 系统性，同时再结合一些比较实用和通用的用例，这样就更加便于公司内部的培训，以及和广大网友的技术交流。需要说明的是，Blog的内容并非line  by  line的翻译，其中包含一些经验性总结，与此同时，对于一些不是非常常用的功能并未予以说明，有兴趣的开发者可以直接查阅Google的官方文档。

</rich_text><rich_text foreground="#ff6600">      一、为什么使用Protocol Buffer？</rich_text><rich_text>
        在回答这个问题之前，我们还是先给出一个在实际开发中经常会遇到的系统场景。比如：我们的客户端程序是使用Java开发的，可能运行自不同的平台， 如：Linux、Windows或者是Android，而我们的服务器程序通常是基于Linux平台并使用C++开发完成的。在这两种程序之间进行数据通讯时存在多种方式用于设计消息格式，如：
       1.  直接传递C/C++语言中一字节对齐的结构体数据，只要结构体的声明为定长格式，那么该方式对于C/C++程序而言就非常方便了，仅需将接收到的数据按照 结构体类型强行转换即可。事实上对于变长结构体也不会非常麻烦。在发送数据时，也只需定义一个结构体变量并设置各个成员变量的值之后，再以char*的方 式将该二进制数据发送到远端。反之，该方式对于Java开发者而言就会非常繁琐，首先需要将接收到的数据存于ByteBuffer之中，再根据约定的字节 序逐个读取每个字段，并将读取后的值再赋值给另外一个值对象中的域变量，以便于程序中其他代码逻辑的编写。对于该类型程序而言，联调的基准是必须客户端和 服务器双方均完成了消息报文构建程序的编写后才能展开，而该设计方式将会直接导致Java程序开发的进度过慢。即便是Debug阶段，也会经常遇到 Java程序中出现各种域字段拼接的小错误。
      2.  使用SOAP协议(WebService)作为消息报文的格式载体，由该方式生成的报文是基于文本格式的，同时还存在大量的XML描述信息，因此将会大大 增加网络IO的负担。又由于XML解析的复杂性，这也会大幅降低报文解析的性能。总之，使用该设计方式将会使系统的整体运行性能明显下降。
      对于以上两种方式所产生的问题，Protocol Buffer均可以很好的解决，不仅如此，Protocol Buffer还有一个非常重要的优点就是可以保证同一消息报文新旧版本之间的兼容性。至于具体的方式我们将会在后续的博客中给出。

</rich_text><rich_text foreground="#ff6600">      二、定义第一个Protocol Buffer消息。</rich_text><rich_text>
      创建扩展名为.proto的文件，如：MyMessage.proto，并将以下内容存入该文件中。
</rich_text><rich_text foreground="#0000ff">      message LogonReqMessage {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required int64 acctID = 1;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required string passwd = 2;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>
      这里将给出以上消息定义的关键性说明。
      1. message是消息定义的关键字，等同于C++中的struct/class，或是Java中的class。
      2. LogonReqMessage为消息的名字，等同于结构体名或类名。
       3. required前缀表示该字段为必要字段，既在序列化和反序列化之前该字段必须已经被赋值。与此同时，在Protocol  Buffer中还存在另外两个类似的关键字，optional和repeated，带有这两种限定符的消息字段则没有required字段这样的限制。相 比于optional，repeated主要用于表示数组字段。具体的使用方式在后面的用例中均会一一列出。
       4. int64和string分别表示长整型和字符串型的消息字段，在Protocol  Buffer中存在一张类型对照表，既Protocol  Buffer中的数据类型与其他编程语言(C++/Java)中所用类型的对照。该对照表中还将给出在不同的数据场景下，哪种类型更为高效。该对照表将在 后面给出。
      5. acctID和passwd分别表示消息字段名，等同于Java中的域变量名，或是C++中的成员变量名。
      6. 标签数字</rich_text><rich_text foreground="#0000ff">1</rich_text><rich_text>和</rich_text><rich_text foreground="#0000ff">2</rich_text><rich_text>则 表示不同的字段在序列化后的二进制数据中的布局位置。在该例中，passwd字段编码后的数据一定位于acctID之后。需要注意的是该值在同一 message中不能重复。另外，对于Protocol  Buffer而言，标签值为1到15的字段在编码时可以得到优化，既标签值和类型信息仅占有一个byte，标签范围是16到2047的将占有两个 bytes，而Protocol  Buffer可以支持的字段数量则为2的29次方减一。有鉴于此，我们在设计消息结构时，可以尽可能考虑让repeated类型的字段标签位于1到15之 间，这样便可以有效的节省编码后的字节数量。

</rich_text><rich_text foreground="#ff6600">      三、定义第二个（含有枚举字段）Protocol Buffer消息。</rich_text><rich_text>
</rich_text><rich_text foreground="#008000">      //在定义Protocol Buffer的消息时，可以使用和C++/Java代码同样的方式添加注释。</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      enum UserStatus {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          OFFLINE = 0;  </rich_text><rich_text foreground="#008000">//表示处于离线状态的用户</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          ONLINE = 1;   </rich_text><rich_text foreground="#008000">//表示处于在线状态的用户</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      message UserInfo {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required int64 acctID = 1;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required string name = 2;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required UserStatus status = 3;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>
      这里将给出以上消息定义的关键性说明（仅包括上一小节中没有描述的）。
      1. enum是枚举类型定义的关键字，等同于C++/Java中的enum。
      2. UserStatus为枚举的名字。
      3. 和C++/Java中的枚举不同的是，枚举值之间的分隔符是分号，而不是逗号。
      4. OFFLINE/ONLINE为枚举值。
      5. 0和1表示枚举值所对应的实际整型值，和C/C++一样，可以为枚举值指定任意整型值，而无需总是从0开始定义。如：
</rich_text><rich_text foreground="#0000ff">      enum OperationCode {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          LOGON_REQ_CODE = 101;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          LOGOUT_REQ_CODE = 102;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          RETRIEVE_BUDDIES_REQ_CODE = 103;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">    </rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          LOGON_RESP_CODE = 1001;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          LOGOUT_RESP_CODE = 1002;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          RETRIEVE_BUDDIES_RESP_CODE = 1003;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>

</rich_text><rich_text foreground="#ff6600">      四、定义第三个（含有嵌套消息字段）Protocol Buffer消息。</rich_text><rich_text>
      我们可以在同一个.proto文件中定义多个message，这样便可以很容易的实现嵌套消息的定义。如：
</rich_text><rich_text foreground="#0000ff">      enum UserStatus {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          OFFLINE = 0;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          ONLINE = 1;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      message UserInfo {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required int64 acctID = 1;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required string name = 2;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required UserStatus status = 3;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      message LogonRespMessage {</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required LoginResult logonResult = 1;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">          required UserInfo userInfo = 2;</rich_text><rich_text>
</rich_text><rich_text foreground="#0000ff">      }</rich_text><rich_text>
      这里将给出以上消息定义的关键性说明（仅包括上两小节中没有描述的）。
      1. LogonRespMessage消息的定义中包含另外一个消息类型作为其字段，如UserInfo userInfo。
       2.  上例中的UserInfo和LogonRespMessage被定义在同一个.proto文件中，那么我们是否可以包含在其他.proto文件中定义的 message呢？Protocol  Buffer提供了另外一个关键字import，这样我们便可以将很多通用的message定义在同一个.proto文件中，而其他消息定义文件可以通过 import的方式将该文件中定义的消息包含进来，如：
      </rich_text><rich_text foreground="#0000ff">import &quot;myproject/CommonMessages.proto&quot;</rich_text><rich_text>

</rich_text><rich_text foreground="#ff6600">      五、限定符(required/optional/repeated)的基本规则。</rich_text><rich_text>
      1. 在每个消息中必须至少留有一个required类型的字段。 
      2. 每个消息中可以包含0个或多个optional类型的字段。
      3. repeated表示的字段可以包含0个或多个数据。需要说明的是，这一点有别于C++/Java中的数组，因为后两者中的数组必须包含至少一个元素。
      4. 如果打算在原有消息协议中添加新的字段，同时还要保证老版本的程序能够正常读取或写入，那么对于新添加的字段必须是optional或repeated。道理非常简单，老版本程序无法读取或写入新增的required限定符的字段。

</rich_text><rich_text foreground="#ff6600">      六、类型对照表。</rich_text><rich_text>
</rich_text><rich_text justification="left"></rich_text><rich_text>

</rich_text><rich_text foreground="#ff6600">      七、Protocol Buffer消息升级原则。</rich_text><rich_text>
        在实际的开发中会存在这样一种应用场景，既消息格式因为某些需求的变化而不得不进行必要的升级，但是有些使用原有消息格式的应用程序暂时又不能被立刻升 级，这便要求我们在升级消息格式时要遵守一定的规则，从而可以保证基于新老消息格式的新老程序同时运行。规则如下：
      1. 不要修改已经存在字段的标签号。
      2. 任何新添加的字段必须是optional和repeated限定符，否则无法保证新老程序在互相传递消息时的消息兼容性。
      3. 在原有的消息中，不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但是他们之前使用的标签号必须被保留，不能被新的字段重用。
       4.  int32、uint32、int64、uint64和bool等类型之间是兼容的，sint32和sint64是兼容的，string和bytes是兼 容的，fixed32和sfixed32，以及fixed64和sfixed64之间是兼容的，这意味着如果想修改原有字段的类型时，为了保证兼容性，只 能将其修改为与其原有类型兼容的类型，否则就将打破新老消息格式的兼容性。
      5. optional和repeated限定符也是相互兼容的。

</rich_text><rich_text foreground="#ff6600">      八、Packages。</rich_text><rich_text>
      我们可以在.proto文件中定义包名，如：
      </rich_text><rich_text foreground="#0000ff">package ourproject.lyphone;</rich_text><rich_text>
      该包名在生成对应的C++文件时，将被替换为名字空间名称，既namespace ourproject { namespace lyphone。而在生成的Java代码文件中将成为包名。

</rich_text><rich_text foreground="#ff6600">      九、Options。</rich_text><rich_text>
      Protocol Buffer允许我们在.proto文件中定义一些常用的选项，这样可以指示Protocol Buffer编译器帮助我们生成更为匹配的目标语言代码。Protocol Buffer内置的选项被分为以下三个级别：
      1. 文件级别，这样的选项将影响当前文件中定义的所有消息和枚举。
      2. 消息级别，这样的选项仅影响某个消息及其包含的所有字段。
      3. 字段级别，这样的选项仅仅响应与其相关的字段。
      下面将给出一些常用的Protocol Buffer选项。
      1. option java_package = &quot;com.companyname.projectname&quot;;
      </rich_text><rich_text foreground="#0000ff">java_package</rich_text><rich_text>是 文件级别的选项，通过指定该选项可以让生成Java代码的包名为该选项值，如上例中的Java代码包名为 com.companyname.projectname。与此同时，生成的Java文件也将会自动存放到指定输出目录下的 com/companyname/projectname子目录中。如果没有指定该选项，Java的包名则为package关键字指定的名称。该选项对于 生成C++代码毫无影响。
      2. option java_outer_classname = &quot;LYPhoneMessage&quot;;
      </rich_text><rich_text foreground="#0000ff">java_outer_classname</rich_text><rich_text>是 文件级别的选项，主要功能是显示的指定生成Java代码的外部类名称。如果没有指定该选项，Java代码的外部类名称为当前文件的文件名部分，同时还要将 文件名转换为驼峰格式，如：my_project.proto，那么该文件的默认外部类名称将为MyProject。该选项对于生成C++代码毫无影响。
        注：主要是因为Java中要求同一个.java文件中只能包含一个Java外部类或外部接口，而C++则不存在此限制。因此在.proto文件中定义的消 息均为指定外部类的内部类，这样才能将这些消息生成到同一个Java文件中。在实际的使用中，为了避免总是输入该外部类限定符，可以将该外部类静态引入到 当前Java文件中，如：</rich_text><rich_text foreground="#0000ff">import static com.company.project.LYPhoneMessage.*</rich_text><rich_text>。
      3. option optimize_for = LITE_RUNTIME;
      </rich_text><rich_text foreground="#0000ff">optimize_for</rich_text><rich_text>是文件级别的选项，Protocol Buffer定义三种优化级别SPEED/CODE_SIZE/LITE_RUNTIME。缺省情况下是SPEED。
      SPEED: 表示生成的代码运行效率高，但是由此生成的代码编译后会占用更多的空间。
      CODE_SIZE: 和SPEED恰恰相反，代码运行效率较低，但是由此生成的代码编译后会占用更少的空间，通常用于资源有限的平台，如Mobile。
       LITE_RUNTIME: 生成的代码执行效率高，同时生成代码编译后的所占用的空间也是非常少。这是以牺牲Protocol  Buffer提供的反射功能为代价的。因此我们在C++中链接Protocol  Buffer库时仅需链接libprotobuf-lite，而非libprotobuf。在Java中仅需包含protobuf-java- 2.4.1-lite.jar，而非protobuf-java-2.4.1.jar。
      注：对于LITE_MESSAGE选项而言，其生成的代码均将继承自MessageLite，而非Message。    
      4. [</rich_text><rich_text foreground="#0000ff">pack</rich_text><rich_text>  = true]:  因为历史原因，对于数值型的repeated字段，如int32、int64等，在编码时并没有得到很好的优化，然而在新近版本的Protocol  Buffer中，可通过添加[pack=true]的字段选项，以通知Protocol Buffer在为该类型的消息对象编码时更加高效。如：
      repeated int32 samples = 4 [packed=true]。
      注：该选项仅适用于</rich_text><rich_text foreground="#ff0000">2.3.0</rich_text><rich_text>以上的Protocol Buffer。
      5. [</rich_text><rich_text foreground="#0000ff">default</rich_text><rich_text>  = default_value]:  optional类型的字段，如果在序列化时没有被设置，或者是老版本的消息中根本不存在该字段，那么在反序列化该类型的消息是，optional的字段 将被赋予类型相关的缺省值，如bool被设置为false，int32被设置为0。Protocol Buffer也支持自定义的缺省值，如：
      optional int32 result_per_page = 3 [default = 10]。

</rich_text><rich_text foreground="#ff6600">     十、命令行编译工具。</rich_text><rich_text>
      </rich_text><rich_text foreground="#0000ff">protoc</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">--proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto</rich_text><rich_text>
      这里将给出上述命令的参数解释。
      1. protoc为Protocol Buffer提供的命令行编译工具。
      2. --proto_path等同于-I选项，主要用于指定待编译的.proto消息定义文件所在的目录，该选项可以被同时指定多个。
      3. --cpp_out选项表示生成C++代码，--java_out表示生成Java代码，--python_out则表示生成Python代码，其后的目录为生成后的代码所存放的目录。
      4. path/to/file.proto表示待编译的消息定义文件。
       注：对于C++而言，通过Protocol  Buffer编译工具，可以将每个.proto文件生成出一对.h和.cc的C++代码文件。生成后的文件可以直接加载到应用程序所在的工程项目中。 如：MyMessage.proto生成的文件为MyMessage.pb.h和MyMessage.pb.cc。
</rich_text><table char_offset="4173" col_max="400" col_min="40"><row><cell>.proto Type</cell><cell>Notes</cell><cell>C++ Type</cell><cell>Java Type</cell></row><row><cell>double</cell><cell> </cell><cell> double</cell><cell> double</cell></row><row><cell>float</cell><cell> </cell><cell> float</cell><cell> float</cell></row><row><cell>int32</cell><cell>Uses variable-length encoding.  Inefficient for encoding negative numbers – if your field is likely to  have negative values, use sint32 instead.</cell><cell> int32</cell><cell> int</cell></row><row><cell>int64</cell><cell>Uses variable-length encoding.  Inefficient for encoding negative numbers – if your field is likely to  have negative values, use sint64 instead.</cell><cell> int64</cell><cell> long</cell></row><row><cell>uint32</cell><cell>Uses variable-length encoding.</cell><cell> uint32</cell><cell> int</cell></row><row><cell>uint64</cell><cell>Uses variable-length encoding.</cell><cell> uint64</cell><cell> long</cell></row><row><cell>sint32</cell><cell>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</cell><cell> int32</cell><cell> int</cell></row><row><cell>sint64</cell><cell>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. </cell><cell> int64</cell><cell> long</cell></row><row><cell>fixed32</cell><cell>Always four bytes. More efficient than uint32 if values are often greater than 228. </cell><cell> uint32</cell><cell> int</cell></row><row><cell>fixed64</cell><cell>Always eight bytes. More efficient than uint64 if values are often greater than 256.</cell><cell> uint64</cell><cell> long</cell></row><row><cell>sfixed32</cell><cell>Always four bytes.</cell><cell> int32</cell><cell> int</cell></row><row><cell>sfixed64</cell><cell>Always eight bytes.</cell><cell> int64</cell><cell> long</cell></row><row><cell>bool</cell><cell> </cell><cell> bool</cell><cell> boolean</cell></row><row><cell>string</cell><cell>A string must always contain UTF-8 encoded or 7-bit ASCII text.</cell><cell> string</cell><cell> String</cell></row><row><cell>bytes</cell><cell>May contain any arbitrary sequence of bytes.</cell><cell>string</cell><cell>ByteString</cell></row><row><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell></row></table></node><node name="Protocol Buffer的安装与使用" prog_lang="custom-colors" readonly="False" tags="" unique_id="7"><rich_text>最近要在产品中改进对象的序列化了。以前用的是java默认序列化实现功能，在产品上线之前要对关键的对象进行序列化/反序列化优化，以期改善存储效率。这里选取了Protocol buffer作为最终的方案，原因主要有以下几个方面：
1java默认序列化效率较低。
2apache的thrift方案并无明显优势，但是使用成本较高，安装等较为麻烦。
3虽然PB不支持map，但是我们的应用中map用的较少，即使使用了存储的数据量也较少，可以转化为list方案进行存储。
4以前我玩过PB,这很关键，当你有某方面的经验时能较轻松的应对一些意外情况。
 
以上只是我选择序列化方案的一些考虑。下面是PB的2.4.1版本的安装与使用示例：
 
</rich_text><rich_text scale="h2" weight="heavy">第一部分：windows7 安装 protocol buffer  (如果没有安装Maven，先安装maven，并且maven -version 验证安装成功)</rich_text><rich_text>
1.下载地址： </rich_text><rich_text link="webs http://code.google.com/p/protobuf/downloads/list">http://code.google.com/p/protobuf/downloads/list</rich_text><rich_text> 。从这里下载</rich_text><rich_text link="webs http://code.google.com/p/protobuf/downloads/detail?name=protobuf-2.4.1.tar.gz&amp;can=2&amp;q=">protobuf-2.4.1.tar.gz</rich_text><rich_text> 和 </rich_text><rich_text link="webs http://code.google.com/p/protobuf/downloads/detail?name=protoc-2.4.1-win32.zip&amp;can=2&amp;q=">protoc-2.4.1-win32.zip</rich_text><rich_text> 两个包。分别解压到各自目录。
2.将protoc-2.4.1-win32中的protoc.exe拷贝到c:\windows\system32中。
3.将proto.exe文件拷贝到解压后的XXX\protobuf-2.4.1\src目录中.
4.进入XXX\protobuf-2.4.1\java 目录  执行maven package命令编辑该包 生成protobuf-java-2.4.1.jar文件（位于target目录中）。
5.假设你的数据文件目录在XXX\data目录，把上一步生成的jar拷贝到该目录中即可。
6.进入XXX\protobuf-2.4.1\examples目录，可以看到addressbook.proto文件，执行命令</rich_text><rich_text foreground="#ff0000"> protoc --java_out=. addressbook.proto </rich_text><rich_text>命令，如果生成com文件夹并在最终生成AddressBookProtos类则说明安装成功。
 
 
</rich_text><rich_text scale="h2" weight="heavy">第二部分：使用篇</rich_text><rich_text>
 
定义proto文件：
1. option java_outer_classname = &quot;UserModelDatas&quot;;  
2.   
3. message ContextMatchedItemPair{  
4.       
5.     message Context{  
6.         optional string time=1;  
7.         optional int32 temperature=2;  
8.         optional string weather=3;  
9.         optional string location=4;  
10.         optional int32 priority=5;  
11.     }  
12.     optional Context context=1;  
13.     message MatchedItem{  
14.   
15.         optional string itemTypeId=1;  
16.         optional double matchRatio=2;  
17.         optional string approachType=3;  
18.           
19.         message Item{  
20.             optional string itemID =1;  
21.             optional string type=2;  
22.             optional string url=3;  
23.             optional string img=4;  
24.             optional string title=5;  
25.             optional string abs=6;  
26.             optional string date=7;  
27.             optional string sourceTypeId=8;  
28.         }  
29.           
30.         optional Item item=4;  
31.     }  
32.     repeated MatchedItem matchedItem = 2;  
33.       
34. }  
35. //out class  
36. message UserModelData{  
37.       
38.     repeated ContextMatchedItemPair contextMatchedItemPair=1;  
39. }  
 
 
执行命令：</rich_text><rich_text foreground="#ff0000">protoc --java_out=. UserModelData.proto  </rich_text><rich_text>即在同级目录下生成UserModelDatas类，该类即可在工程中使用了。如果要使用的话，还需要在工程中引入安装过程中生成的protobuf-java-2.4.1.jar 。
 
PS： 注意到我的所有类型都是repeated或者optional，并没有用required。 个人习惯而已。

</rich_text><rich_text scale="h2" weight="heavy">第三部分： protocol buffer C(linux)安装   </rich_text><rich_text scale="h2">         </rich_text><rich_text>
 下面描述了在 GNU/Linux x86_64(centeros)下安装 protocol buffer,支持 C 和 C++ 。
</rich_text><rich_text weight="heavy">1. google protocol buffer </rich_text><rich_text>
    下载 google protocol buffer,使用版本 2.5的,主页
    http://code.google.com/p/protobuf/
    下载地址:
    http://code.google.com/p/protobuf/downloads/detail?name=protobuf-2.5.0.tar.gz&amp;can=2&amp;q=

</rich_text><rich_text weight="heavy">2. protocol buffer C 下载</rich_text><rich_text>
    使用最新的,并有维护的 0.16 版本
    下载主页
    http://code.google.com/p/protobuf/wiki/ThirdPartyAddOns
    下载地址
    http://code.google.com/p/protobuf-c/
    下面地址是有维护的 0.16 版本
    https://github.com/protobuf-c/protobuf-c

</rich_text><rich_text weight="heavy">3. 安装 google protocol buffer</rich_text><rich_text>
    一般文件名称是  protobuf-2.5.0.tar
    执行命令解压
    tar -xvzf protobuf-2.5.0.tar
    得到目录 protobuf-2.5.0,下面是我的工作目录结构,pb 目录是全部有关 protocol buffer 的支持
    /home/huangzhihui/pb/protobuf-2.5.0
    执行 configure,构造 makefile 文件
    ./configure --help
    看看携带那些参数,我们指定下面的参数,编译为32 位版本
    ./configure --prefix=/usr/local/ CFLAGS=-m32 CXXFLAGS=-m32
    执行 make,编译完成 
    执行 make install,编译完成后安装完成

</rich_text><rich_text weight="heavy">4. 安装 protobuf-c</rich_text><rich_text>
    如果下载的是 protobuf-c-master.zip,</rich_text><rich_text link="webs http://www.2cto.com/os/windows/">windows</rich_text><rich_text> 上解压后拷贝到 linux 上。
    同样建立 /home/huangzhihui/pb/protobuf-c-master目录
    因为 protobuf 有些用于 C++ 支持  google rpc 和测试的功能,我们不编译
    也不安装它，所有我们这次修改一下 Makefile.am 文件。
    统一给  AM_CPPFLAGS 加上 -m32 参数，编译为 32 位的程序;
    统一给  AM_CFLAGS 加上  -m32 参数;
    统一给 AM_LDFLAGS 加上  -m32 -L/usr/local/lib/ 参数，指定链接库;
    注释掉有关 t/generated-code2 目录的所有文件,不参与编译和安装;
    执行 configure,构造 makefile 文件
    ./configure --help
    看看携带那些参数,我们指定下面的参数,编译为32 位版本
    
    ./configure --prefix=/usr/local/ CFLAGS=-m32 CXXFLAGS=-m32 protobuf_CFLAGS=-I/usr/local/include/ protobuf_LIBS=-L/usr/local/lib/
    执行 make,编译完成 
    执行 make install,编译完成后安装完成

</rich_text><rich_text weight="heavy">5. 测试 protobuf-c</rich_text><rich_text>
    进入 /home/huangzhihui/pb/protobuf-c-master/t(相对路径t)
    执行命令,根据协议描述文件，生成协议源代码
    /usr/local/bin/protoc-c test.proto --c_out=./
    静态链接 libprotobuf-c.a
    gcc -m32 generated-code/test-generated-code.c test.pb-c.c  -I../ -o test /usr/local/lib/libprotobuf-c.a
    运行 test,输出 test succeeded.OK
    ./test
    动态链接 protobuf-c
    gcc -m32 generated-code/test-generated-code.c test.pb-c.c  -I../ -o test -L/usr/local/lib/ -lprotobuf-c

</rich_text><rich_text weight="heavy">6. 查询 test-generated-code.c</rich_text><rich_text>
    /home/huangzhihui/pb/protobuf-c-master/t/generated-code/test-generated-code.c
    通过看这个代码,我们大致能明白 C 使用 protocol buffer 的流程。
</rich_text></node></node><node name="gcc" prog_lang="custom-colors" readonly="False" tags="" unique_id="3"><rich_text></rich_text><node name="GCC选项_-Wl,-soname " prog_lang="custom-colors" readonly="False" tags="" unique_id="2"><rich_text>-Wl选项告诉编译器将后面的参数传递给链接器。
-soname则指定了动态库的soname(简单共享名，Short for shared object name)

soname的关键功能是它提供了兼容性的标准：
当要升级系统中的一个库时，并且新库的soname和老库的soname一样，用旧库链接生成的程序使用新库依然能正常运行。这个特性使得在Linux下，升级使得共享库的程序和定位错误变得十分容易。
 
在Linux中，应用程序通过使用soname，来指定所希望库的版本，库作者可以通过保留或改变soname来声明，哪些版本是兼容的，这使得程序员摆脱了共享库版本冲突问题的困扰。
可以通过readelf -d来查看每个动态库的SONAME
 
</rich_text><rich_text scale="h3" weight="heavy">1. 声明libto.so.1，并生成libto.so.1.2</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.1 -o libto.so.1.2 to.c  
2. [root@localhost c]# ls -lh  
3. -rwxr-xr-x 1 root root 4268 Jan 10 17:22 libto.so.1.2  
4. [root@localhost c]# ldconfig -n ./  
5. lrwxrwxrwx 1 root root   12 Jan 10 17:23 libto.so.1 -&gt; libto.so.1.2  
6. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  

1. [root@localhost c]# readelf -d libto.so.1.2  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.1]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

</rich_text><rich_text scale="h3" weight="heavy">2. 声明libto.so.1，并生成libto.so.1.3</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.1 -o libto.so.1.3 to.c  
2. [root@localhost c]# ls -lh  
3. lrwxrwxrwx 1 root root   12 Jan 10 17:23 libto.so.1 -&gt; libto.so.1.2  
4. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
5. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
6. [root@localhost c]# ldconfig -n ./  
7. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  #重新ldconfig，指向新的库文件  
8. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
9. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  

1. [root@localhost c]# readelf -d libto.so.1.3  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.1]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

</rich_text><rich_text scale="h3" weight="heavy">3. 声明libto.so.2，并生成libto.so.1.4</rich_text><rich_text>
1. [root@localhost c]# gcc -fPIC -shared -Wl,-soname,libto.so.2 -o libto.so.1.4 to.c  
2. [root@localhost c]# ls -lh  
3. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  
4. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
5. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
6. -rwxr-xr-x 1 root root 4.2K Jan 10 17:24 libto.so.1.4  
7. [root@localhost c]# ldconfig -n ./  
8. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.1 -&gt; libto.so.1.3  #重新ldconfig，不指向新的库文件，因为新库(1.4)的soname为libto.so.2  
9. -rwxr-xr-x 1 root root 4.2K Jan 10 17:22 libto.so.1.2  
10. -rwxr-xr-x 1 root root 4.2K Jan 10 17:23 libto.so.1.3  
11. -rwxr-xr-x 1 root root 4.2K Jan 10 17:24 libto.so.1.4  
12. lrwxrwxrwx 1 root root   12 Jan 10 17:24 libto.so.2 -&gt; libto.so.1.4  

1. [root@localhost c]# readelf -d libto.so.1.4  
2.   
3.   
4. Dynamic section at offset 0x504 contains 21 entries:  
5.   Tag        Type                         Name/Value  
6.  0x00000001 (NEEDED)                     Shared library: [libc.so.6]  
7.  0x0000000e (SONAME)                     Library soname: [libto.so.2]  
8.  0x0000000c (INIT)                       0x2cc  
9.  0x0000000d (FINI)                       0x4c4  
10.  0x6ffffef5 (GNU_HASH)                   0xb4  
11.  0x00000005 (STRTAB)                     0x1b4  
12.  0x00000006 (SYMTAB)                     0xf4  
13.  0x0000000a (STRSZ)                      150 (bytes)  
14.  0x0000000b (SYMENT)                     16 (bytes)  
15.  0x00000003 (PLTGOT)                     0x15d8  
16.  0x00000002 (PLTRELSZ)                   24 (bytes)  
17.  0x00000014 (PLTREL)                     REL  
18.  0x00000017 (JMPREL)                     0x2b4  
19.  0x00000011 (REL)                        0x294  
20.  0x00000012 (RELSZ)                      32 (bytes)  
21.  0x00000013 (RELENT)                     8 (bytes)  
22.  0x6ffffffe (VERNEED)                    0x264  
23.  0x6fffffff (VERNEEDNUM)                 1  
24.  0x6ffffff0 (VERSYM)                     0x24a  
25.  0x6ffffffa (RELCOUNT)                   1  
26.  0x00000000 (NULL)                       0x0  

总结：程式库主要的升级会破坏相容性；而次要的升级则可能不会；那麽以下面的方式来连结，所有的一切就都会相安无事了。 
gcc -shared -Wl,-soname,libfoo.so.major -o libfoo.so.major.minor
</rich_text></node></node></cherrytree>