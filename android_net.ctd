<?xml version="1.0" ?><cherrytree><node name="wifi配置" prog_lang="custom-colors" readonly="False" tags="" unique_id="25"><rich_text scale="h2">一、WIFI的基本架构    </rich_text><rich_text>
    1、wifi用户空间的程序和库:
         external/wpa_supplicant/
       生成库libwpaclient.so和守护进程wpa_supplicant。    
    2、hardware/libhardware_legary/wifi/是wifi管理库。    
    3、JNI部分：
         frameworks/base/core/jni/android_net_wifi_Wifi.cpp    
    4、JAVA部分：
         frameworks/base/services/java/com/android/server/
         frameworks/base/wifi/java/android/net/wifi/    
    5、WIFI Settings应用程序位于：
       packages/apps/Settings/src/com/android/settings/wifi/   
    6、WIFI 驱动模块  wlan.ko        
        wpa_supplicant通过wireless_ext 接口和驱动通信   
    7、WIFI 硬件模块 
    
</rich_text><rich_text scale="h2">二、WIFI在Android中如何工作    </rich_text><rich_text>
    Android使用一个修改版wpa_supplicant作为daemon来控制WIFI，代码位于   external/wpa_supplicant。wpa_supplicant是通过socket与
   hardware/libhardware_legacy/wifi/wifi.c通信。UI通过android.net.wifi package
   （frameworks/base/wifi/java/android/net/wifi/）发送命令给wifi.c。
   相应的JNI实现位于frameworks/base/core/jni/android_net_wifi_Wifi.cpp。
   更高一级的网络管理位于frameworks/base/core/java/android/net。
  
</rich_text><rich_text scale="h2">三、配置Android支持WIFI    </rich_text><rich_text>
    在BoardConfig.mk中添加：
      BOARD_HAVE_WIFI := true
      BOARD_WPA_SUPPLICANT_DRIVER := WEXT
  
   这将在external/wpa_supplicant/Android.mk设置WPA_BUILD_SUPPLICANT为true，
   默认使用驱动driver_wext.c。
   如果使用定制的wpa_supplicant驱动(例如 madwifi)，可以设置:
       BOARD_WPA_SUPPLICANT_DRIVER := MADWIFI
       
   在android ICS以后，BoardConfig.mk改为以下内容：
    WPA_SUPPLICANT_VERSION := VER_0_8_X
    BOARD_WPA_SUPPLICANT_DRIVER := NL80211
    BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_rtl
    BOARD_HOSTAPD_DRIVER        := NL80211
    BOARD_HOSTAPD_PRIVATE_LIB   := lib_driver_cmd_rtl

    SW_BOARD_USR_WIFI := rtl8188eu
    BOARD_WLAN_DEVICE := rtl8188eu   
  
</rich_text><rich_text scale="h2">四、使能wpa_supplicant调试信息    </rich_text><rich_text>
    默认wpa_supplicant设置为MSG_INFO，为了输出更多信息，可修改：
   1、在common.c中设置wpa_debug_level = MSG_DEBUG;
   2、在common.c中把#define wpa_printf宏中的
      if ((level) &gt;= MSG_INFO)
      改为
      if ((level) &gt;= MSG_DEBUG) 
      
</rich_text><rich_text scale="h2">五、配置wpa_supplicant.conf</rich_text><rich_text>
   wpa_supplicant是通过wpa_supplicant.conf中的ctrl_interface=来指定控制socket的，应该在   
   AndroidBoard.mk中配置好复制到$(TARGET_OUT_ETC)/wifi（也就是   /system/etc/wifi/wpa_supplicant.conf）
   这个位置会在init.rc中再次检测的。
   一般的wpa_supplicant.conf配置为：
      ctrl_interface=DIR=/data/system/wpa_supplicant GROUP=wifi
      update_config=1
      fast_reauth=1  
   有时，驱动需要增加：
      ap_scan=1   如果遇到AP连接问题，需要修改ap_scan=0来让驱动连接，代替wpa_supplicant。
  
   如果要连接到non-WPA or open wireless networks，要增加：
      network={
              key_mgmt=NONE
      } 
      
</rich_text><rich_text scale="h2">六、配置路径和权限    </rich_text><rich_text>
    Google修改的wpa_supplicant要运行在wifi用户和组下的。代码可见wpa_supplicant/os_unix.c   中的os_program_init()函数。
  
   如果配置不对，会出现下面错误：
      E/WifiHW  (  ): Unable to open connection to supplicant on      &quot;/data/system/wpa_supplicant/wlan0&quot;: No such file or directory will appear.
 
   确认init.rc中有如下配置：
       mkdir /system/etc/wifi 0770 wifi wifi
       chmod 0770 /system/etc/wifi
       chmod 0660 /system/etc/wifi/wpa_supplicant.conf
       chown wifi wifi /system/etc/wifi/wpa_supplicant.conf
       # wpa_supplicant socket
       mkdir /data/system/wpa_supplicant 0771 wifi wifi
       chmod 0771 /data/system/wpa_supplicant
       #wpa_supplicant control socket for android wifi.c
       mkdir /data/misc/wifi 0770 wifi wifi
       mkdir /data/misc/wifi/sockets 0770 wifi wifi
       chmod 0770 /data/misc/wifi
       chmod 0660 /data/misc/wifi/wpa_supplicant.conf    如果系统的/system目录为只读，那应该使用路径/data/misc/wifi/wpa_supplicant.conf。
  
</rich_text><rich_text scale="h2">七、运行wpa_supplicant和dhcpcd</rich_text><rich_text>
   在init.rc中确保有如下语句：
      service wpa_supplicant /system/bin/logwrapper /system/bin/wpa_supplicant -dd                   -Dwext -iwlan0 -c /data/misc/wifi/wpa_supplicant.conf
         user root
         group wifi inet
         socket wpa_wlan0 dgram 660 wifi wifi
         oneshot      
         
     service dhcpcd /system/bin/logwrapper /system/bin/dhcpcd -d -B wlan0
         disabled
         oneshot    
         
         根据所用的WIFI驱动名字，修改wlan0为自己驱动的名字。
         
     在android JB 中改为:
        service wpa_supplicant /system/bin/wpa_supplicant \
            -iwlan0 -Dnl80211 -c/data/misc/wifi/wpa_supplicant.conf -e/data/misc/wifi/entropy.bin
            #   we will start as root and wpa_supplicant will switch to user wifi
            #   after setting up the capabilities required for WEXT
            #   user wifi
            #   group wifi inet keystore
            class main
            socket wpa_wlan0 dgram 660 wifi wifi
            disabled
            oneshot

        service p2p_supplicant /system/bin/wpa_supplicant \
            -iwlan0 -Dnl80211 -iwlan0 -c/data/misc/wifi/wpa_supplicant.conf -N \
            -ip2p0 -Dnl80211 -c /data/misc/wifi/p2p_supplicant.conf -e/data/misc/wifi/entropy.bin -puse_p2p_group_interface=1
        #   we will start as root and wpa_supplicant will switch to user wifi
        #   after setting up the capabilities required for WEXT
        #   user wifi
        #   group wifi inet keystore
            class main
            socket wpa_wlan0 dgram 660 wifi wifi
            disabled
            oneshot

        service dhcpcd_wlan0 /system/bin/dhcpcd -aABKL
            class main
            disabled
            oneshot

        service dhcpcd_p2p /system/bin/dhcpcd -aABKL
            class main
            disabled
            oneshot

        service dhcpcd_eth0 /system/bin/dhcpcd -ABKL -f/system/etc/dhcpcd/dhcpcd.conf
            class main
            disabled
            oneshot

        service dhcpcd_bnep0 /system/bin/dhcpcd -ABKL
            class main
            disabled
            oneshot

        service iprenew_wlan0 /system/bin/dhcpcd -n
            class main
            disabled
            oneshot

        service iprenew_p2p /system/bin/dhcpcd -n
            class main
            disabled
            oneshot

        service iprenew_eth0 /system/bin/dhcpcd -n
            class main
            disabled
            oneshot
         
   
</rich_text><rich_text scale="h2">七、编译WIFI驱动为module或kernel built in    </rich_text><rich_text>
   1、编译为module
      在BoardConfig.mk中添加：
         WIFI_DRIVER_MODULE_PATH := &quot;/system/lib/modules/ar6000.ko&quot;
         WIFI_DRIVER_MODULE_ARG := &quot;&quot;  #for example nohwcrypt
         WIFI_DRIVER_MODULE_NAME := &quot;ar6000&quot;  #for example wlan0 
         WIFI_FIRMWARE_LOADER := &quot;&quot;         
  
   2、编译为kernel built in  
     1）在hardware/libhardware_legacy/wifi/wifi.c要修改interface名字，
     2）在init.rc中添加：
        setprop wifi.interface &quot;wlan0&quot;
        
        在android ICS以后，改为：
        PRODUCT_PROPERTY_OVERRIDES += \
	        wifi.interface=wlan0 \
	        wifi.supplicant_scan_interval=15 \
	        keyguard.no_require_sim=true
        
     3）在hardware/libhardware_legacy/wifi/wifi.c中当insmod/rmmod时，
        直接return 0。
 
</rich_text><rich_text scale="h2">八、WIFI需要的firmware    </rich_text><rich_text>
    Android不使用标准的hotplug binary，WIFI需要的firmware要复制到/etc/firmware。
   或者复制到WIFI驱动指定的位置，然后WIFI驱动会自动加载。 
   
</rich_text><rich_text scale="h2">九、修改WIFI驱动适合Android    </rich_text><rich_text>
    Google修改的wpa_supplicant要求SIOCSIWPRIV ioctl发送命令到驱动，及接收信息，例如signal   strength, mac address of the AP, link speed等。所以要正确实现WIFI驱动，需要从   SIOCSIWPRIV ioctl返回RSSI (signal strength)和MACADDR信息。    如果没实现这个ioctl，会出现如下错误：
     E/wpa_supplicant(  ): wpa_driver_priv_driver_cmd failed                               wpa_driver_priv_driver_cmd RSSI len = 4096 
     E/wpa_supplicant(  ): wpa_driver_priv_driver_cmd failed 
     D/wpa_supplicant(  ): wpa_driver_priv_driver_cmd LINKSPEED len = 4096
     E/wpa_supplicant(  ): wpa_driver_priv_driver_cmd failed 
     I/wpa_supplicant(  ): CTRL-EVENT-DRIVER-STATE HANGED
   
</rich_text><rich_text scale="h2">十、设置dhcpcd.conf</rich_text><rich_text>
   一般/system/etc/dhcpcd/dhcpcd.conf的配置为：
      interface wlan0
      option subnet_mask, routers, domain_name_server</rich_text><node name="wifi jni" prog_lang="custom-colors" readonly="False" tags="" unique_id="26"><rich_text>android下如何通过jni监控wifi网络连接、dhcpcd执行和power电源控制
=============================================================================================================
libs/android_runtime/android_net_wifi_Wifi.cpp
部分jni接口
static JNINativeMethod gWifiMethods[] = {
    { &quot;loadDriver&quot;, &quot;()Z&quot;, (void *)android_net_wifi_loadDriver },
    { &quot;setPowerModeCommand&quot;, &quot;(I)Z&quot;, (void*) android_net_wifi_setPowerModeCommand },//电源管理
    { &quot;connectToSupplicant&quot;, &quot;()Z&quot;, (void *)android_net_wifi_connectToSupplicant },
    { &quot;waitForEvent&quot;, &quot;()Ljava/lang/String;&quot;, (void*) android_net_wifi_waitForEvent },
    { &quot;disconnectCommand&quot;, &quot;()Z&quot;, (void *)android_net_wifi_disconnectCommand },
    ...
};
int register_android_net_wifi_WifiManager(JNIEnv* env)
{
    ...
    return AndroidRuntime::registerNativeMethods(env,
            WIFI_PKG_NAME, gWifiMethods, NELEM(gWifiMethods));//登记jni
}
libs/android_runtime/AndroidRuntime.cpp
static const RegJNIRec gRegJNI[] = {
    ...
    REG_JNI(register_android_net_wifi_WifiManager),
    ...
};
int AndroidRuntime::startReg(JNIEnv* env)
{
    ...
    register_jni_PRocs(gRegJNI, NELEM(gRegJNI), env);
    ...
}
AndroidRuntime::start
=&gt;startReg(env)即调用方法int AndroidRuntime::startReg(JNIEnv* env)
=============================================================================================================
wifi_load_driver
wifi_start_supplicant
=&gt;ensure_config_file_exists
//检查/data/misc/wifi/wpa_supplicant.conf文件是否存在,如果不存在,那么从/system/etc/wifi/wpa_supplicant.conf动态拷贝一份
android_net_wifi_connectToSupplicant
=&gt;wifi_connect_to_supplicant
=&gt;
    ctrl_conn = wpa_ctrl_open(ifname);
    monitor_conn = wpa_ctrl_open(ifname);
    wpa_ctrl_attach(monitor_conn);
android_net_wifi_waitForEvent
=&gt;wifi_wait_for_event
=&gt;wpa_ctrl_recv(monitor_conn, buf, &amp;nread);
=&gt;recv(ctrl-&gt;s, reply, *reply_len, 0);//阻塞等待wpa_supplicant的netlink数据过来
=&gt;如果接收的buf数据区,buf[0]为'&lt;',那么说明有level级别信息,所以将'&lt;'...'&gt;'数据剔除,然后wifi_wait_for_event函数返回[luther.gliethttp].
java/android/android/net/wifi/WifiMonitor.java
public class WifiMonitor {
    ...
    public void startMonitoring() {
        new MonitorThread().start();//启动java线程
    }
    class MonitorThread extends Thread {
        public MonitorThread() {
            super(&quot;WifiMonitor&quot;);
        }
    public void run() {
        for (;;) {
            ensureSupplicantConnection();//=&gt;WifiNative.connectToSupplicant调用jni函数android_net_wifi_connectToSupplicant
            String eventStr = WifiNative.waitForEvent();//=&gt;调用jni函数android_net_wifi_waitForEvent
            //private static final int CONNECTED = 1;
            //private static final int DISCONNECTED = 2;
            //private static final String eventPrefix = &quot;CTRL-EVENT-&quot;;
            //private static final int eventPrefixLen = eventPrefix.length();
            //private static final String connectedEvent = &quot;CONNECTED&quot;;
            //private static final String disconnectedEvent = &quot;DISCONNECTED&quot;;
            String eventName = eventStr.substring(eventPrefixLen);//去掉&quot;CTRL-EVENT-&quot;字符串
            int nameEnd = eventName.indexOf(' ');//找到随后的空格位置,这在wpa_supplicant发送时
//#define WPA_EVENT_CONNECTED &quot;CTRL-EVENT-CONNECTED &quot;中,已经内置空格了.
                if (nameEnd != -1)
                    eventName = eventName.substring(0, nameEnd);
            int event;
                if (eventName.equals(connectedEvent))//检测netlink过来的字符串action类型
                    event = CONNECTED;
                else if (eventName.equals(disconnectedEvent))
                    event = DISCONNECTED;
    ...
            int ind = eventStr.indexOf(&quot; - &quot;);//CTRL-EVENT-CONNECTED - Connection to ...
                    if (ind != -1)
                        eventData = eventStr.substring(ind + 3);
//剔除前导控制字符,将&quot; - &quot;后面的描述字符串作为真实数据,继续处理
    ...
            if (event == STATE_CHANGE) {
                    handleSupplicantStateChange(eventData);
                } else if (event == DRIVER_STATE) {
                    handleDriverEvent(eventData);
                } else {
                    handleEvent(event, eventData);//对于CONNECTED和DISCONNECTED等netlink事件将执行此操作来处理[luther.gliethttp]
                    // If supplicant is gone, exit the thread
                    if (event == TERMINATING) {
                        break;
                    }
                }
    ...
            void handleEvent(int event, String remainder) {
            switch (event) {
                case DISCONNECTED:
                    handleNetworkStateChange(NetworkInfo.DetailedState.DISCONNECTED, remainder);
                    break;
                case CONNECTED:
                    handleNetworkStateChange(NetworkInfo.DetailedState.CONNECTED, remainder);//控制界面显示
                    break;
    ...
}
public class WifiStateTracker extends NetworkStateTracker {
    ...
        public void startEventLoop() {
        mWifiMonitor.startMonitoring();//启动上面的MonitorThread线程
    }
    ...
}
java/services/com/android/server/WifiService.java
public class WifiService extends IWifiManager.Stub {
    ...
    private boolean setWifiEnabledBlocking(boolean enable) {
        final int eventualWifiState = enable ? WIFI_STATE_ENABLED : WIFI_STATE_DISABLED;
            ...
            if (enable) {
            if (WifiNative.loadDriver()) {
                Log.e(TAG, &quot;Failed to load Wi-Fi driver.&quot;);
                updateWifiState(WIFI_STATE_UNKNOWN);
                return false;
            }
            if (WifiNative.startSupplicant()) {
                WifiNative.unloadDriver();
                Log.e(TAG, &quot;Failed to start supplicant daemon.&quot;);
                updateWifiState(WIFI_STATE_UNKNOWN);
                return false;
            }
            mWifiStateTracker.startEventLoop();
//启动MonitorThread线程,等待wpa_supplicant将netlink数据转发过来,然后根据netlink动作类型,进一步影响界面显示[luther.gliethttp].
        }
    ...
}
java/android/android/net/wifi/WifiStateTracker.java
电源管理
private void handleConnectedState() {
    ...
    mDhcpTarget.obtainMessage(EVENT_DHCP_START).sendToTarget();//传递到下面的handleMessage方法
    ...
}
public void onChange(boolean selfChange) {
    ...
    handleConnectedState();
    ...
}
public class WifiStateTracker extends NetworkStateTracker {
    ...
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case EVENT_SUPPLICANT_CONNECTION:
            case EVENT_NETWORK_STATE_CHANGED:
                handleConnectedState();//调用
    ...
    private class DhcpHandler extends Handler {
        private Handler mTarget;
        public DhcpHandler(Looper looper, Handler target) {
            super(looper);
            mTarget = target;
        }
        public void handleMessage(Message msg) {
            int event;
        //private static final int DRIVER_POWER_MODE_AUTO = 0;
        //private static final int DRIVER_POWER_MODE_ACTIVE = 1;
            switch (msg.what) {
                case EVENT_DHCP_START:
                    synchronized (this) {
                        WifiNative.setPowerModeCommand(DRIVER_POWER_MODE_ACTIVE);//设置电源模式,调用android_net_wifi_setPowerModeCommand
                    }
                    Log.d(TAG, &quot;DhcpHandler: DHCP request started&quot;);
//libs/android_runtime/android_net_NetUtils.cpp
//static JNINativeMethod gNetworkUtilMethods[] = {
//{ &quot;runDhcp&quot;, &quot;(Ljava/lang/String;Landroid/net/DhcpInfo;)Z&quot;, (void *)android_net_utils_runDhcp },
// ...
//};
                    if (NetworkUtils.runDhcp(mInterfaceName, mDhcpInfo)) {//执行dhcp申请ip地址操作
                        event = EVENT_INTERFACE_CONFIGURATION_SUCCEEDED;
                        if (LOCAL_LOGD) Log.v(TAG, &quot;DhcpHandler: DHCP request succeeded&quot;);
                    } else {
                        event = EVENT_INTERFACE_CONFIGURATION_FAILED;
                        Log.i(TAG, &quot;DhcpHandler: DHCP request failed: &quot; +
                            NetworkUtils.getDhcpError());
//如果dhcpcd分配ip失败,那么Message.obtain(mTarget, event).sendToTarget();将执行
//WifiNative.disconnectCommand();即：static JNINativeMethod gWifiMethods[] = {
//android_net_wifi_disconnectCommand发送&quot;DISCONNECT&quot;字符串[luther.gliethttp]
//然后在wpa_supplicant服务端执行wpa_supplicant_ctrl_iface_process
//wpa_supplicant_disassociate
                    }
                    synchronized (this) {
                        WifiNative.setPowerModeCommand(DRIVER_POWER_MODE_AUTO);
                    }
                    Message.obtain(mTarget, event).sendToTarget();
                    break;
            }
        }
    }
    ...
    /**
     * Send the tracker a notification that a connection to the supplicant
     * daemon has been established.
     */
//在上面的public class WifiMonitor=&gt;ensureSupplicantConnection
//=&gt;
//while (!supplicantConnected) {
// boolean connected;
//synchronized (mWifiStateTracker) {
//connected = WifiNative.connectToSupplicant();//如果没有连接成功,那么while循环尝试,直到尝试成功,或者定义了oneShot,仅一次尝试
//=&gt;mWifiStateTracker.notifySupplicantConnection();//如果WifiNative.connectToSupplicant()成功,那么将执行
//mWifiStateTracker.notifySupplicantConnection();的调用.
    void notifySupplicantConnection() {//向对象发送message
        Message.obtain(this, EVENT_SUPPLICANT_CONNECTION).sendToTarget();
    }
    void notifyStateChange(SupplicantState newState) {
        Message.obtain(this, EVENT_SUPPLICANT_STATE_CHANGED, newState).sendToTarget();
    }
    ...
}
static jboolean android_net_wifi_setPowerModeCommand(JNIEnv* env, jobject clazz, jint mode)
{
    char cmdstr[256];
    sprintf(cmdstr, &quot;DRIVER POWERMODE %d&quot;, mode);
    return doBooleanCommand(cmdstr, &quot;OK&quot;);
}
android_net_wifi_setPowerModeCommand
=&gt;doBooleanCommand
=&gt;doCommand
=&gt;wifi_command
=&gt;wifi_send_command
=&gt;wpa_ctrl_request
=&gt;send给wpa_supplicant
然后wpa_supplicant将做如下接收操作：
system/extra/wpa_supplicant/main.c
=&gt;wpa_supplicant_add_iface
=&gt;wpa_supplicant_init_iface2
=&gt;wpa_supplicant_ctrl_iface_init
=&gt;注册ctrl_conn控制端口和monitor_conn监听端口的处理函数
  eloop_register_read_sock(priv-&gt;sock, wpa_supplicant_ctrl_iface_receive, wpa_s, priv);//ctrl_conn端口的handler处理函数
  wpa_msg_register_cb(wpa_supplicant_ctrl_iface_msg_cb);//monitor_conn端口的回调处理函数,处理netlink数据到所有monitor_conn监听端口
=&gt;wpa_supplicant_ctrl_iface_receive//对于unix通信方式
=&gt;wpa_supplicant_ctrl_iface_process
=&gt;如果wpa_cli发送的是wpa_cli driver xxx形式的命令,那么调用这个函数
if (os_strncmp(buf, &quot;DRIVER &quot;, 7) == 0) {//掠过前7个,直接将命令传过去
reply_len = wpa_supplicant_driver_cmd(wpa_s, buf + 7, reply, reply_size);
=&gt;wpa_supplicant_driver_cmd
=&gt;wpa_drv_driver_cmd
=&gt;自定义DRIVER扩展处理函数,所以对于java传递过来的power电源管理命令,wpa_drv_driver_cmd将收到&quot;POWERMODE 0&quot;或者&quot;POWERMODE 1&quot;字符串[luther.gliethttp]
=============================================================================================================
jni
=&gt;runDhcp
=&gt;android_net_utils_runDhcp
libs/netutils/dhcp_utils.c
=&gt;dhcp_do_request
=&gt;
    static const char DAEMON_NAME[] = &quot;dhcpcd&quot;;
    static const char DAEMON_PROP_NAME[] = &quot;init.svc.dhcpcd&quot;;
    static const char DHCP_PROP_NAME_PREFIX[] = &quot;dhcp&quot;;
    const char *ctrl_prop = &quot;ctl.start&quot;;
    const char *desired_status = &quot;running&quot;;
    snprintf(result_prop_name, sizeof(result_prop_name), &quot;%s.%s.result&quot;,
            DHCP_PROP_NAME_PREFIX,
            interface);
    property_set(result_prop_name, &quot;&quot;);//设置dhcp.eth0.result=&quot;&quot;;等到成功完成dhcp之后,
    property_set(ctrl_prop, DAEMON_NAME);//向名字为dhcpcd的service,发送&quot;ctrl.start&quot;启动命令字,该service在init.rc中
//init.rc中dhcpcd服务进程命令字
//service dhcpcd /system/bin/dhcpcd eth0
// disabled
// oneshot 
    wait_for_property(DAEMON_PROP_NAME, desired_status, 10);
//init.c=&gt;init进程
//=&gt;handle_property_set_fd因为是&quot;ctrl.start&quot;命令字,所以调用handle_control_message处理控制信息
//=&gt;handle_control_message
//=&gt;msg_start
//=&gt;
// struct service *svc = service_find_by_name(name);
// service_start(svc);//启动svc,即执行：/system/bin/dhcpcd eth0
//=&gt;service_start
//=&gt;pid = fork();
// if(pid == 0)execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV);子进程执行execve运行/system/bin/dhcpcd,参数为eth0
//=&gt;否则父进程,即init进程将
//=&gt;notify_service_state(svc-&gt;name, &quot;running&quot;);设置该svc的状态prop
// snprintf(pname, sizeof(pname), &quot;init.svc.%s&quot;, name);
// property_set(pname, state);//所以这样上面wait_for_property(DAEMON_PROP_NAME, desired_status, 10);也才能够正常pass[luther.gliethttp].
    wait_for_property(result_prop_name, NULL, 15);//等待dhcp.eth0.result=非空
=============================================================================================================
system/extra/dhcpcd-4.0.0-beta9/dhcpcd.c
dhcpcd
=&gt;main
# define SYSCONFDIR        &quot;/system/etc/dhcpcd&quot;
#define PACKAGE            &quot;dhcpcd&quot;
# define CONFIG            SYSCONFDIR &quot;/&quot; PACKAGE &quot;.conf&quot;
# define LIBEXECDIR        &quot;/system/etc/dhcpcd&quot;
# define SCRIPT            LIBEXECDIR &quot;/&quot; PACKAGE &quot;-run-hooks&quot;
=&gt;strlcpy(options-&gt;script,  SCRIPT,  sizeof(options-&gt;script));//默认的options-&gt;script=&quot;/system/etc/dhcpcd /dhcpcd-run-hooks&quot;
=&gt;f = fopen(cf ? cf : CONFIG, &quot;r&quot;);//如果没有指定.conf文件,那么使用默认.conf文件
=&gt;parse_config_line//解析&quot;/system/etc/dhcpcd/dhcpcd.conf&quot;默认配置文件
=&gt;parse_option
=&gt;如果在&quot;/system/etc/dhcpcd/dhcpcd.conf&quot;有&quot;script&quot;这个节
=&gt;那么执行strlcpy(options-&gt;script, oarg, sizeof(options-&gt;script));直接拷贝
/*
{&quot;script&quot;, required_argument, NULL, 'c'},
{&quot;option&quot;, required_argument, NULL, 'o'},
&quot;/system/etc/dhcpcd/dhcpcd.conf&quot;中的部分内容如下：
...
option domain_name_servers, domain_name, domain_search, host_name
...
*/
=&gt;dhcp_run
=&gt;handle_dhcp_packet
=&gt;handle_dhcp
=&gt;bind_dhcp
  reason = &quot;TIMEOUT&quot;;reason = &quot;BOUND&quot;;reason = &quot;REBIND&quot;;reason = &quot;RENEW&quot;;
system/extra/dhcpcd-4.0.0-beta9/configure.c
=&gt; configure(iface, reason, state-&gt;new, state-&gt;old, &amp;state-&gt;lease, options, 1);
//如果dhcp超时或者dhcp成功,都会调用exec_script来执行脚本,
//执行setprop dhcp.${interface}.result &quot;failed&quot;或者
//执行setprop dhcp.${interface}.result &quot;ok&quot;
=&gt;exec_script(options, iface-&gt;name, reason, NULL, old);
=&gt;然后configure_env通过环境变量将reason传递到脚本中
int exec_script(const struct options *options, const char *iface, const char *reason,
     const struct dhcp_message *dhcpn, const struct dhcp_message *dhcpo)
=&gt;pid = fork();
=&gt;if(pid == 0)execve(options-&gt;script, argv, env);//子进程执行脚本,默认&quot;/system/etc/dhcpcd/dhcpcd-run-hooks&quot;
//dhcpcd-run-hooks脚本会根据level值,决定是否执行system/etc/dhcpcd/dhcpcd-hook/*目录下的相应文件
//我们的系统在该system/etc/dhcpcd/dhcpcd-hook/*目录下有如下3个文件
//95-configured
//20-dns.conf
//01-test
=&gt;父进程返回while (waitpid(pid, &amp;status, 0) == -1)等待子进程脚本执行完成
system/extra/dhcpcd-4.0.0-beta9/dhcpcd-hooks/20-dns.conf
system/extra/dhcpcd-4.0.0-beta9/dhcpcd-hooks/95-configured
    ...
    setprop dhcp.${interface}.ipaddress &quot;${new_ip_address}&quot;
    setprop dhcp.${interface}.result &quot;ok&quot;//设置属性为ok
    setprop dhcp.${interface}.result &quot;failed&quot;
    ...
=============================================================================================================
inet_init、tcp_prot
sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size);
=&gt;inetsw_array[]
=&gt;inet_stream_ops
=&gt;tcp_sendmsg
=============================================================================================================
wpa_cli.c
=&gt;main
=&gt;wpa_cli_interactive
=&gt;wpa_cli_recv_pending(monitor_conn, 0, 0);//阻塞等待wpa_supplicant发送数据过来
=&gt;如果action_monitor为true,那么将执行一些简单加工操作,否则将直接将wpa_supplicant发过来的数据打印到console上
分享到：     • 
</rich_text></node><node name="suspend" prog_lang="custom-colors" readonly="False" tags="" unique_id="35"><rich_text>
</rich_text></node><node name="suspend" prog_lang="custom-colors" readonly="False" tags="" unique_id="34"><rich_text>
</rich_text></node><node name="wifi driver" prog_lang="custom-colors" readonly="False" tags="" unique_id="28"><rich_text>
</rich_text></node><node name="wpa_supplicant" prog_lang="custom-colors" readonly="False" tags="" unique_id="29"><rich_text>
</rich_text></node></node><node name="Android流量统计" prog_lang="custom-colors" readonly="False" tags="" unique_id="118"><rich_text>    对于Android流量统计来说在2.2版中加入了TrafficStats类可以轻松获取，其实本身TrafficStats类也是读取 Linux提供的文件对象系统类型的文本进行解析。android.net.TrafficStats类中，提供了多种静态方法，可以直接调用获取，返回类型均为long型，如果返回等于-1代表 UNSUPPORTED 当前设备不支持统计。
    static long  getMobileRxBytes()  //获取通过Mobile连接收到的字节总数，这里提示大家不包含WiFi
    static long  getMobileRxPackets()  //获取Mobile连接收到的数据包总数
    static long  getMobileTxBytes()  //Mobile发送的总字节数
    static long  getMobileTxPackets()  //Mobile发送的总数据包数
    static long  getTotalRxBytes()  //获取总的接受字节数，包含Mobile和WiFi等
    static long  getTotalRxPackets()  //总的接受数据包数，包含Mobile和WiFi等
    static long  getTotalTxBytes()  //总的发送字节数，包含Mobile和WiFi等
    static long  getTotalTxPackets()  //发送的总数据包数，包含Mobile和WiFi等
    static long  getUidRxBytes(int uid)  //获取某个网络UID的接受字节数
    static long  getUidTxBytes(int uid) //获取某个网络UID的发送字节数
    
    其实本身TrafficStats类也是读取Linux提供的文件对象系统类型的文本进行解析。android.net.TrafficStats类中，提供了多种静态方法，可以直接调用获取，
    返回类型均为 long型，如果返回等于-1代表 UNSUPPORTED 当前设备不支持统计
    
</rich_text><rich_text scale="h3">   </rich_text><rich_text scale="h3" weight="heavy">frameworks/base/core/java/android/net/TrafficStats.java:</rich_text><rich_text>
    private static INetworkStatsService sStatsService;

    private synchronized static INetworkStatsService getStatsService() {
        if (sStatsService == null) {
            sStatsService = INetworkStatsService.Stub.asInterface(
                    ServiceManager.getService(Context.NETWORK_STATS_SERVICE));
        }
        return sStatsService;
    }
    
     /**
     * Return set of any ifaces associated with mobile networks since boot.
     * Interfaces are never removed from this list, so counters should always be
     * monotonic.
     */
    private static String[] getMobileIfaces() {
        try {
            return getStatsService().getMobileIfaces();
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Return number of packets transmitted across mobile networks since device
     * boot. Counts packets across all mobile network interfaces, and always
     * increases monotonically since device boot. Statistics are measured at the
     * network layer, so they include both TCP and UDP usage.
     * &lt;p&gt;
     * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
     * return {@link #UNSUPPORTED} on devices where statistics aren't available.
     */
    public static long getMobileTxPackets() {
        long total = 0;
        for (String iface : getMobileIfaces()) {
            total += getTxPackets(iface);
        }
        return total;
    }

    /**
     * Return number of packets received across mobile networks since device
     * boot. Counts packets across all mobile network interfaces, and always
     * increases monotonically since device boot. Statistics are measured at the
     * network layer, so they include both TCP and UDP usage.
     * &lt;p&gt;
     * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
     * return {@link #UNSUPPORTED} on devices where statistics aren't available.
     */
    public static long getMobileRxPackets() {
        long total = 0;
        for (String iface : getMobileIfaces()) {
            total += getRxPackets(iface);
        }
        return total;
    }

    /**
     * Return number of bytes transmitted across mobile networks since device
     * boot. Counts packets across all mobile network interfaces, and always
     * increases monotonically since device boot. Statistics are measured at the
     * network layer, so they include both TCP and UDP usage.
     * &lt;p&gt;
     * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
     * return {@link #UNSUPPORTED} on devices where statistics aren't available.
     */
    public static long getMobileTxBytes() {
        long total = 0;
        for (String iface : getMobileIfaces()) {
            total += getTxBytes(iface);
        }
        return total;
    }

    /**
     * Return number of bytes received across mobile networks since device boot.
     * Counts packets across all mobile network interfaces, and always increases
     * monotonically since device boot. Statistics are measured at the network
     * layer, so they include both TCP and UDP usage.
     * &lt;p&gt;
     * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
     * return {@link #UNSUPPORTED} on devices where statistics aren't available.
     */
    public static long getMobileRxBytes() {
        long total = 0;
        for (String iface : getMobileIfaces()) {
            total += getRxBytes(iface);
        }
        return total;
    }

    /** {@hide} */
    public static long getMobileTcpRxPackets() {
        long total = 0;
        for (String iface : getMobileIfaces()) {
            final long stat = nativeGetIfaceStat(iface, TYPE_TCP_RX_PACKETS);
            if (stat != UNSUPPORTED) {
                total += stat;
            }
        }
        return total;
    }

    /** {@hide} */
    public static long getMobileTcpTxPackets() {
        long total = 0;
        for (String iface : getMobileIfaces()) {
            final long stat = nativeGetIfaceStat(iface, TYPE_TCP_TX_PACKETS);
            if (stat != UNSUPPORTED) {
                total += stat;
            }
        }
        return total;
    }
    /** {@hide} */
    public static long getTxPackets(String iface) {
        return nativeGetIfaceStat(iface, TYPE_TX_PACKETS);
    }

    /** {@hide} */
    public static long getRxPackets(String iface) {
        return nativeGetIfaceStat(iface, TYPE_RX_PACKETS);
    }

    /** {@hide} */
    public static long getTxBytes(String iface) {
        return nativeGetIfaceStat(iface, TYPE_TX_BYTES);
    }

    /** {@hide} */
    public static long getRxBytes(String iface) {
        return nativeGetIfaceStat(iface, TYPE_RX_BYTES);
    }
        
</rich_text><rich_text scale="h3">   </rich_text><rich_text scale="h3" weight="heavy">frameworks/base/services/java/com/android/server/net/NetworkStatsService.java</rich_text><rich_text>
    @Override
    public String[] getMobileIfaces() {
        return mMobileIfaces;
    }

    当网络连接出现变化，就通过广播或消息来调用下面的函数
    private void updateIfaces() {
        synchronized (mStatsLock) {
            mWakeLock.acquire();
            try {
                updateIfacesLocked();
            } finally {
                mWakeLock.release();
            }
        }
    }    
    /**
     * Inspect all current {@link NetworkState} to derive mapping from {@code
     * iface} to {@link NetworkStatsHistory}. When multiple {@link NetworkInfo}
     * are active on a single {@code iface}, they are combined under a single
     * {@link NetworkIdentitySet}.
     */
    private void updateIfacesLocked() {
        if (!mSystemReady) return;
        if (LOGV) Slog.v(TAG, &quot;updateIfacesLocked()&quot;);

        // take one last stats snapshot before updating iface mapping. this
        // isn't perfect, since the kernel may already be counting traffic from
        // the updated network.

        // poll, but only persist network stats to keep codepath fast. UID stats
        // will be persisted during next alarm poll event.
        performPollLocked(FLAG_PERSIST_NETWORK);

        final NetworkState[] states;
        final LinkProperties activeLink;
        try {
            states = mConnManager.getAllNetworkState();
            activeLink = mConnManager.getActiveLinkProperties();
        } catch (RemoteException e) {
            // ignored; service lives in system_server
            return;
        }

        mActiveIface = activeLink != null ? activeLink.getInterfaceName() : null;

        // rebuild active interfaces based on connected networks
        mActiveIfaces.clear();

        for (NetworkState state : states) {
            if (state.networkInfo.isConnected()) {
                // collect networks under their parent interfaces
                final String iface = state.linkProperties.getInterfaceName();

                NetworkIdentitySet ident = mActiveIfaces.get(iface);
                if (ident == null) {
                    ident = new NetworkIdentitySet();
                    mActiveIfaces.put(iface, ident);
                }

                ident.add(NetworkIdentity.buildNetworkIdentity(mContext, state));

                // remember any ifaces associated with mobile networks
                if (isNetworkTypeMobile(state.networkInfo.getType()) &amp;&amp; iface != null) {
                    if (!contains(mMobileIfaces, iface)) {
                        mMobileIfaces = appendElement(String.class, mMobileIfaces, iface);
                    }
                }
            }
        }
    }
    

    </rich_text><rich_text scale="h3" weight="heavy">frameworks/base/core/jni/android_net_TrafficStats.cpp:    </rich_text><rich_text>
    static const char* QTAGUID_IFACE_STATS = &quot;/proc/net/xt_qtaguid/iface_stat_fmt&quot;;
    static const char* QTAGUID_UID_STATS = &quot;/proc/net/xt_qtaguid/stats&quot;;

    // NOTE: keep these in sync with TrafficStats.java
    static const uint64_t UNKNOWN = -1;

    enum StatsType {
        RX_BYTES = 0,
        RX_PACKETS = 1,
        TX_BYTES = 2,
        TX_PACKETS = 3,
        TCP_RX_PACKETS = 4,
        TCP_TX_PACKETS = 5
    };

    struct Stats {
        uint64_t rxBytes;
        uint64_t rxPackets;
        uint64_t txBytes;
        uint64_t txPackets;
        uint64_t tcpRxPackets;
        uint64_t tcpTxPackets;
    };

    static uint64_t getStatsType(struct Stats* stats, StatsType type) {
        switch (type) {
            case RX_BYTES:
                return stats-&gt;rxBytes;
            case RX_PACKETS:
                return stats-&gt;rxPackets;
            case TX_BYTES:
                return stats-&gt;txBytes;
            case TX_PACKETS:
                return stats-&gt;txPackets;
            case TCP_RX_PACKETS:
                return stats-&gt;tcpRxPackets;
            case TCP_TX_PACKETS:
                return stats-&gt;tcpTxPackets;
            default:
                return UNKNOWN;
        }
    }

    static int parseIfaceStats(const char* iface, struct Stats* stats) {
        FILE *fp = fopen(QTAGUID_IFACE_STATS, &quot;r&quot;);
        if (fp == NULL) {
            return -1;
        }

        char buffer[384];
        char cur_iface[32];
        bool foundTcp = false;
        uint64_t rxBytes, rxPackets, txBytes, txPackets, tcpRxPackets, tcpTxPackets;

        while (fgets(buffer, sizeof(buffer), fp) != NULL) {
            int matched = sscanf(buffer, &quot;%31s %llu %llu %llu %llu &quot;
                    &quot;%*u %llu %*u %*u %*u %*u &quot;
                    &quot;%*u %llu %*u %*u %*u %*u&quot;, cur_iface, &amp;rxBytes,
                    &amp;rxPackets, &amp;txBytes, &amp;txPackets, &amp;tcpRxPackets, &amp;tcpTxPackets);
            if (matched &gt;= 5) {
                if (matched == 7) {
                    foundTcp = true;
                }
                if (!iface || !strcmp(iface, cur_iface)) {
                    stats-&gt;rxBytes += rxBytes;
                    stats-&gt;rxPackets += rxPackets;
                    stats-&gt;txBytes += txBytes;
                    stats-&gt;txPackets += txPackets;
                    if (matched == 7) {
                        stats-&gt;tcpRxPackets += tcpRxPackets;
                        stats-&gt;tcpTxPackets += tcpTxPackets;
                    }
                }
            }
        }

        if (!foundTcp) {
            stats-&gt;tcpRxPackets = UNKNOWN;
            stats-&gt;tcpTxPackets = UNKNOWN;
        }

        if (fclose(fp) != 0) {
            return -1;
        }
        return 0;
    }

    static int parseUidStats(const uint32_t uid, struct Stats* stats) {
        FILE *fp = fopen(QTAGUID_UID_STATS, &quot;r&quot;);
        if (fp == NULL) {
            return -1;
        }

        char buffer[384];
        char iface[32];
        uint32_t idx, cur_uid, set;
        uint64_t tag, rxBytes, rxPackets, txBytes, txPackets;

        while (fgets(buffer, sizeof(buffer), fp) != NULL) {
            if (sscanf(buffer, &quot;%d %31s 0x%llx %u %u %llu %llu %llu %llu&quot;, &amp;idx,
                    iface, &amp;tag, &amp;cur_uid, &amp;set, &amp;rxBytes, &amp;rxPackets, &amp;txBytes,
                    &amp;txPackets) == 9) {
                if (uid == cur_uid &amp;&amp; tag == 0L) {
                    stats-&gt;rxBytes += rxBytes;
                    stats-&gt;rxPackets += rxPackets;
                    stats-&gt;txBytes += txBytes;
                    stats-&gt;txPackets += txPackets;
                }
            }
        }

        if (fclose(fp) != 0) {
            return -1;
        }
        return 0;
    }

    static jlong getTotalStat(JNIEnv* env, jclass clazz, jint type) {
        struct Stats stats;
        memset(&amp;stats, 0, sizeof(Stats));
        if (parseIfaceStats(NULL, &amp;stats) == 0) {
            return getStatsType(&amp;stats, (StatsType) type);
        } else {
            return UNKNOWN;
        }
    }

    static jlong getIfaceStat(JNIEnv* env, jclass clazz, jstring iface, jint type) {
        ScopedUtfChars iface8(env, iface);
        if (iface8.c_str() == NULL) {
            return UNKNOWN;
        }

        struct Stats stats;
        memset(&amp;stats, 0, sizeof(Stats));
        if (parseIfaceStats(iface8.c_str(), &amp;stats) == 0) {
            return getStatsType(&amp;stats, (StatsType) type);
        } else {
            return UNKNOWN;
        }
    }
    
</rich_text><rich_text scale="h3" weight="heavy">kernel的功能实现:    </rich_text><rich_text>
    1. netfilter是linux默认的网络防火墙，他可以匹配各种规则来统计，拦截数据收发。
    2. qtaguid 是android为了做流量统计而加入kernel的，标准kernel(3.4)中没有合入
        qtaguid的原理是：
            上层提供应用的uid，kernel根据uid建立tag，并存入红黑树中，统计前台和后台的收发数据，并保存在相应的
            文件(/proc/net/xt_qtaguid/stats)等待上层读取。
        在$android_source/system/core/libcutils中有qtaguid的接口，与kernel的 qtaguid对接
        之所以在libcutils中加入，是为了让所以的java和c程序都能使用到这个接口。
        再往上是java层的networkManagementSocketTagger和networkstatservice，他们 负责监听并更新uid列 表
        并将应用的uid传入kernel
    3.另外发现netd的带宽控制功能也是用iptables操作，需要打开netfilter的相关配置
    </rich_text></node></cherrytree>