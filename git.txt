1. 服务器安装ssh,git, python-setuptools
sudo apt-get install openssh-server openssh-client
sudo apt-get install git-core
sudo apt-get install python-setuptools

2. 服务器安装gitosis
cd /tmp
#git clone git://eagain.net/gitosis.git
git clone https://github.com/res0nat0r/gitosis.git
git clone git://github.com/res0nat0r/gitosis.git
cd gitosis
sudo python setup.py install
 
3. 客户端
sudo apt-get install openssh-server openssh-client
sudo apt-get install git-core
ssh-keygen -t rsa
scp .ssh/id_rsa.pub cjcheng@192.168.1.108:/tmp
 
4. 服务器配置 git服务器
创建git服务器管理用户
sudo useradd -m git
sudo passwd git
vim /etc/passwd //将git /bin/sh改为/bin/bash
sudo mkdir /home/git/repositories
sudo chown git:git /home/git/repositories
sudo chmod 755 /home/git/repositories
git config --global user.name "cjcheng"
git config --global user.email "caijicheng2006@163.com"
 
5. 服务器初始化gitosis
sudo -H -u git gitosis-init < /tmp/id_rsa.pub
sudo chmod 755 /home/git/repositories/gitosis-admin.git/hooks/post-update
 
6. 客户端clone gitosis
git clone git@192.168.1.108:gitosis-admin.git

7. 客户端创建test.git
sudo vim gitosis-admin/gitosis.conf
[group test]
members = cjcheng@cjcheng
writable = test
提交
git add .
git commit -m "add test project"
git push origin master
mkdir test
cd test
git init
echo "hello" > readme
git add .
git commit -m "readme"
git remote add origin git@192.168.1.108:test.git
git push origin master
 
8.另一个客户端git clone
su cjc
ssh-keygen -t rsa
exit
cp ~/.ssh/id_rsa.pub ~/gitosis-admin/keydir/cjc@cjcheng.pub
sudo sudo vim gitosis-admin/gitosis.conf
[group test]
members = cjcheng@cjcheng cjc@cjcheng
writable = test
git add .
git commit -m "add user cjc"
git push origin master
git clone git@192.168.1.108:test.git

================================================================================
常用的git命令
================================================================================
git diff --cached  比较暂存区内的文件与上次提交的差别。
git commit -a -m 'added new benchmarks' 一步部到位提交文件，只针对已经有跟踪的文件，对于新文件，还是要用add
git rm --cached readme.txt只是从暂存区内删除，用于已经添加了，但是文件不需要删除，
git rm log/\*.log  删除所有log/ 目录下扩展名为.log 的文件
git rm \*~      递归删除当前目录及其子目录中所有~ 结尾的文件。
git log --stat 显示简要的增改行数统计 列出每次更改 文件的列表
git log --pretty=oneline   列出版本 号与提交的备注
git log --pretty=format:"%h - %an, %ar : %s"可以定制要显示的记录格式
git log --pretty=format:"%h %s" --graph  查看出分支的情况
git commit --amend    当提交后还想提交文件，此时先add剩下的文件，然后执行此句，进行重新提交
git reset HEAD filename  取消已经放在暂缓区内的东西

有时候发现某个关键文件被改动了，需要跟踪查看对这个关键文件的所有commit的记录，以便理解其中的修改原因和过程
git log -p “file name”
git blame “file name" 可以显示这个文件的每一行的最后提交commit，方便定位commit

分支
git checkout -b iss53  新建分支，并转到分支
git merge hotfix  合并分支
git branch -d hotfix 合并完后删除某个分支
git branch  查看所有分支
git branch --merge 查看哪些分支已被并入当前分支
git branch --no-merged  还没有合并的分支
合并前也必须保证主分支也已经提交了合并时必须回到主分支，然后进行合并; 在进行分支切换时必须保证文件已经提交完如果合并有冲突则进行，解决并提交;

git切换到另外一个branch (本例是develop分支):
git checkout develop

git删除一个branch(本例是myfeature):
git branch -d myfeature

git删除一个远程branch:
git push origin :branchName

git push 新的branch到远程:
git push -u origin mynewfeature

设置git email:
git config --global user.email "me@example.com"

如果你有未提交的commit，与master同步:
git pull --rebase origin master


如果你要把你的分支合并到主干分支，从主干（master）分支上发送：
git branch -d new_feature

假如修改已经合并了，它只会删除分支。假如分支没有合并，你会得到一个错误信息。删除一个未合并的分支（通常你不想保留的修改），你需要发送一样的命令附带一个大写D。意思是“强制删除分支，无论如何我不想要它了。”：
git branch -D new_feature

简单地用提交的ID做签出（checkout）（我通常只用到ID开头的9个字符）
git checkout 085bb3bcb

你也可以签出到一个新的分支，像这样：
git checkout -b my_previous_version 085bb3bcb

						 checkout -- files		  	reset -- files
						  <------------			   	 <-----------
		Working Directory ------------> Stage(index) -----------> History 
							add	files				    commit 

git add files 
	把当前文件放入暂存区域。
git commit 
	给暂存区域生成快照并提交。
git reset -- files 
	用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。
git checkout -- files 
	把文件从暂存区域复制到工作目录，用来丢弃本地修改。

git show-branch
	可以使我们看到版本库中每个分支的世系发展状态，并且可以看到每次提交的内容是否已进入每个分支
	
================================================================================
git revert 是撤销某次操作，此次操作之前的commit都会被保留, 并要作为最新一次commit
git reset 是撤销某次提交，但是此次之后的修改都会被退回到暂存区
================================================================================
具体一个例子，假设有三个commit， git st:
commit3: add test3.c
commit2: add test2.c
commit1: add test1.c
当执行git revert HEAD~1时， commit2被撤销了
git log可以看到：
commit1：add test1.c
commit3：add test3.c
git status 没有任何变化
如果换做执行git reset --soft(默认) HEAD~1后，运行git log
commit2: add test2.c
commit1: add test1.c
运行git status， 则test3.c处于暂存区，准备提交。
如果换做执行git reset --hard HEAD~1后，
显示：HEAD is now at commit2，运行git log
commit2: add test2.c
commit1: add test1.c
运行git st， 没有任何变化

 ----------------------------------------------------------------------------------------------

另外，说一下git revert ，git reset --hard和 --soft的区别

git reset --mixed id ，是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。
git reset --soft id. 实际上，是git reset --mixed id 后，又做了一次git add
git reset --hard id.是将git的HEAD变了，文件也变了。

git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。
比如git revert HEAD~1  ,那么会撤销倒数第二次的提交结果。而倒数第一次的提交记录，仍然在。
如果git reset --hard HEAD~1,那么，commit退回到倒数第三次的状态中。
总体来讲，还是git revert 好啊，雁过留声嘛。

其实，通过git reset --soft id的方法，可以将原来多次的git提交记录合并为一个。

git reset是指将当前head的内容重置，不会留log信息。

    git reset HEAD filename  从暂存区中移除文件
    git reset --hard HEAD~3  会将最新的3次提交全部重置，就像没有提交过一样。
    git reset --hard commit (38679ed709fd0a3767b79b93d0fba5bb8dd235f8) 回退到 38679ed709fd0a3767b79b93d0fba5bb8dd235f8 版本

----------------------------------------------------------------------------------------------

根据--soft --mixed --hard，会对working tree和index和HEAD进行重置:

    git reset --mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
    git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可
    git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容

git reset --soft :取消了commit  

git reset --mixed（默认） :取消了commit ，取消了add

git reset --hard :取消了commit ，取消了add，取消源文件修改 

================================================================================
Git fetch和git pull的区别
================================================================================
Git中从远程的分支获取最新的版本到本地有这样2个命令：
1. git fetch：相当于是从远程获取最新版本到本地，不会自动merge
	git fetch origin master
	git log -p master..origin/master
	git merge origin/master

    以上命令的含义：
   首先从远程的origin的master主分支下载最新的版本到origin/master分支上
   然后比较本地的master分支和origin/master分支的差别
   最后进行合并
   上述过程其实可以用以下更清晰的方式来进行：

	git fetch origin master:tmp
	git diff tmp 
	git merge tmp

    从远程获取最新的版本到本地的test分支上
   之后再进行比较合并
   
2. git pull：相当于是从远程获取最新版本并merge到本地

	git pull origin master

	上述命令其实相当于git fetch 和 git merge
	在实际使用中，git fetch更安全一些
	因为在merge前，我们可以查看更新情况，然后再决定是否合并
	结束

================================================================================
Git的Patch功能
================================================================================
1.git diff生成的标准patch

我们可以首先用git diff制作一个patch。本文示例的工作目录里最初有一个文件a，内容是“This is the file a.”，放置在master分支中。为了修改代码，我们一般的做法是建立一个新分支：

sweetdum@sweetdum-ASUS:~/GitEx$ git branch Fix
sweetdum@sweetdum-ASUS:~/GitEx$ git checkout Fix
Switched to branch 'Fix'

接下来我们在a文件里面追加一行，然后执行git diff。
sweetdum@sweetdum-ASUS:~/GitEx$ echo 'Fix!!!'>>a
sweetdum@sweetdum-ASUS:~/GitEx$ git diff
diff --git a/a b/a
index 4add65f..0d295ac 100644
--- a/a
+++ b/a
@@ -1 +1,2 @@
This is the file a.
+Fix!!!

我们看到了Git diff的输出，这是一个非常典型的Patch式diff。这样我们可以直接把这个输出变为一个Patch：
sweetdum@sweetdum-ASUS:~/GitEx$ git commit -a -m "Fix"
[Fix b88c46b] Fix
1 files changed, 1 insertions(+), 0 deletions(-)
sweetdum@sweetdum-ASUS:~/GitEx$ git diff master > patch
sweetdum@sweetdum-ASUS:~/GitEx$ git checkout master
Switched to branch 'master'

我们现在有一个patch文件，并且签出了master，接下来我们可以使用git apply来应用这个patch。当然了，实际应用中，我们不会这样在一个分支建patch，到另一个分支去应用，因为只有merge一下就好了。我们现 在权当没有这个Fix分支。一般情况下，为了保护master，我们会建立一个专门处理新交来的patch的分支：

sweetdum@sweetdum-ASUS:~/GitEx$ git branch PATCH
sweetdum@sweetdum-ASUS:~/GitEx$ git checkout PATCH
Switched to branch 'PATCH'
sweetdum@sweetdum-ASUS:~/GitEx$ git apply patch
sweetdum@sweetdum-ASUS:~/GitEx$ git commit -a -m "Patch Apply"
[PATCH 9740af8] Patch Apply
1 files changed, 1 insertions(+), 0 deletions(-)

看，现在我们在PATCH分支中应用了这个补丁，我们可以把PATCH分支和Fix比对一下，结果肯定是什么也没有，说明PATCH分支和Fix分支完全一样。patch应用成功。即使有多个文件git diff 也能生成一个patch。

2.git format-patch生成的git专用补丁。

我们同样用上面那个例子的工作目录，这次，我们在Fix分支中的a添加了新行之后，用git format-patch生成一个patch。
sweetdum@sweetdum-ASUS:~/GitEx$ git checkout Fix
Switched to branch 'Fix'
sweetdum@sweetdum-ASUS:~/GitEx$ echo 'Fix!!!'>>a
sweetdum@sweetdum-ASUS:~/GitEx$ git commit -a -m "Fix1"
[Fix 6991743] Fix1
1 files changed, 1 insertions(+), 0 deletions(-)
sweetdum@sweetdum-ASUS:~/GitEx$ git format-patch -M master
0001-Fix1.patch

git format-patch的-M选项表示这个patch要和那个分支比对。现在它生成了一个patch文件，我们看看那是什么：

sweetdum@sweetdum-ASUS:~/GitEx$ cat 0001-Fix1.patch
From 6991743354857c9a6909a253e859e886165b0d90 Mon Sep 17 00:00:00 2001
From: Sweetdumplings <linmx0130@163.com>
Date: Mon, 29 Aug 2011 14:06:12 +0800
Subject: [PATCH] Fix1

---
a |    1 +
1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/a b/a
index 4add65f..0d295ac 100644
--- a/a
+++ b/a
@@ -1 +1,2 @@
This is the file a.
+Fix!!!
--
1.7.4.1

看，这次多了好多东西，不仅有diff的信息，还有提交者，时间等等，仔细一看你会发现，这是个E-mail的文件，你可以直接发送它！这种patch，我们要用git am来应用。

sweetdum@sweetdum-ASUS:~/GitEx$ git checkout master
Switched to branch 'master'
sweetdum@sweetdum-ASUS:~/GitEx$ git branch PATCH
sweetdum@sweetdum-ASUS:~/GitEx$ git checkout PATCH
sweetdum@sweetdum-ASUS:~/GitEx$ git am 0001-Fix1.patch
Applying: Fix1
sweetdum@sweetdum-ASUS:~/GitEx$ git commit -a -m "PATCH apply"

在提交了补丁之后，我们可以再看看目前文件a的情况：

sweetdum@sweetdum-ASUS:~/GitEx$ cat a
This is the file a.
Fix!!!

果然，多了一个Fix!!!

不过要注意的是，如果master与Fix分支中间有多次提交，它会针对每次提交生成一个patch。

3.两种patch的比较：

    兼容性：很明显，git diff生成的Patch兼容性强。如果你在修改的代码的官方版本库不是Git管理的版本库，
		那么你必须使用git diff生成的patch才能让你的代码被项目的维护人接受。
		
    除错功能：对于git diff生成的patch，你可以用git apply --check 查看补丁是否能够干净顺利地应用到当前分支中；
		如果git format-patch 生成的补丁不能打到当前分支，git am会给出提示，并协助你完成打补丁工作，
		你也可以使用git am -3进行三方合并，详细的做法可以参考git手册或者《Progit》。从这一点上看，两者除错功能都很强。
		
    版本库信息：由于git format-patch生成的补丁中含有这个补丁开发者的名字，因此在应用补丁时，这个名字会被记录进版本库，
		显然，这样做是恰当的。因此，目前使用Git的开源社区往往建议大家使用format-patch生成补丁。

================================================================================
git源码发布
================================================================================
1.tar.gz包
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz

	其中:
	  git describe master
	  获得最近生成的tag

2.zip包
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip

