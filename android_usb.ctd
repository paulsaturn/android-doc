<?xml version="1.0" ?><cherrytree><node name="usb状态相关处理 " prog_lang="custom-colors" readonly="False" tags="" unique_id="67"><rich_text>关于Usb的检测，相关联的和sd card一起研究。
在状态栏如何进行显示Sd卡插入状态的Notification和Usb在Debugging时的Notification的？
先来看Sd卡的Notification显示：
在StatusBarPolicy.java的StatusBarPolicy类的构造函数中，有这样关于Sd卡的状态监听机制：
 // storage
 mStorageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);
 mStorageManager.registerListener(
               new com.android.systemui.usb.StorageNotification(context));

 注：
    在android4.2中StatusBarPolicy.java这个文件已经没有，而调用上面的程序可以放到start()函数. 
    
 进入StorageManager.java的registerListener去查看是怎样监听的：
  public void registerListener(StorageEventListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (mListeners) {
            mListeners.add(new ListenerDelegate(listener));
        }
    }    

可见所谓注册过程就是将监听类添加到监听的List表中，那么，在这个表中如何监听的？
查看ListenerDelegate：
ListenerDelegate(StorageEventListener listener) {
            mStorageEventListener = listener;
            mHandler = new Handler(mTgtLooper) {
                @Override
                public void handleMessage(Message msg) {
                    StorageEvent e = (StorageEvent) msg.obj;
                    if (msg.what == StorageEvent.EVENT_UMS_CONNECTION_CHANGED) {
                        UmsConnectionChangedStorageEvent ev = (UmsConnectionChangedStorageEvent) e;
                        mStorageEventListener.onUsbMassStorageConnectionChanged(ev.available);
                    } else if (msg.what == StorageEvent.EVENT_STORAGE_STATE_CHANGED) {
                        StorageStateChangedStorageEvent ev = (StorageStateChangedStorageEvent) e;
                        mStorageEventListener.onStorageStateChanged(ev.path, ev.oldState, ev.newState);
                    } else {
                        Log.e(TAG, &quot;Unsupported event &quot; + msg.what);
                    }
                }
            };
        }
实际上就是开启一个无线循环的Handler等待消息的传送过来，到这一步自然就会想到是谁发送消息？
先插卡StorageManager类的构造函数：
  public StorageManager(Looper tgtLooper) throws RemoteException {
        mMountService = IMountService.Stub.asInterface(ServiceManager.getService(&quot;mount&quot;));
        if (mMountService == null) {
            Log.e(TAG, &quot;Unable to connect to mount service! - is it running yet?&quot;);
            return;
        }
        mTgtLooper = tgtLooper;
        mBinderListener = new MountServiceBinderListener();
        mMountService.registerListener(mBinderListener);
    }
在开启StorageManager的时候实际上就开启一个MountService，将MountServiceBinderListener注册为监听类：
它的作用是这样的：
private class MountServiceBinderListener extends IMountServiceListener.Stub {
        public void onUsbMassStorageConnectionChanged(boolean available) {
            final int size = mListeners.size();
            for (int i = 0; i &lt; size; i++) {
                mListeners.get(i).sendShareAvailabilityChanged(available);
            }
        }
        public void onStorageStateChanged(String path, String oldState, String newState) {
            final int size = mListeners.size();
            for (int i = 0; i &lt; size; i++) {
                mListeners.get(i).sendStorageStateChanged(path, oldState, newState);
            }
        }
    }
也就是实际发送StorageEvent.EVENT_UMS_CONNECTION_CHANGED或者另外的消息：
EVENT_STORAGE_STATE_CHANGED。
那么这个监听类如何知道状态变化的？
在MountService.java中，
  public void registerListener(IMountServiceListener listener) {
        synchronized (mListeners) {
            MountServiceBinderListener bl = new MountServiceBinderListener(listener);
            try {
                listener.asBinder().linkToDeath(bl, 0);
                mListeners.add(bl);
            } catch (RemoteException rex) {
                Slog.e(TAG, &quot;Failed to link to listener death&quot;);
            }
        }
    }
在MountService中有一个可供守护进程调用的函数：
public boolean onEvent(int code, String raw, String[] cooked)，它在有关状态发生变化时会调用相关函数，
    比如VolumeStateChange时，notifyVolumeStateChange()，
    而在 notifyVolumeStateChange()中会更新：updatePublicVolumeState（），在这里我们看到实际就是通过Environment中相关函数判断Sd卡状态，
在这里：
synchronized (mListeners) {
            for (int i = mListeners.size() -1; i &gt;= 0; i--) {
                MountServiceBinderListener bl = mListeners.get(i);
                try {
                    bl.mListener.onStorageStateChanged(path, oldState, state);
                } catch (RemoteException rex) {
                    Slog.e(TAG, &quot;Listener dead&quot;);
                    mListeners.remove(i);
                } catch (Exception ex) {
                    Slog.e(TAG, &quot;Listener failed&quot;, ex);
                }
            }
        }
也就是守护进程检测sd卡状态变化时调用StorageManager中的mBinderListener对象的onStorageStateChanged，此时在StorageManager中，
就依次向需要知道Storage状态变化的目标发送消息，刚才我们说的StorageManager开启的无限循环的Handler收到消息就开始了相应处理。
Usb插入时有无Debugging时的Notification是怎样产生的？

在UsbService.java中，private final UEventObserver mUEventObserver = new UEventObserver() 函数是用来监听底层Usb状态的机制。
当&quot;usb_connected&quot;、&quot;usb_configuration&quot;、或者其它的Usb状态(如Adb)发生变化时会发送一个Message，然后根据message，usbService做出相应的处理。
在source code中，adb变化时，有Note如下：
Note: we do not broadcast a change when a function is enabled or disabled. We just record the state change for the next broadcast.
这就使得android系统不能及时更新Usb Notification状态。
在handler处理函数处：
case MSG_FUNCTION_ENABLED:
case MSG_FUNCTION_DISABLED:
    functionEnabledLocked((String)msg.obj, msg.what == MSG_FUNCTION_ENABLED);
    break;
    
如Note所说，仅仅是保存起来，并未进行更新。
要想即刻做出更新，应做出如下操作：
case MSG_FUNCTION_ENABLED:
case MSG_FUNCTION_DISABLED:
    functionEnabledLocked((String)msg.obj, msg.what == MSG_FUNCTION_ENABLED);
    // send a sticky broadcast containing current USB state
    Intent intent = new Intent(UsbManager.ACTION_USB_STATE);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    intent.putExtra(UsbManager.USB_CONNECTED, mConnected != 0);
    intent.putExtra(UsbManager.USB_CONFIGURATION, mConfiguration);
    addEnabledFunctionsLocked(intent);
    mContext.sendStickyBroadcast(intent);
    break;
这就完成了及时更新策略。


在allwinners方案中UMS的检测是放在MountService.java：
    private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            boolean available = (intent.getBooleanExtra(UsbManager.USB_CONNECTED, false) &amp;&amp;
                    intent.getBooleanExtra(UsbManager.USB_FUNCTION_MASS_STORAGE, false));
		    mUsbConnent =  available;
			//usb status changing,check volume to change usb notification
            int size = mVolumes.size();
		    for(int i=0; i&lt;size; i++) {
			  StorageVolume volume = mVolumes.get(i);
			  String path  = volume.getPath();
			  String state = mVolumeStates.get(path);
              if(volume.allowMassStorage()){
                 notifyShareAvailabilityChange(available);
			  }
			  if(!mUsbConnent&amp;&amp;volume.allowMassStorage()){
			  	  //usb is disconnented,we should disabled UMS
				 setUsbMassStorageEnabled(false);
			  }
			}
            //boolean available = (intent.getBooleanExtra(UsbManager.USB_CONNECTED, false) &amp;&amp;
            //        intent.getBooleanExtra(UsbManager.USB_FUNCTION_MASS_STORAGE, false));
            //notifyShareAvailabilityChange(available);
        }
    };
    
    class UnmountCallBack {
        final String path;
        final boolean force;
        final boolean removeEncryption;
        int retries;

        UnmountCallBack(String path, boolean force, boolean removeEncryption) {
            retries = 0;
            this.path = path;
            this.force = force;
            this.removeEncryption = removeEncryption;
        }

        void handleFinished() {
            if (DEBUG_UNMOUNT) Slog.i(TAG, &quot;Unmounting &quot; + path);
            doUnmountVolume(path, true, removeEncryption);
        }
    }

    class UmsEnableCallBack extends UnmountCallBack {
        final String method;

        UmsEnableCallBack(String path, String method, boolean force) {
            super(path, force, false);
            this.method = method;
        }

        @Override
        void handleFinished() {
            //调用UnmountCallBack::handleFinished(), umount volume
            super.handleFinished();         
            //调用int VolumeManager::shareVolume(const char *label, const char *method)
            //      -&gt; part=v-&gt;shareVol(mlun);          返回多少个分区可以share
            //调用int Volume::shareVol(int lun)
            //     -&gt; 把&quot;/dev/block/vold/%d:%d&quot;写到&quot;/sys/class/android_usb/android0/f_mass_storage/lun/file&quot;
            //     -&gt; handleVolumeShared()  
            //        -&gt; DirectVolume::handleVolumeShared() 
            //        -&gt; setState(Volume::State_Shared);
            //           -&gt;  mVm-&gt;getBroadcaster()-&gt;sendBroadcast(ResponseCode::VolumeStateChange, msg, false);
            doShareUnshareVolume(path, method, true); 
        }
    }

    class ShutdownCallBack extends UnmountCallBack {
        IMountShutdownObserver observer;
        ShutdownCallBack(String path, IMountShutdownObserver observer) {
            super(path, true, false);
            this.observer = observer;
        }

        @Override
        void handleFinished() {
            int ret = doUnmountVolume(path, true, removeEncryption);
            if (observer != null) {
                try {
                    observer.onShutDownComplete(ret);
                } catch (RemoteException e) {
                    Slog.w(TAG, &quot;RemoteException when shutting down&quot;);
                }
            }
        }
    }
    

在android4.2.2中UsbService.java调用了UsbHostManager, UsbDeviceManager
UsbHostManager:
    -&gt;
    android_server_UsbHostManager_monitorUsbHostBus
        -&gt;
        struct usb_host_context*  context = usb_host_init()
        usb_host_run(context, usb_device_added, usb_device_removed, NULL, (void *)thiz);
        (调用system/core/libusbhost/usbhost.c里的usb_host_*()函数)
    
UsbDeviceManager:
    /*
     * Listens for uevent messages from the kernel to monitor the USB state
     */
    private final UEventObserver mUEventObserver = new UEventObserver() {
        @Override
        public void onUEvent(UEventObserver.UEvent event) {
            if (DEBUG) Slog.v(TAG, &quot;USB UEVENT: &quot; + event.toString());

            String state = event.get(&quot;USB_STATE&quot;);
            String accessory = event.get(&quot;ACCESSORY&quot;);
            if (state != null) {
                mHandler.updateState(state);
            } else if (&quot;START&quot;.equals(accessory)) {
                if (DEBUG) Slog.d(TAG, &quot;got accessory start&quot;);
                startAccessoryMode();
            }
        }
    };
    
    public UsbHandler(Looper looper) {
            ...
            mUEventObserver.startObserving(USB_STATE_MATCH);
            mUEventObserver.startObserving(ACCESSORY_START_MATCH);
            ...
    }
                
    public UsbDeviceManager(Context context) {
        ...
        // create a thread for our Handler
        HandlerThread thread = new HandlerThread(&quot;UsbDeviceManager&quot;,
                Process.THREAD_PRIORITY_BACKGROUND);
        thread.start();
        mHandler = new UsbHandler(thread.getLooper());
        
        if (nativeIsStartRequested()) {
            if (DEBUG) Slog.d(TAG, &quot;accessory attached at boot&quot;);
            startAccessoryMode();
        }

        if (&quot;1&quot;.equals(SystemProperties.get(&quot;ro.adb.secure&quot;))) {
            mDebuggingManager = new UsbDebuggingManager(context);
        }            
    }
</rich_text></node></cherrytree>