<?xml version="1.0" ?><cherrytree><node name="杂项记录" prog_lang="custom-colors" readonly="False" tags="" unique_id="1"><rich_text>1.FTDI232下载器-系统板
TXD-RXD
RXD-TXD
VCC-VCC
GND-GND
DTR-DTR

2.DS3231
1). 连线
　　SCL→A5
　　SDA→A4
　　VCC→5V
　　GND→GND

2).测试
#include &lt;DS3231.h&gt;
#include &lt;Wire.h&gt;

DS3231 Clock;
bool Century=false;
bool h12;
bool PM;
byte ADay, AHour, AMinute, ASecond, ABits;
bool ADy, A12h, Apm;

byte year, month, date, DoW, hour, minute, second;

void setup() {
	// 启动I2C(IIC)接口
	Wire.begin();
	//以下部分是初始化时间，每次板子通电之后都会初始化成这个时间，只是测试用，以后可以删除。
	Clock.setSecond(40);//Set the second
	Clock.setMinute(20);//Set the minute 设置分钟
	Clock.setHour(10);  //Set the hour 设置小时
	Clock.setDoW(2);    //Set the day of the week 设置星期几
	Clock.setDate(23);  //Set the date of the month 设置月份
	Clock.setMonth(9);  //Set the month of the year 设置一年中的月份
	Clock.setYear(14);  //Set the year (Last two digits of the year) 设置年份(在今年的最后两位数——比如2013年最后的13)
	// Start the serial interface
	Serial.begin(115200);
}

void ReadDS3231()
{
	int temperature;
	Clock.getTime(year, month, date, DoW, hour, minute, second);
	// second=Clock.getSecond();
	// minute=Clock.getMinute();
	// hour=Clock.getHour(h12, PM);
	// date=Clock.getDate();
	// month=Clock.getMonth(Century);
	// year=Clock.getYear();

	temperature=Clock.getTemperature();

	Serial.print(&quot;20&quot;);
	Serial.print(year,DEC);
	Serial.print('-');
	Serial.print(month,DEC);
	Serial.print('-');
	Serial.print(date,DEC);
	Serial.print(' ');
	Serial.print(hour,DEC);
	Serial.print(':');
	Serial.print(minute,DEC);
	Serial.print(':');
	Serial.print(second,DEC);
	Serial.print('\n');
	Serial.print(&quot;T=&quot;);  //这里是显示温度
	Serial.print(temperature);
	Serial.print('\n');
}

void loop()
{
	ReadDS3231();
	delay(1000);  //间隔1000ms(1000ms=1秒)循环一次。
}

3.AT24C32

4.测试328 or 168的VCC电压(5000相当于5v)
long readVcc() {
  long result;
  // Read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA,ADSC));
  result = ADCL;
  result |= ADCH&lt;&lt;8;
  result = 1126400L / result; // Back-calculate AVcc in mV
  return result;
}

void setup() {
  Serial.begin(9600);
}

void loop() {
  Serial.println( readVcc(), DEC );
  delay(1000);
}

5.输出PWM
1).analogWrite(pin, val)
int pin = 8; //0~13

void setup()
{
	pinMode(pin, OUTPUT);
}   

void loop()
{
	analogWrite(pin, 128);
	delay(500);
}
上面的例子输出方波周期大概是20ms左右（50Hz）, analogWrite(pin, val)中val是0~255, 对应电压是0~+5V

2).digitalWrite
int pin = 8;  

void setup()
{
	pinMode(pin, OUTPUT);
}

void loop()
{
  digitalWrite(pin, HIGH);
  delayMicroseconds(100);
  digitalWrite(pin, LOW);
  delayMicroseconds(1000 - 100);
}
产生一个PWM=0.1的，周期为1ms的方波（1000Hz）

3).使用PWM寄存器
Timer0, Timer1和Timer2。每个时钟都使用了两个寄存器
Timer0和Timer1共用一个控制器，Timer2和它们是独立的
delay()等函数用到Timer0, 所以最好用Timer2。

6. ATmega328使用internal 8M clock
1).把reset脚上的10k上拉去掉(不上拉)
2).把breadboard目录放到sketchbook/hardware下，在IDE上选用ATmega328 on a breadboard (8 MHz internal clock)

7. arduino ISP下载bootloader
1).连接
arduino控制板		atmega328p
D10(SS)				pin-1 (RESET) 
D11(MOSI)			pin-17 (MOSI)
D12(MISO)			pin-18 (MISO)
D13(SCK)			pin-19 (SCK)

arduino的reset需要100欧的上拉才能下载

2).烧录bootloader
(1).首先打开arduino IDE，在File的Examples里面，选择ArduinoISP，把这个程序编译好，下载进入arduino控制板中
(2).在IDE中选择下载的bootloader的板子为Atmega8的NG（根据实际情况选用）
(3).然后选择Programmer，选择arduino as ISP
(4).选择Burn Bootloader
就看着灯闪呀闪的下载了，下载完成后会提示Done burning bootloader

3).下载程序(FTDI232)
FTDI232			atmega328p
DTR				pin-1 (RESET)	(上拉10k)
RX				pin-3 (TX)
TX				pin-2 (RX)
VCC				VCC
GND				GND

下载完成之后，自动运行；
需要串口调试的时候，注意要把DTR断开，因为打开串口时，DTR一直为低。

8. nrf24l01模块
1). SPI连接
nrf24l01模块				arduino			atmega328p
1 GND (白色框)			GND				GND
2 VCC (3.3v)			3.3V			3.3V
3 CE					D9				pin-15
4 CSN					D10				pin-16 (SS)
5 SCK					D13				pin-19 (SCK)
6 MOSI					D11				pin-17 (MOSI)
7 MISO					D12				pin-18 (MISO)
8 IRQ					D2 (INT0)		pin-4

</rich_text></node><node name="rf" prog_lang="custom-colors" readonly="False" tags="" unique_id="2"><rich_text></rich_text><node name="nRF24L01" prog_lang="custom-colors" readonly="False" tags="" unique_id="4"><rich_text>/* Memory Map */ </rich_text><rich_text foreground="#00000000ffff">//寄存器地址</rich_text><rich_text>
#define CONFIG      0x00
#define EN_AA       0x01
#define EN_RXADDR   0x02
#define SETUP_AW    0x03
#define SETUP_RETR  0x04
#define RF_CH       0x05
#define RF_SETUP    0x06
#define STATUS      0x07
#define OBSERVE_TX  0x08
#define CD          0x09
#define RX_ADDR_P0  0x0A
#define RX_ADDR_P1  0x0B
#define RX_ADDR_P2  0x0C
#define RX_ADDR_P3  0x0D
#define RX_ADDR_P4  0x0E
#define RX_ADDR_P5  0x0F
#define TX_ADDR     0x10
#define RX_PW_P0    0x11
#define RX_PW_P1    0x12
#define RX_PW_P2    0x13
#define RX_PW_P3    0x14
#define RX_PW_P4    0x15
#define RX_PW_P5    0x16
#define FIFO_STATUS 0x17
#define DYNPD	    0x1C        </rich_text><rich_text foreground="#00000000ffff">//通道的动态载荷长度使能</rich_text><rich_text>
#define FEATURE	    0x1D

/* Bit Mnemonics */ </rich_text><rich_text foreground="#00000000ffff">//寄存器位</rich_text><rich_text>
#define MASK_RX_DR  6
#define MASK_TX_DS  5
#define MASK_MAX_RT 4
#define EN_CRC      3
#define CRCO        2
#define PWR_UP      1
#define PRIM_RX     0
#define ENAA_P5     5
#define ENAA_P4     4
#define ENAA_P3     3
#define ENAA_P2     2
#define ENAA_P1     1
#define ENAA_P0     0
#define ERX_P5      5
#define ERX_P4      4
#define ERX_P3      3
#define ERX_P2      2
#define ERX_P1      1
#define ERX_P0      0
#define AW          0
#define ARD         4           </rich_text><rich_text foreground="#00000000ffff">//(4-7)Auto Retransmit Delay, (n+1)*250us</rich_text><rich_text>
#define ARC         0           </rich_text><rich_text foreground="#00000000ffff">//(0-3)Auto Retransmit Count, 0-15</rich_text><rich_text>
#define PLL_LOCK    4
#define RF_DR       3         </rich_text><rich_text foreground="#00000000ffff">//Data rate, 如果是24L01+, 用下面P mode的值</rich_text><rich_text>
#define RF_PWR      1       </rich_text><rich_text foreground="#00000000ffff">//Output power in TX mode</rich_text><rich_text>
#define LNA_HCURR   0        
#define RX_DR       6           </rich_text><rich_text foreground="#00000000ffff">//1, 接收到有效数据；写1清除</rich_text><rich_text>
#define TX_DS       5           </rich_text><rich_text foreground="#00000000ffff">//1, 发送成功(自动应答模式，只有接收到应答信号才置1)；写1清除</rich_text><rich_text>
#define MAX_RT      4         </rich_text><rich_text foreground="#00000000ffff">//1, 多次重发中断；写1清除  </rich_text><rich_text>
#define RX_P_NO     1        </rich_text><rich_text foreground="#00000000ffff">//(1-3)Data pipe number for the payload available forreading from RX_FIFO</rich_text><rich_text>
#define TX_FULL     0         </rich_text><rich_text foreground="#00000000ffff">//TX FIFO寄存器满标志</rich_text><rich_text>  
#define PLOS_CNT    4       </rich_text><rich_text foreground="#00000000ffff">//(4-7)数据包丢失计数器, 写RF_CH计数器会复位; 满15个会重启。</rich_text><rich_text> 
#define ARC_CNT     0        </rich_text><rich_text foreground="#00000000ffff">//(0-3)重发计数器， 发送数据会复位。</rich_text><rich_text>
#define TX_REUSE    6
#define FIFO_FULL   5
#define TX_EMPTY    4
#define RX_FULL     1
#define RX_EMPTY    0
#define DPL_P5	    5
#define DPL_P4	    4
#define DPL_P3	    3
#define DPL_P2	    2
#define DPL_P1	    1
#define DPL_P0	    0
#define EN_DPL	    2           </rich_text><rich_text foreground="#00000000ffff">//Enables Dynamic Payload Length</rich_text><rich_text>
#define EN_ACK_PAY  1       </rich_text><rich_text foreground="#00000000ffff">//Enables Payload with ACK</rich_text><rich_text>
#define EN_DYN_ACK  0      </rich_text><rich_text foreground="#00000000ffff">//Enables the W_TX_PAYLOAD_NOACK command</rich_text><rich_text>

/* Instruction Mnemonics */ </rich_text><rich_text foreground="#00000000ffff">//SPI操作指令</rich_text><rich_text>
#define R_REGISTER    0x00
#define W_REGISTER    0x20
#define REGISTER_MASK 0x1F
#define ACTIVATE      0x50
#define R_RX_PL_WID   0x60      </rich_text><rich_text foreground="#00000000ffff">//读RX-PAYLOAD的长度，这个长度是下一次使用R_RX_PAYLOAD命令从RX FIFO中读取数据的长度</rich_text><rich_text>
#define R_RX_PAYLOAD  0x61      
#define W_TX_PAYLOAD  0xA0
#define W_ACK_PAYLOAD 0xA8   </rich_text><rich_text foreground="#00000000ffff">//接收模式下使用，写在ack包里的负载数据, 绑定到通道PPP上(PPP有效为0-5), 最多有3个ack payload, 最长32个字节。</rich_text><rich_text>
#define FLUSH_TX      0xE1          </rich_text><rich_text foreground="#00000000ffff">//清除TX FIFO寄存器, 应用于发射模式下</rich_text><rich_text>
#define FLUSH_RX      0xE2          </rich_text><rich_text foreground="#00000000ffff">//清除RX FIFO寄存器, 应用于接收模式下</rich_text><rich_text>
#define REUSE_TX_PL   0xE3       </rich_text><rich_text foreground="#00000000ffff">//重新使用上一包有效数据</rich_text><rich_text>   
#define NOP           0xFF

/* Non-P omissions */
#define LNA_HCURR   0

/* P model memory Map */
#define RPD         0x09                               </rich_text><rich_text foreground="#00000000ffff">//Received Power Detector</rich_text><rich_text>
#define W_TX_PAYLOAD_NO_ACK  0xB0   </rich_text><rich_text foreground="#00000000ffff">//在发送模式下使用，禁止指定的数据包的自动应答功能</rich_text><rich_text>

/* P model bit Mnemonics */
#define RF_DR_LOW   5
#define RF_DR_HIGH  3
#define RF_PWR_LOW  1
#define RF_PWR_HIGH 2


</rich_text><rich_text scale="h3" weight="heavy">1. ShockBurst Mode</rich_text><rich_text>
    </rich_text><rich_text foreground="#ffff00000000">nRF24L01+</rich_text><rich_text>芯片有2种通信模式：ShockBurst Mode（突发模式）和Enhanced ShockBurst Mode（增强式突发模式）。当在ShockBurst Mode下芯片自己完成需要高速处理的RF协议，发送数据时只需要将数据放入发送数据缓冲区，芯片会自动产生PREAMBLE和CRC数据并将这些数据和地址信息、发送数据缓冲区的数据等组成一个数据包发送出去，这个数据包的组成为“1字节字头 + 3～5字节地址 + 9bit标志位 + 1～2字节CRC”。配置为接收数据的nRF24L01+接收到数据包后由硬件解析地址数据和数据信息，当接收到有效的数据信息后在IRQ引脚产生中断通知外部处理器读走数。
    Enhanced ShockBurst Mode比前一种多了数据传输的握手信号可以保证数据传输的可靠性。当配置为Enhanced ShockBurst Mode，nRF24L01+发送数据后会自动切换到接收模式以接收返回的握手信号，当收到确认信号后IRQ引脚产生数据发送完成中断，如果没有握手信号返回表示发送失败，芯片会自动重新发送。如果重新发送的次数超过在ARC_CNT寄存器里面设定的值则会在IRQ引脚产生中断。MCU查询STATUS寄存器的值即可知道是发送完成中断还是重发次数超限中断。
    推荐将nRF24L01+配置工作于Enhanced ShockBurst?模式，这种工作模式下，系统的程序编制会更加简单，并且稳定性也会更高。

    </rich_text><rich_text foreground="#ffff00000000">RX_DR, TX_DS, MAX_RT会产生中断(默认没有屏蔽中断, 寄存器CONFIG中设置)。</rich_text><rich_text>
</rich_text></node><node name="Mirf" prog_lang="custom-colors" readonly="False" tags="" unique_id="3"><rich_text>	1).
	class MirfSpiDriver {
		public:
			virtual uint8_t transfer(uint8_t data);

			virtual void begin();
			virtual void end();
	};
	class MirfSpiDriver是SPI驱动的基类		
	class MirfHardwareSpiDriver是继承于class MirfSpiDriver, 调用SPI.h的函数实现上面的类方法。
	
	2). 
	class Nrf24l中有成员变量MirfSpiDriver *spi， 需要在初始化的时候指定MirfSpiDriver类实例。
	如下：
	#include &lt;SPI.h&gt;
	#include &lt;Mirf.h&gt;
	#include &lt;nRF24L01.h&gt;
	#include &lt;MirfHardwareSpiDriver.h&gt;
	
	...
	void setup() {
		...
		Mirf.cePin = 9;			//CE
		Mirf.csnPin = 10;		//CSN
		Mirf.spi = &amp;MirfHardwareSpi;
		Mirf.init();
		...
		Mirf.config();			//设置channel, lenght of payload; Start receiver
		...
	}	
	
	nrf24l01的P0作为发送的auto ack接收, RX_ADDR_P0和TX_ADDR的地址是一样的。RX_ADDR_P1是接收通道。
	P0和P1的自动应答默认打开(寄存器EN_AA), auto ack的地址是接收通道地址一样。
	因为成员变量都是public的，所以应用都可以直接修改它的值。</rich_text></node><node name="RF24" prog_lang="custom-colors" readonly="False" tags="" unique_id="5"><rich_text>1. void openWritingPipe(const uint8_t *address);
    设置发送地址
    设置RX_ADDR_P0, TX_ADDR, RX_PW_P0
    P0作为发送的auto ack接收, RX_ADDR_P0和TX_ADDR的地址是一样的

2. void openReadingPipe(uint8_t number, const uint8_t *address);
    设置接收地址和使能EN_RXADDR相应的位
    pipes 0-1  5个字节
    pipes 2-5, 只写LSB一个字节， 其他的字节和P1一样。

</rich_text><rich_text foreground="#ffff00000000">    pgm_read_byte从flash读取变量值, 如：
        const prog_uchar FlashConst = 3; //定义uchar型的常量n定义在flash里(flash常量)
        unsigned char RamVar; //定义无符号整型变量(Ram变量)
        RamVar = pgm_read_byte(&amp;FlashConst); //读取flash常量到ram变量
        
</rich_text><rich_text>3. 自动识别nRF24L01和nRF24L01+
    在begin函数中：
  if( setDataRate( RF24_250KBPS ) )
  {
    p_variant = true ;      </rich_text><rich_text foreground="#00000000ffff">//nRF24L01+</rich_text><rich_text>
  }

4. void startListening(void);    
    开始侦听pipe的数据接收
    调用这个函数之前要先调用openReadingPipe函数， 并不能在这个模式下调用write()函数。

5.  bool write( const void* buf, uint8_t len, const bool multicast );
    这个函数会先调用：
    void RF24::startFastWrite( const void* buf, uint8_t len, const bool multicast){ //TMRh20

	    //write_payload( buf,len);
	    write_payload( buf, len,multicast ? W_TX_PAYLOAD_NO_ACK : W_TX_PAYLOAD ) ;
	    ce(HIGH);

    }
    </rich_text><rich_text foreground="#ffff00000000">multicast为真，那么发送no ack的payload; 否则发送普通的payload。</rich_text><rich_text>
    然后等到成功或失败才退出函数。
    
6. void read( void* buf, uint8_t len );
    调用read_payload( buf, len ); 最后调用
    write_register(STATUS,_BV(RX_DR) | _BV(MAX_RT) | _BV(TX_DS) );
    清除中断标志    

7. bool txStandBy(uint32_t timeout);
    等待发送完成，并CE拉低，进入standby I 模式。
    如果成功， 返回true; 失败或超时(&gt;timeout), 则返回false。

</rich_text></node><node name="RF24Network" prog_lang="custom-colors" readonly="False" tags="" unique_id="6"><rich_text>1. void begin(uint8_t _channel, uint16_t _node_address );
    _channel : RF channel
    _node_address : node address
        </rich_text><rich_text foreground="#ffff00000000">00表示master, 01 - 05是00(master)的子node, 015-055是05的子node，每一层占3bit(用8进制表示，0开头), 以此来定义node address。</rich_text><rich_text>

2. bool RF24Network::write(RF24NetworkHeader&amp; header,const void* message, size_t len)
    payload等于RF24NetworkHeader加messag, 
    里面调用RF24的write()函数(调用之前要stopListening, 完成之后调用startListening)
    放送的目标在RF24NetworkHeader的to_node定义，如果to_node是相连的node(父或子)，那么直接发送；如果不是，先发到父node来
    路由数据。</rich_text></node></node></cherrytree>