<?xml version="1.0" ?><cherrytree><node name="Android内核解读" prog_lang="custom-colors" readonly="False" tags="" unique_id="128"><rich_text>
</rich_text><node name="Android系统的开机启动过程 " prog_lang="custom-colors" readonly="False" tags="" unique_id="130"><rich_text scale="h2">前言</rich_text><rich_text>
    当长按手机的power键，Android手机就会开机，那么Android系统的开机启动过程到底是怎么样的呢，本文将要 介绍这一过程。简单来说，Android系统的开机启动过程大致是这样的：首先linux系统会启动一个叫做zygote（可以称为受精卵、母体）的 linux程序，这个程序实际上就是android系统的内核，zygote启动的时候会建立socket服务端并加载大量的类和资源。接着zygote 会孵化第一个dalvik进程SystemServer，在SystemServer中会创建一个socket客户端，后续 AMS（ActivityManagerService）会通过此客户端和zygote通信，zygote再根据请求孵化出新的dalvik进程即启动一 个新的apk同时把新进程的socket连接关闭。SystemServer初始化完毕后会启动一个位于桟顶的activity，由于系统刚开机，所以 task桟顶没有activity，于是接着它会发送一个隐式的intent（category：CATEGORY_HOME），也就是launcher 了，即Android系统的桌面程序，launcher启动以后，我们就可以通过桌面启动各种应用了，可以发现，launcher可以有多个，第三方应用只要加入launcher所需要的intent-filter即可。下面一一分析各个流程。（注：本文分析基于Android4.3源码）

</rich_text><rich_text scale="h2">zygote的启动过程</rich_text><rich_text>
zygote是一个linux程序，其对应的可执行文件位于/system/bin/app_process，它在/init.rc中定义，如下
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
    onrestart restart netd
    
    可以发现，zygote创建了一个流式套接字（即采用TCP协议），并监听660端口，并且当zygote重启的时候需要对唤醒电源并重启Media、 netd服务。下面看zygote的源码，
其路径为frameworks\base\cmds\app_process\app_main.cpp中：
1. int main(int argc, char* const argv[])  
2. {  
3. #ifdef __arm__  
4.     /* 
5.      * b/7188322 - Temporarily revert to the compat memory layout 
6.      * to avoid breaking third party apps. 
7.      * 
8.      * THIS WILL GO AWAY IN A FUTURE ANDROID RELEASE. 
9.      * 
10.      * http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=7dbaa466 
11.      * changes the kernel mapping from bottom up to top-down. 
12.      * This breaks some programs which improperly embed 
13.      * an out of date copy of Android's linker. 
14.      */  
15.     char value[PROPERTY_VALUE_MAX];  
16.     property_get(&quot;ro.kernel.qemu&quot;, value, &quot;&quot;);  
17.     bool is_qemu = (strcmp(value, &quot;1&quot;) == 0);  
18.     if ((getenv(&quot;NO_ADDR_COMPAT_LAYOUT_FIXUP&quot;) == NULL) &amp;&amp; !is_qemu) {  
19.         int current = personality(0xFFFFFFFF);  
20.         if ((current &amp; ADDR_COMPAT_LAYOUT) == 0) {  
21.             personality(current | ADDR_COMPAT_LAYOUT);  
22.             setenv(&quot;NO_ADDR_COMPAT_LAYOUT_FIXUP&quot;, &quot;1&quot;, 1);  
23.             execv(&quot;/system/bin/app_process&quot;, argv);  
24.             return -1;  
25.         }  
26.     }  
27.     unsetenv(&quot;NO_ADDR_COMPAT_LAYOUT_FIXUP&quot;);  
28. #endif  
29.   
30.     // These are global variables in ProcessState.cpp  
31.     mArgC = argc;  
32.     mArgV = argv;  
33.   
34.     mArgLen = 0;  
35.     for (int i=0; i&lt;argc; i++) {  
36.         mArgLen += strlen(argv[i]) + 1;  
37.     }  
38.     mArgLen--;  
39.     //注意，这里持有了一个AppRuntime对象，其继承自AndroidRuntime  
40.     AppRuntime runtime;  
41.     const char* argv0 = argv[0];  
42.   
43.     // Process command line arguments  
44.     // ignore argv[0]  
45.     argc--;  
46.     argv++;  
47.   
48.     // Everything up to '--' or first non '-' arg goes to the vm  
49.   
50.     int i = runtime.addVmArguments(argc, argv);  
51.   
52.     // Parse runtime arguments.  Stop at first unrecognized option.  
53.     bool zygote = false;  
54.     bool startSystemServer = false;  
55.     bool application = false;  
56.     const char* parentDir = NULL;  
57.     const char* niceName = NULL;  
58.     const char* className = NULL;  
59.     //这里是解析init.rc中定义的zygote的启动参数  
60.     while (i &lt; argc) {  
61.         const char* arg = argv[i++];  
62.         if (!parentDir) {  
63.             parentDir = arg;  
64.         } else if (strcmp(arg, &quot;--zygote&quot;) == 0) {  
65.             zygote = true;  
66.             niceName = &quot;zygote&quot;;  
67.         } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) {  
68.             startSystemServer = true;  
69.         } else if (strcmp(arg, &quot;--application&quot;) == 0) {  
70.             application = true;  
71.         } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) {  
72.             niceName = arg + 12;  
73.         } else {  
74.             className = arg;  
75.             break;  
76.         }  
77.     }  
78.   
79.     if (niceName &amp;&amp; *niceName) {  
80.         setArgv0(argv0, niceName);  
81.         set_process_name(niceName);  
82.     }  
83.   
84.     runtime.mParentDir = parentDir;  
85.   
86.     if (zygote) {  
87.         //从init.rc中的定义可以看出，zygote为true，startSystemServer也为true  
88.         //最终这里会调用ZygoteInit的main方法  
89.         runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,  
90.                 startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);  
91.     } else if (className) {  
92.         // Remainder of args get passed to startup class main()  
93.         runtime.mClassName = className;  
94.         runtime.mArgC = argc - i;  
95.         runtime.mArgV = argv + i;  
96.         runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;,  
97.                 application ? &quot;application&quot; : &quot;tool&quot;);  
98.     } else {  
99.         fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);  
100.         app_usage();  
101.         LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);  
102.         return 10;  
103.     }  
104. }  
    说 明：这句代码 runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, startSystemServer ?  &quot;start-system-server&quot; :  &quot;&quot;)
    在AndroidRuntime中实现，其最终会调用ZygoteInit的main方法，请看 env-&gt;CallStaticVoidMethod(startClass, startMeth,  strArray);这里的startClass就是com.android.internal.os.ZygoteInit，而startMeth就是main，所以，我们直接看ZygoteInit的main方法，代码路径为：frameworks\base\core\java\com\android\internal\os\ZygoteInit.java：
106. public static void main(String argv[]) {  
107.     try {  
108.         // Start profiling the zygote initialization.  
109.         SamplingProfilerIntegration.start();  
110.         //这里注册流式socket，以便于fork新的dalvik进程  
111.         registerZygoteSocket();  
112.         EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,  
113.             SystemClock.uptimeMillis());  
114.         //这里预先加载一些类和资源  
115.         preload();  
116.         EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,  
117.             SystemClock.uptimeMillis());  
118.   
119.         // Finish profiling the zygote initialization.  
120.         SamplingProfilerIntegration.writeZygoteSnapshot();  
121.   
122.         // Do an initial gc to clean up after startup  
123.         gc();  
124.   
125.         // Disable tracing so that forked processes do not inherit stale tracing tags from  
126.         // Zygote.  
127.         Trace.setTracingEnabled(false);  
128.   
129.         // If requested, start system server directly from Zygote  
130.         if (argv.length != 2) {  
131.             throw new RuntimeException(argv[0] + USAGE_STRING);  
132.         }  
133.   
134.         if (argv[1].equals(&quot;start-system-server&quot;)) {  
135.             //启动SystemServer，zygote通过SystemServer和上层服务进行交互  
136.             startSystemServer();  
137.         } else if (!argv[1].equals(&quot;&quot;)) {  
138.             throw new RuntimeException(argv[0] + USAGE_STRING);  
139.         }  
140.   
141.         Log.i(TAG, &quot;Accepting command socket connections&quot;);  
142.         //通过Select方式监听端口，即异步读取消息，死循环，没有消息则一直阻塞在那里  
143.         runSelectLoop();  
144.   
145.         closeServerSocket();  
146.     } catch (MethodAndArgsCaller caller) {  
147.         caller.run();  
148.     } catch (RuntimeException ex) {  
149.         Log.e(TAG, &quot;Zygote died with exception&quot;, ex);  
150.         closeServerSocket();  
151.         throw ex;  
152.     }  
153. }  
    下面看一下runSelectLoop方法，看看它是如何fork产生一个新的进程的：
1. /** 
2.  * Runs the zygote process's select loop. Accepts new connections as 
3.  * they happen, and reads commands from connections one spawn-request's 
4.  * worth at a time. 
5.  * 
6.  * @throws MethodAndArgsCaller in a child process when a main() should 
7.  * be executed. 
8.  */  
9. private static void runSelectLoop() throws MethodAndArgsCaller {  
10.     ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();  
11.     ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();  
12.     FileDescriptor[] fdArray = new FileDescriptor[4];  
13.   
14.     fds.add(sServerSocket.getFileDescriptor());  
15.     peers.add(null);  
16.   
17.     int loopCount = GC_LOOP_COUNT;  
18.     //死循环，没有消息则一直阻塞在这里  
19.     while (true) {  
20.         int index;  
21.   
22.         /* 
23.          * Call gc() before we block in select(). 
24.          * It's work that has to be done anyway, and it's better 
25.          * to avoid making every child do it.  It will also 
26.          * madvise() any free memory as a side-effect. 
27.          * 
28.          * Don't call it every time, because walking the entire 
29.          * heap is a lot of overhead to free a few hundred bytes. 
30.          */  
31.         if (loopCount &lt;= 0) {  
32.             gc();  
33.             loopCount = GC_LOOP_COUNT;  
34.         } else {  
35.             loopCount--;  
36.         }  
37.   
38.   
39.         try {  
40.             fdArray = fds.toArray(fdArray);  
41.             //通过select()函数来读取新的socket消息，其返回值有&lt;0、0、&gt;0三种  
42.             //分别代表：发生异常、继续读取新消息、首先处理当前消息  
43.             index = selectReadable(fdArray);  
44.         } catch (IOException ex) {  
45.             throw new RuntimeException(&quot;Error in select()&quot;, ex);  
46.         }  
47.   
48.         if (index &lt; 0) {  
49.             throw new RuntimeException(&quot;Error in select()&quot;);  
50.         } else if (index == 0) {  
51.             //构造一个ZygoteConnection对象，并将其加入到peers列表中  
52.             ZygoteConnection newPeer = acceptCommandPeer();  
53.             peers.add(newPeer);  
54.             fds.add(newPeer.getFileDesciptor());  
55.         } else {  
56.             boolean done;  
57.             //这里处理当前socket消息，ZygoteConnection的runOnce会被调用，一个新的dalvik进程会被创建  
58.             done = peers.get(index).runOnce();  
59.   
60.             if (done) {  
61.                 //处理完了以后删除此socket消息  
62.                 peers.remove(index);  
63.                 fds.remove(index);  
64.             }  
65.         }  
66.     }  
67. }  
    接着，我们还需要看下ZygoteConnection的runOnce方法，看看一个dalvik进程到底是如何产生的，我们知道每个apk都运行在一个 独立的dalvik进程中，所以当启动一个apk的时候，zygote会孵化出一个新的进程，在这个进程中运行此apk。  在 ZygoteConnection中，新进程是通过Zygote的静态方法forkAndSpecialize来产生的：
    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName);
具 体的我们就不用多看了，内部肯定是通过linux系统的fork()函数来产生一个新进程的。当一个新的dalvik进程产生了以后，还需要做一些清场的 工作，由于新进程是由zygote程序fork出来的，所以子进程具有zygote的一份拷贝，我们知道，zygote启动的时候创建了一个socket 服务端，这个服务端只能有一个，由zygote孵化的子进程是不应该有的，所以子进程孵化出来以后，还必须关闭拷贝的socket服务端，这些操作在 handleChildProc方法中完成：
1. private void handleChildProc(Arguments parsedArgs,  
2.         FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)  
3.         throws ZygoteInit.MethodAndArgsCaller {  
4.     //关闭本地和服务端（如果有）的socket  
5.     closeSocket();  
6.     ZygoteInit.closeServerSocket();  
7.   
8.     if (descriptors != null) {  
9.         try {  
10.             ZygoteInit.reopenStdio(descriptors[0],  
11.                     descriptors[1], descriptors[2]);  
12.   
13.             for (FileDescriptor fd: descriptors) {  
14.                 IoUtils.closeQuietly(fd);  
15.             }  
16.             newStderr = System.err;  
17.         } catch (IOException ex) {  
18.             Log.e(TAG, &quot;Error reopening stdio&quot;, ex);  
19.         }  
20.     }  
21.   
22.     if (parsedArgs.niceName != null) {  
23.         Process.setArgV0(parsedArgs.niceName);  
24.     }  
25.   
26.     if (parsedArgs.runtimeInit) {  
27.         if (parsedArgs.invokeWith != null) {  
28.             WrapperInit.execApplication(parsedArgs.invokeWith,  
29.                     parsedArgs.niceName, parsedArgs.targetSdkVersion,  
30.                     pipeFd, parsedArgs.remainingArgs);  
31.         } else {  
32.             RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,  
33.                     parsedArgs.remainingArgs);  
34.         }  
35.     } else {  
36.         String className;  
37.         try {  
38.             className = parsedArgs.remainingArgs[0];  
39.         } catch (ArrayIndexOutOfBoundsException ex) {  
40.             logAndPrintError(newStderr,  
41.                     &quot;Missing required class name argument&quot;, null);  
42.             return;  
43.         }  
44.   
45.         String[] mainArgs = new String[parsedArgs.remainingArgs.length - 1];  
46.         System.arraycopy(parsedArgs.remainingArgs, 1,  
47.                 mainArgs, 0, mainArgs.length);  
48.   
49.         if (parsedArgs.invokeWith != null) {  
50.             WrapperInit.execStandalone(parsedArgs.invokeWith,  
51.                     parsedArgs.classpath, className, mainArgs);  
52.         } else {  
53.             ClassLoader cloader;  
54.             if (parsedArgs.classpath != null) {  
55.                 cloader = new PathClassLoader(parsedArgs.classpath,  
56.                         ClassLoader.getSystemClassLoader());  
57.             } else {  
58.                 cloader = ClassLoader.getSystemClassLoader();  
59.             }  
60.   
61.             try {  
62.                 //这里子进程的main方法被调用，此时，子进程完全从zygote（母体）上脱离出来了  
63.                 ZygoteInit.invokeStaticMain(cloader, className, mainArgs);  
64.             } catch (RuntimeException ex) {  
65.                 logAndPrintError(newStderr, &quot;Error starting.&quot;, ex);  
66.             }  
67.         }  
68.     }  
69. }  

    /**
     * Helper exception class which holds a method and arguments and
     * can call them. This is used as part of a trampoline to get rid of
     * the initial process setup stack frames.
     */
    public static class MethodAndArgsCaller extends Exception
            implements Runnable {
        /** method to call */
        private final Method mMethod;

        /** argument array */
        private final String[] mArgs;

        public MethodAndArgsCaller(Method method, String[] args) {
            mMethod = method;
            mArgs = args;
        }

        public void run() {
            try {
                mMethod.invoke(null, new Object[] { mArgs });
            } catch (IllegalAccessException ex) {
                throw new RuntimeException(ex);
            } catch (InvocationTargetException ex) {
                Throwable cause = ex.getCause();
                if (cause instanceof RuntimeException) {
                    throw (RuntimeException) cause;
                } else if (cause instanceof Error) {
                    throw (Error) cause;
                }
                throw new RuntimeException(ex);
            }
        }
    }

    /**
     * Invokes a static &quot;main(argv[]) method on class &quot;className&quot;.
     * Converts various failing exceptions into RuntimeExceptions, with
     * the assumption that they will then cause the VM instance to exit.
     *
     * @param loader class loader to use
     * @param className Fully-qualified class name
     * @param argv Argument vector for main()
     */
    static void invokeStaticMain(ClassLoader loader,
            String className, String[] argv)
            throws ZygoteInit.MethodAndArgsCaller {
        Class&lt;?&gt; cl;

        try {
            cl = loader.loadClass(className);
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(
                    &quot;Missing class when invoking static main &quot; + className,
                    ex);
        }

        Method m;
        try {
            m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(
                    &quot;Missing static main on &quot; + className, ex);
        } catch (SecurityException ex) {
            throw new RuntimeException(
                    &quot;Problem getting static main on &quot; + className, ex);
        }

        int modifiers = m.getModifiers();
        if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {
            throw new RuntimeException(
                    &quot;Main method is not public and static on &quot; + className);
        }

        /*
         * This throw gets caught in ZygoteInit.main(), which responds
         * by invoking the exception's run() method. This arrangement
         * clears up all the stack frames that were required in setting
         * up the process.
         */
        throw new ZygoteInit.MethodAndArgsCaller(m, argv);
    }
        
    调用invokeStaticMain函数抛出MethodAndArgsCaller异常， 然后在ZygoteInit的main中
146.     } catch (MethodAndArgsCaller caller) {  
147.         caller.run();  
148.     }
    调用
    同时在ZygoteInit中会预先加载一些类和资源，具体代码在preload方法中：
    static void preload() {
        preloadClasses();
        preloadResources();
    }

</rich_text><rich_text scale="h2">SystemServer的创建</rich_text><rich_text>
    SystemServer 作为zygote孵化的第一个dalvik进程，其孵化过程在上面已经进行了描述，但是其和普通进程的启动略有不同，普通进程由 Zygote.forkAndSpecialize来启动，而SystemServer由Zygote.forkSystemServer来启动，其次是 SystemServer内部多创建了一个socket客户端。关于SystemServer内部的本地socket客户端，本文前面已经说过，外围的 Service都是通过SystemServer和zygote交互的，比如要启动一个apk，首先AMS会发起一个新进程的创建请求，在 startProcessLocked方法中会调用Process的start方法，其内部会调用startViaZygote方法，而在 startViaZygote内部会创建一个本地socket和zygote通信，我们要知道，AMS是在SystemServer进程中创建的，所以说 在SystemServer中创建一个本地socket和zygote通信是有道理的。SystemServer的一个很重要的作用是创建各种服务，包括 大家常见的WindowManagerService 、AlarmManagerService、ActivityManagerService等，然 后上层的各种manager通过binder和service进行交互，关于SystemServer创建各种服务的过程以及和binder的交互，请参 考我之前写的一篇博客的其中一节，这里就不重复了：</rich_text><rich_text link="webs http://blog.csdn.net/singwhatiwanna/article/details/18448997#t4">各种Manager和Binder服务的对应关系</rich_text><rich_text>。

</rich_text><rich_text scale="h2">系统桌面的启动</rich_text><rich_text>
 当SystemServer创建各种服务完毕后，其中的一个服务ActivityManagerService由于也创建完成，所以其事件回调方法systemReady会被调用，这个方法很长，注意到在这个方法的倒数第二句是mMainStack.resumeTopActivityLocked(null)，它的意思是将桟顶的activity复位，看它的代码
1. final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {  
2.     // Find the first activity that is not finishing.  
3.     //找到桟顶的activity记录  
4.     ActivityRecord next = topRunningActivityLocked(null);  
5.   
6.     // Remember how we'll process this pause/resume situation, and ensure  
7.     // that the state is reset however we wind up proceeding.  
8.     final boolean userLeaving = mUserLeaving;  
9.     mUserLeaving = false;  
10.     //由于系统刚启动，桟顶肯定没有activity，所以next为null  
11.     if (next == null) {  
12.         // There are no more activities!  Let's just start up the  
13.         // Launcher...  
14.         if (mMainStack) {  
15.             ActivityOptions.abort(options);  
16.             //程序执行到这里，桌面就会被调起来  
17.             return mService.startHomeActivityLocked(mCurrentUser);  
18.         }  
19.     }  
20.     ...此处省略  
21. }  
最后看看桌面是如何被调起来的：
1. boolean startHomeActivityLocked(int userId) {  
2.     if (mHeadless) {  
3.         // Added because none of the other calls to ensureBootCompleted seem to fire  
4.         // when running headless.  
5.         ensureBootCompleted();  
6.         return false;  
7.     }  
8.   
9.     if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL  
10.             &amp;&amp; mTopAction == null) {  
11.         // We are running in factory test mode, but unable to find  
12.         // the factory test app, so just sit around displaying the  
13.         // error message and don't try to start anything.  
14.         return false;  
15.     }  
16.     Intent intent = new Intent(  
17.         mTopAction,  
18.         mTopData != null ? Uri.parse(mTopData) : null);  
19.     intent.setComponent(mTopComponent);  
20.     if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {  
21.         //其实就是为intent加上CATEGORY_HOME这个Category，接着就发送隐式intent来调起所有满足条件的桌面  
22.         //这也是第三方桌面存在的价值  
23.         intent.addCategory(Intent.CATEGORY_HOME);  
24.     }  
25.     ActivityInfo aInfo =  
26.         resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);  
27.     if (aInfo != null) {  
28.         intent.setComponent(new ComponentName(  
29.                 aInfo.applicationInfo.packageName, aInfo.name));  
30.         // Don't do this if the home app is currently being  
31.         // instrumented.  
32.         aInfo = new ActivityInfo(aInfo);  
33.         aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);  
34.         ProcessRecord app = getProcessRecordLocked(aInfo.processName,  
35.                 aInfo.applicationInfo.uid);  
36.         if (app == null || app.instrumentationClass == null) {  
37.             intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);  
38.             //这里启动桌面activity，到此为止，桌面被启动了，我们就可以认为手机开机完成了  
39.             mMainStack.startActivityLocked(null, intent, null, aInfo,  
40.                     null, null, 0, 0, 0, null, 0, null, false, null);  
41.         }  
42.     }  
43.   
44.     return true;  
45. }  
到此为止，桌面已经启动了，也就意味着手机的开机启动过程已经完成，后续我们就可以通过桌面来启动各个应用了，根据本文的介绍，我们已经知道apk启动时dalvik进程的创建过程，关于单个activity的启动过程，请参看我之前写的另一篇文章</rich_text><rich_text link="webs http://blog.csdn.net/singwhatiwanna/article/details/18154335">Android源码分析-Activity的启动过程</rich_text><rich_text>。到此为止，本文结束了，相信大家对Android系统的开机启动过程应该有了一个感性的认识了。
</rich_text></node><node name="应用的安装过程" prog_lang="custom-colors" readonly="False" tags="" unique_id="129"><rich_text scale="h2">前言</rich_text><rich_text>
我 们知道，在android手机上安装一个apk很简单，只要打开apk文件，默认就会弹出安装界面，然后点击确定，经过若干秒后，apk就安装成功了，可 是你知道apk的安装过程是什么吗？你知道android系统在安装一个apk的时候都干了什么吗？在本文中，将一一解答这个问题。
    简单来说，apk的安 装过程分两步：
        第一步，将apk文件复制到程序目录下（/data/app/）；
        第二步，为应用创建数据目录（/data/data/&lt;package  name&gt;/）、提取dex文件到指定目录（/data/dalvik-cache/）、修改系统包管理信息。
        注意，本文的分析基于Android  4.3源码。

</rich_text><rich_text scale="h2">apk的复制过程</rich_text><rich_text>
    apk的安装从PackageManager的installApk方法开始，由于PackageManager所对应的binder服务为 PackageManagerService（PMS），所以，真正的安装过程都在PackageManagerService中完成。 PackageManagerService的installApk方法最终调用了installPackageWithVerificationAndEncryption方法，该方法的核心就是在最后发送了一个INIT_COPY的 消息，这个消息的含义是完成apk的拷贝过程。
1. public void installPackageWithVerificationAndEncryption(Uri packageURI,  
2.         IPackageInstallObserver observer, int flags, String installerPackageName,  
3.         VerificationParams verificationParams, ContainerEncryptionParams encryptionParams) {  
4.     mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES,  
5.             null);  
6.   
7.     final int uid = Binder.getCallingUid();  
8.     if (isUserRestricted(UserHandle.getUserId(uid), UserManager.DISALLOW_INSTALL_APPS)) {  
9.         try {  
10.             observer.packageInstalled(&quot;&quot;, PackageManager.INSTALL_FAILED_USER_RESTRICTED);  
11.         } catch (RemoteException re) {  
12.         }  
13.         return;  
14.     }  
15.   
16.     UserHandle user;  
17.     if ((flags&amp;PackageManager.INSTALL_ALL_USERS) != 0) {  
18.         user = UserHandle.ALL;  
19.     } else {  
20.         user = new UserHandle(UserHandle.getUserId(uid));  
21.     }  
22.   
23.     final int filteredFlags;  
24.   
25.     if (uid == Process.SHELL_UID || uid == 0) {  
26.         if (DEBUG_INSTALL) {  
27.             Slog.v(TAG, &quot;Install from ADB&quot;);  
28.         }  
29.         filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;  
30.     } else {  
31.         filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB;  
32.     }  
33.   
34.     verificationParams.setInstallerUid(uid);  
35.   
36.     final Message msg = mHandler.obtainMessage(INIT_COPY);  
37.     msg.obj = new InstallParams(packageURI, observer, filteredFlags, installerPackageName,  
38.             verificationParams, encryptionParams, user);  
39.     mHandler.sendMessage(msg);  
40. }  
    </rich_text><rich_text foreground="#000000">通过分析代码可以发现，真正实现apk拷贝的方法是InstallParams的handleStartCopy方法，InstallParams中有重试机制，拷贝如果失败的话会重试，最多重试4次。在拷贝之前，还必须做一件事情，那就是绑定media container  service，安装过程中一些状态的检查会用到这个服务，代码如下所示：</rich_text><rich_text>
1. class PackageHandler extends Handler {  
2.     private boolean mBound = false;  
3.     final ArrayList&lt;HandlerParams&gt; mPendingInstalls =  
4.         new ArrayList&lt;HandlerParams&gt;();  
5.   
6.     private boolean connectToService() {  
7.         if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Trying to bind to&quot; +  
8.                 &quot; DefaultContainerService&quot;);  
9.         Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);  
10.         Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);  
11.         if (mContext.bindServiceAsUser(service, mDefContainerConn,  
12.                 Context.BIND_AUTO_CREATE, UserHandle.OWNER)) {  
13.             Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
14.             mBound = true;  
15.             return true;  
16.         }  
17.         Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
18.         return false;  
19.     }  
20.     ...  
21. }  
现在分析一下InstallParams的handleStartCopy方法，这个方法很长，代码就不帖出来了，大家可以自己去看看，这里主要分析下它的工作流程：
1. 检查安装位置标记位是否有冲突，如果有冲突，则安装失败，这里的有冲突是指“一个apk同时要求被安装到内部存储和sd卡”
2. 调用MCS服务的getMinimalPackageInfo方法来得到apk的推荐安装位置，并检查是否能够进行正常的安装。在这一步，有可能抛出一些无法安装的状态位：存储空间不足、程序已经安装、无效的apk文件等，这个时候安装过程终止
3. 到这一步，表示程序可以正常安装，同时MCS服务服务可能会根据需要调整安装位置，在InstallParams的installLocationPolicy中完成
4. 文件的复制过程，PMS针对内部存储和sd卡分别提供了一个类：FileInstallArgs和AsecInstallArgs，并分别调用二者的copyApk方法来完成apk的复制过程
经过了上面4步，待安装apk已经被复制到了/data/app/目录了。

</rich_text><rich_text scale="h2">apk的解析过程</rich_text><rich_text>
    上面，apk已经被复制到了/data/app/目录，安装的第一步已经完成，那么系统是什么时候对apk进行dex提取和解析的呢，这还要从PMS说起， 在PMS内部有一个AppDirObserver类，顾名思义，它的作用是应用目录观察者，它时刻观察着应用目录/data/app/，当目录内部结构改 变的时候（创建文件和删除文件）它会做出相应行为，下面看下它的代码：
1. private final class AppDirObserver extends FileObserver {  
2.     public AppDirObserver(String path, int mask, boolean isrom) {  
3.         super(path, mask);  
4.         mRootDir = path;  
5.         mIsRom = isrom;  
6.     }  
7.     //在/data/app/目录下添加或删除apk的时候，此方法会被调用  
8.     public void onEvent(int event, String path) {  
9.         String removedPackage = null;  
10.         int removedAppId = -1;  
11.         int[] removedUsers = null;  
12.         String addedPackage = null;  
13.         int addedAppId = -1;  
14.         int[] addedUsers = null;  
15.   
16.         // TODO post a message to the handler to obtain serial ordering  
17.         synchronized (mInstallLock) {  
18.             String fullPathStr = null;  
19.             File fullPath = null;  
20.             if (path != null) {  
21.                 fullPath = new File(mRootDir, path);  
22.                 fullPathStr = fullPath.getPath();  
23.             }  
24.   
25.             if (DEBUG_APP_DIR_OBSERVER)  
26.                 Log.v(TAG, &quot;File &quot; + fullPathStr + &quot; changed: &quot; + Integer.toHexString(event));  
27.   
28.             if (!isPackageFilename(path)) {  
29.                 if (DEBUG_APP_DIR_OBSERVER)  
30.                     Log.v(TAG, &quot;Ignoring change of non-package file: &quot; + fullPathStr);  
31.                 return;  
32.             }  
33.   
34.             // Ignore packages that are being installed or  
35.             // have just been installed.  
36.             if (ignoreCodePath(fullPathStr)) {  
37.                 return;  
38.             }  
39.             PackageParser.Package p = null;  
40.             PackageSetting ps = null;  
41.             // reader  
42.             synchronized (mPackages) {  
43.                 p = mAppDirs.get(fullPathStr);  
44.                 if (p != null) {  
45.                     ps = mSettings.mPackages.get(p.applicationInfo.packageName);  
46.                     if (ps != null) {  
47.                         removedUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);  
48.                     } else {  
49.                         removedUsers = sUserManager.getUserIds();  
50.                     }  
51.                 }  
52.                 addedUsers = sUserManager.getUserIds();  
53.             }  
54.             //当apk被删除的时候，往往意味着这个apk被卸载  
55.             if ((event&amp;REMOVE_EVENTS) != 0) {  
56.                 if (ps != null) {  
57.                     if (DEBUG_REMOVE) Slog.d(TAG, &quot;Package disappeared: &quot; + ps);  
58.                     //removePackageLI方法完成卸载apk的主要功能  
59.                     removePackageLI(ps, true);  
60.                     removedPackage = ps.name;  
61.                     removedAppId = ps.appId;  
62.                 }  
63.             }  
64.               
65.             //新添加了一个apk，往往意味着一个新的apk被安装  
66.             if ((event&amp;ADD_EVENTS) != 0) {  
67.                 if (p == null) {  
68.                     if (DEBUG_INSTALL) Slog.d(TAG, &quot;New file appeared: &quot; + fullPath);  
69.                     //scanPackageLI方法完成了apk安装的第二个步骤  
70.                     p = scanPackageLI(fullPath,  
71.                             (mIsRom ? PackageParser.PARSE_IS_SYSTEM  
72.                                     | PackageParser.PARSE_IS_SYSTEM_DIR: 0) |  
73.                             PackageParser.PARSE_CHATTY |  
74.                             PackageParser.PARSE_MUST_BE_APK,  
75.                             SCAN_MONITOR | SCAN_NO_PATHS | SCAN_UPDATE_TIME,  
76.                             System.currentTimeMillis(), UserHandle.ALL);  
77.                     if (p != null) {  
78.                         /* 
79.                          * TODO this seems dangerous as the package may have 
80.                          * changed since we last acquired the mPackages 
81.                          * lock. 
82.                          */  
83.                         // writer  
84.                         synchronized (mPackages) {  
85.                             updatePermissionsLPw(p.packageName, p,  
86.                                     p.permissions.size() &gt; 0 ? UPDATE_PERMISSIONS_ALL : 0);  
87.                         }  
88.                         addedPackage = p.applicationInfo.packageName;  
89.                         addedAppId = UserHandle.getAppId(p.applicationInfo.uid);  
90.                     }  
91.                 }  
92.             }  
93.   
94.             // reader  
95.             synchronized (mPackages) {  
96.                 mSettings.writeLPr();  
97.             }  
98.         }  
99.   
100.         //下面两个if语句块大家应用不陌生吧，在我们的应用中想监听应用的安装和卸载，  
101.         //就是通过收听ACTION_PACKAGE_ADDED和ACTION_PACKAGE_REMOVED这两个广播来实现的  
102.         if (removedPackage != null) {  
103.             Bundle extras = new Bundle(1);  
104.             extras.putInt(Intent.EXTRA_UID, removedAppId);  
105.             extras.putBoolean(Intent.EXTRA_DATA_REMOVED, false);  
106.             sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED, removedPackage,  
107.                     extras, null, null, removedUsers);  
108.         }  
109.         if (addedPackage != null) {  
110.             Bundle extras = new Bundle(1);  
111.             extras.putInt(Intent.EXTRA_UID, addedAppId);  
112.             sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, addedPackage,  
113.                     extras, null, null, addedUsers);  
114.         }  
115.     }  
116.   
117.     private final String mRootDir;  
118.     private final boolean mIsRom;  
119. }  
    下面，我们主要分析一下scanPackageLI方法，还是仅仅分析，不帖代码，因为代码太长了，帖出来没法看了，这个方法不仅仅是完成apk包的扫描， 还解析AndroidManifest.xml文件并提取出所有的intent-filter和permission信息，apk安装的主要功能都由它来 完成的，当apk包扫描完成后，系统会调用updatePermissionsLPw方法更新系统所具有的权限。
scanPackageLI方法有两个，其第一个参数分别接受File和PackageParser.Package类型，第一个方法会从File中提取出package信息然后再调用第二个方法，下面分析第二个scanPackageLI方法，其完成的事情如下：
1. 如果包名是android，则会做一些特殊处理，这个包名为android的应用是系统内部应用的，其他应用的包名如果叫android则安装会有问题，大家可以试一下
2. 解析常见的use-feature、shared-userId、use-library标签并保存到成员变量中
3. 进行签名验证，对应的方法是verifySignaturesLP，验证失败则应用无法安装
4. 创建应用程序目录/data/data/包名，同时将apk中提取出dex文件并保存到/data/dalvik-cache，把apk当做zip解压就能得到dex文件
5. 解析AndroidManifest.xml文件，提取出所需信息，包括具有intent-filter的四大组件信息（Activity、Service、BroadcastReceiver、ContentProvider）和声明的系统权限等
    到 此为止，scanPackageLI方法结束了。而updatePermissionsLPw的作用是对系统中所有的权限进行更新，大家可以查看下 /system/etc/permissons目录，下面定义了android系统中所有的权限，开发中最常用的权限定义在目录下的 platform.xml里面，大家可以打开看看，可以看到常见的访问网络、读写外部存储等权限等都是在这里定义的。权限更新完毕以后，系统就会发送 ACTION_PACKAGE_ADDED广播，告知所有应用有新应用安装了。另外，大家可以查看下data/system/目录，里面有两个文件 packages.list和packages.xml，在packages.list里面放的是手机上安装的所有应用列表，而packages.xml 中存放的是所有应用的设置应用，比如一个应用声明了哪些系统权限就定义在这里面。关于应用的卸载，我们可以想到是应用安装过程的逆过程，大致要做的是：停 止应用、删除各种文件，更新系统设置、权限等，大家感兴趣自己看一下，完全是安装过程的逆过程，这里不介绍了。
</rich_text></node></node><node name="camera driver" prog_lang="custom-colors" readonly="False" tags="" unique_id="15"><rich_text>
</rich_text><rich_text scale="h3">1  手机摄像头功能概述</rich_text><rich_text>
    手机摄像头功能由多个功能模块组成，主要三个部分，采集，加工，显示。
    （1）采集部分由感光的sensor完成，通过CAM IF接口与手机芯片内的CAM连接。
    （2）CAM对CAM IF数据进行加工，主要是格式转换，特殊效果等。最终处理出来的一帧数据，存在内存中。
    （3） 手机的刷新线程，使用手机内部的DMA功能，或者OVERLAY技术，把处理好的camera图像，显示到LCD上。刷新部分，不在camera框架范围内，后面只做简单讨论。
    图1：Camera典型硬件模块图

</rich_text><rich_text scale="h3">2  Sensor简介</rich_text><rich_text>
    Sensor是对图像的采集系统，通常采用的是ov系列的芯片。如ov2655等。通常包含两路接口：
    （1）控制总线：Sensor也是一个智能嵌入式系统，一般通过I2C总线与手机芯片通信。手机可以通过I2C读写Sensor的寄存器，改变Sensor的参数，从而改变其工作方式。
    （2）数据总线：Sensor通过CAM IF接口与CAM联系。
     
    图2：sensor硬件连接图
     
    由图可知，sensor工作的条件需要：
    （1）电压供应，一般模拟电压，数字电压。
    （2）工作时钟，通常为24M HZ的正弦波。一般为手机芯片产生
    （3）SDA,SCL，i2c总线连接，sensor通常为从设备。
    （4）standby控制线，手机芯片通过这条GPIO控制线，控制sensor的工作是否开启。
    （5）Sensor输出给手机芯片的接口，CAM IF接口：
    （6）并行数据线，通常8位，10位。分辨率高的sensor数据线需要更多。
    （7）提供给手机芯片内集成的camera模块的PCLK,HCLK,VCLK.(像素同步信号，行同步信号，帧同步信号)。
    Sensor通常产出稳定频率的数据图像流，手机芯片可以通过I2C总线接口，修改寄存器，改变帧频率。也可以改变sensor的输出流的格式，通常采用yuv422格式。

</rich_text><rich_text scale="h3">3  CAM简介</rich_text><rich_text>
    CAM就是将Sensor采集过来的数据，转换相应格式，及其他加工，最后存放到内存中。CAM核心就是个DSP。这个阶段，dsp可以做很多图像处理的事情。比如颜色纠正，自动对焦，scaler等。不同平台会有不同。
    由于Sensor的核心也是dsp，对于这些特效工作，一般Sensor中也会提供。
    高通平台的Sensor的特效（反色）就可以在Sensor中设置。
    由图可知
    CAM consists ofthe following elements:
    • Image Signal Processing (ISP)1
    • Color Processing
    • Image effects
    • Luminance / Chrominance Splitter (Y/C Split)
    • Resize (Down/Up-Scalers)
    • JPEG Encoder
    • YCbCr to RGB conversion for preview
    • Memory Interface
    • Control Unit
    具体详解，可见ste6715 datesheet。
    这些模块看似很复杂，对于我们开发者来说，也不复杂。我们知道它们相应的流程，并且知道每个子模块提供了什么功能。这些模块的功能可以通过相应模块的寄存器进行相应调整的]。这同sensor的参数调整的思想是一样的。硬件提供功能，通过寄存器进行参数调整。
     
    Camera的native层软件接口，在Camera在native层中，提供了/dev/video*的设备节点。Native层通过打开设备 文件，关联上camera，申请一串帧缓冲区，建立循环队列，并把这些内存地址传给内核的camera模块，并等待内核camera的处理结束。 Camera模块一帧处理结束，native层就会返回。 

</rich_text><rich_text scale="h3">4  LCD显示</rich_text><rich_text>
    LCD的显示，就是将lcd的framebuffer的数据映射到LCD屏上，而我们camera的数据要在屏幕上显示，就只需建立camera帧 buffer到framebuffer的映射关系。可以使用内核的DMA，也可以使用overlay。通常的preview过程都是在native层以上 开个线程，waiting kernel的处理完成，然后push到lcd屏上，如此循环。
    （1）软件设计思想


</rich_text><rich_text scale="h3">5  V4l2驱动框架：</rich_text><rich_text>
    关联文件：V4l2-dev.c(src\linux\kernel\linux\drivers\media\video)
    Videodev2.h(src\linux\kernel\linux\include\linux) Cam-core分析
    V4l2.c（src/linux/modules/v4l2cam）
    V4L2是linux的标准接口，提供了众多的标准IOCTL接口，这样不管内核驱动如何改变，风格各异，都可以让应用程序native程序稳定工作。IOCTL接口标准定义于Videodev2.h，这个文件也会被android系统所引用。
    V4L2层的意义在于：让平台的驱动，通过char字符设备层能够与应用关联起来。首先对v4l2.c和v4l2-dev.c两个文件的内容做个简单介绍：
    （1）V4l2.c文件主要工作：在模块加载的时候，调用v4l2_init()函数，该函数完成camera_sensor的获取和对 video_device设备的创建，初始化和注册。实际上完成一个video_device设备驱动，最重要的是v4l2_ioctrl()函数的实 现，根据android的HAL层传下来的操作类型调用不同的控制函数，而这些控制函数通过调用cameraa_sensor和camIF接口来实现。
    （2）V4l2-dev.c文件的主要工作：完成一个字符设备驱动，并实现了video_device注册的工作。字符设备驱动中的主要工作是通过调用video_device设备驱动来完成的。
        这里请注意：camera驱动分为三个部分，最后生成cam.ko，v4l2cam.ko和sensor.ko三个模块，v4l2cam.ko依赖于cam.ko和sensor.ko模块，因此，v4l2cam.ko后于cam.ko和sensor.ko模块加载。
    下面来分析v4l2框架的工作流程。
    （1）v4l2-dev.c
    v4l2-dev.c文件中初始化函数申请了v4l2的字符设备号，但是并没有注册和关联具体驱动。
    static int __init videodev_init(void){  
        dev_t dev =MKDEV(VIDEO_MAJOR, 0);  
        int ret;
        ……  
        ret =register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);  //申请一组设备号
        ……  
        ret =class_register(&amp;video_class);              //注册一个类设备
    } 
    提供了2个函数供其他具体驱动进行注册
    video_register_device_index（）;
    video_register_device（）;
    int video_register_device_index(struct video_device *vdev, int type,int nr,                              
            int index){
            ……  
            vdev-&gt;cdev= cdev_alloc();  
            if (vdev-&gt;cdev == NULL) {         
                ret =-ENOMEM;         
                gotocleanup;  
            }  
            
            if (vdev-&gt;fops-&gt;unlocked_ioctl)         
                vdev-&gt;cdev-&gt;ops= &amp;v4l2_unlocked_fops;  
            else         
                vdev-&gt;cdev-&gt;ops= &amp;v4l2_fops;
                  
            vdev-&gt;cdev-&gt;owner= vdev-&gt;fops-&gt;owner;  
            ret = cdev_add(vdev-&gt;cdev,MKDEV(VIDEO_MAJOR, vdev-&gt;minor), 1);  //注册一个字符设备
            ……
            memset(&amp;vdev-&gt;dev, 0, sizeof(vdev-&gt;dev));  
            /* The memsetabove cleared the device's drvdata, so     
            put back the copy we made earlier. */  
            video_set_drvdata(vdev,priv);  
            vdev-&gt;dev.class= &amp;video_class;  
            vdev-&gt;dev.devt= MKDEV(VIDEO_MAJOR, vdev-&gt;minor);  
            if (vdev-&gt;parent)         
                vdev-&gt;dev.parent= vdev-&gt;parent;  
            dev_set_name(&amp;vdev-&gt;dev,&quot;%s%d&quot;, name_base, vdev-&gt;num);  
            ret = device_register(&amp;vdev-&gt;dev);  //注册video_deice设备，将其添加到sysfs文件系统
            ……
            mutex_lock(&amp;videodev_lock);  
            video_device[vdev-&gt;minor] = vdev;   //本地管理的一个video_device数组  
            mutex_unlock(&amp;videodev_lock);
            ……
    }
    该文件中核心对象为：static struct video_device *video_device[VIDEO_NUM_DEVICES];
    设备文件就是根据index与相应的video_device[index]指针关联。
    在videodev_init()初始化函数中，申请了一组设备号，并注册了一个类 video_class，在注册视频设备时，首先注册了一个字符设备，然后用相同的设备号注册了一个设备节点。这里的字符设备是让平台的驱动通过char 字符设备层能够与应用关联起来，V4l2框架核心文件为v4l2-dev.c。  
    v4l2-dev.c文件的核心对象为：static struct video_device  *video_device[VIDEO_NUM_DEVICES]，它维护每个注册了的video_device设备，设备文件就是根据index与相 应的video_device[index]指针关联。所以，这个文件的主要工作就是：字符设备的驱动内容。
字符设备驱动最后还是调用video_device的fops来实现的，这个fops就是v4l2.c中的cam_fops结构体，不过它只实现了 打开，关闭，映射和io控制四个函数。这里要注意的是：在注册video_device前是通过config_a_device（）来初始化 video_device的fops的成员的。
 
（2）V4l2.c：
    文件中重要的数据对象：
    struct acq_device_t {       
        structvideo_device *vfd;           //视频设备对象指针
        
        #define NAME_LENGTH 16    
        char name[NAME_LENGTH];       
        
        ……        
        
        structacq_session_cxt_t *streaming;              //打开camera的一个上下文
               
        video_frame_t *stream_vdf[V4L2_MAX_VDF];       
        
        /* Hardware dependant parts */       
        
        /* The Camera object plugged to our CAMIF*/       
        
        structcamera_sensor *camera;        //sensor对象指针  
             
        /* specific to sensor */       
        void *camera_priv_data;       
        ……
    }; 
    
    struct acq_session_cxt_t {   //代表一个打开的camera设备       
        structacq_device_t *dev;      
         /* handle to control session of CAM hardware bloc */       
         void *camhdl;       
         /* data pool handle (framemem) */       
         void *pool_hdl;       
         /* jpeg buffers */
      #ifdef CONFIG_V4L2CAM_PMEM       
         memblock_t blocks[V4L2_MAX_BUF];
      #else       
         struct v4l2_buffer bufs[V4L2_MAX_BUF];
      #endif       
      /* CameraPixfmt defines the size andpixel format of the sensor. */       
      struct v4l2_pix_format CameraPixfmt;       
      /* CamPixfmt defines the size and pixelformat at the output of CAM bloc */       
      struct v4l2_pix_format CamPixfmt;      
      /* CamPixfmt defines the size and pixelformat of thumbnail at the output of CAM bloc*/       
      struct v4l2_pix_format CamThumbfmt;       
      /* video frame use to preview session */       
      video_frame_t *cur_vdf;       
      video_frame_t *next_vdf;      
      int count;
  }; 
  
    V4l2cam驱动模块的初始化函数流程如下：
    int v4l2_init(void){
        ……  
        while (1) {         
            dev =kzalloc(sizeof(struct acq_device_t), GFP_KERNEL);         
            dev-&gt;camera = v4l2_detect(dev);             //检测并获得camera_sensor设备         
            /* openthe cam bloc interface */         
            cam_open(&amp;hdl);         
            /* wegot a camera plugged ! */         
            /*initialiseprivate fields of the sensor, for cmos coprocessor we try to find the cameraplugged to it */         
            dev-&gt;camera_priv_data= dev-&gt;camera-&gt;init();          
            /*close the cam bloc interface */         
            cam_close(hdl);         
            dev-&gt;vfd = video_device_alloc();              //为video_device分配内存         
            if (config_a_device(dev)) {                //初始化video_device设备结构，包括fops成员                
                unconfig_a_device(dev);                
                ret= -ENODEV;                
                gotobail;         
            }          
            
            if (video_register_device(dev-&gt;vfd,VFL_TYPE_GRABBER, dev-&gt;vfd-&gt;minor) != 0) {                                //注册video_device设备                
                CRITICAL(&quot;Couldn'tregister video driver.&quot;);                
                unconfig_a_device(dev);                
                ret= -ENODEV;                
                gotobail;         
             }         
             
             dev-&gt;is_registered= 1;         
             dev-&gt;preview_running= FALSE;         
             dev-&gt;snapshot_running= FALSE;         
             dev-&gt;snapshot_done= FALSE;          
             /* initcompletion */         
             init_completion(&amp;dev-&gt;complete);          
             video_set_drvdata(dev-&gt;vfd, dev);
          }
     }
     该函数中出现一个config_a_device(dev)函数，这个函数是video_device设备的初始化配置函数，包括对文件操作指针的赋值，这里是一个初始化封装。
    先来看看v4l2_detect()函数：
    structcamera_sensor *v4l2_detect(structacq_device_t *dev){       
        struct camera_sensor **Cams = NULL;       
        struct camera_sensor *cam = NULL;       
        void *hdl = 0;      
        int i = 0;       
        
        PROLOG(&quot;&quot;);        
        dev-&gt;camera = NULL;       
        
        cam_open(&amp;hdl);        
        Cams= sensor_get_cameras();         //获取camera_sensor数组       
        if (Cams) {              
            while (Cams[i] != NULL) {                     
                cam = Cams[i];                     
                if (!cam-&gt;isProbed) {                            
                    cam-&gt;isProbed =1;                            
                    if (cam-&gt;detect() == 0) {            //创建和初始化camera_sensor就在这里，这是sensor驱动部分的内容，后面会有详细的介绍                                   
                        goto detect_exit;                            
                    }                     
                }                     
                
                i++;              
            }                   
        }       
        dev-&gt;camera = NULL;       
        cam = NULL;      
         
    detect_exit:       
        cam_close(hdl);       
        EPILOG(&quot;&quot;);       
        return cam;
    }
    该函数中调用了cam-&gt;detect()函数，这个函数在camera的sensor部分被实现，后面会有详细说明，下面看看如何注册 video_device设备的，video_register_device（）函数，该函数代码在前面已经列出，这里简单描述：
    intvideo_register_device(struct video_device *vdev, int type, int nr){       
        return __video_register_device(vdev,type, nr, 1);
    }
     
    static int __video_register_device(struct video_device *vdev, int type, int nr,              
            int warn_if_nr_in_use){       
            
            ……       
            
            ret= cdev_add(vdev-&gt;cdev, MKDEV(VIDEO_MAJOR, vdev-&gt;minor), 1);       
            
            ……       
            
            ret= device_register(&amp;vdev-&gt;dev);       
            
            ……       
            
            video_device[vdev-&gt;minor]= vdev;       
            
            ……
    }
    该文件中核心对象为：static struct video_device *video_device[VIDEO_NUM_DEVICES];设备文件就是根据index与相应的video_device[index]指针关联。
    由驱动框架我们了解到，平台驱动就是初始化video_device结构，然后注册到V4L2框架中。

在V4l2框架中有几个重要内容有必要提出来：
（1）capture_callback（）
     void capture_callback(void *userdata){ 
        struct acq_session_cxt_t*acq_cxt = (struct acq_session_cxt_t *)userdata; 
        struct acq_device_t *dev; 
        
        BUG_ON(!acq_cxt); 
        dev = acq_cxt-&gt;dev; BUG_ON(!dev); 
        dev-&gt;it_frame_nb++;  
        if (dev-&gt;wait_end_of_frame) {         
            dev-&gt;wait_end_of_frame= 0;        
            complete(&amp;dev-&gt;complete); 
        } else {        
            if(dev-&gt;wait_first_frame) {               
                dev-&gt;wait_first_frame= 0;               
                complete(&amp;dev-&gt;complete);        
            } 
        }
    }
    这是一个回调函数，当一帧数据完成时候，中断函数会响应，从而callback函数也会被调用，唤醒comple等待的函数。此callback函数通过cam_streaming_start函数，注册到底层cam驱动中，下面是启动camera数据流的函数。
    static inline int v4l2_stream_on(structacq_device_t *dev, struct acq_session_cxt_t *acq_cxt, void *arg) {
        
        ……
        
        cam_streaming_start(acq_cxt-&gt;camhdl,                         
            acq_cxt-&gt;cur_vdf, (void*)capture_callback, (void *)data_loss_callback, (void *)acq_cxt);
         
         ……
    } 

（2）v4l2_do_ioct（）
      static long v4l2_do_ioctl(struct file *file, unsigned intcmd, void *arg)；此函数相当庞大，在此不列出了，就是IOCTL的实现函数，每个命令都会有个处理函数，也在此文件中。
      
（3）v4l2_mmap（）
    static int v4l2_mmap(struct file *file, structvm_area_struct *vma)；此函数把内核的cam数据映射到用户空间，用户空间可以读取。

（4）v4l2_open（）
    static int v4l2_open(struct file *file)
    此函数就是创建一次与具体sensor的连接，重要的是创建了acq_session_cxt_t上下文对象。但此时cam的采集转换工作并没有启 动。启动工作是通过ioctl在v4l2_do_ioctl调用v4l2_stream_on函数启动的，就是刚才的那个设置回调函数的函数。
    这里的核心对象为：struct acq_device_t *devices[] = { NULL, NULL, NULL, NULL,  NULL,NULL, NULL, NULL }；每个 acq_device_t  标识唯一camera设备，而acq_session_cxt_t标识一次打开的上下文。
    V4L2平台驱动，调用了2个子模块驱动：Sensor驱动和cam模块驱动，使两者协调工作，从而组成个完成的摄像头工作模块。不过这里要注意的是，v4l2.c 指出同一时间只能打开一次，不能重复打开。

</rich_text><rich_text scale="h3">6  Sensor驱动部分：</rich_text><rich_text>
（一）sensor的核心部分
    Sensor-core驱动很简单。此文件维护一个camera_sensor数组，以供v4l2.c使用。它还实现了关联sensor对象的i2c驱动句柄对象（camera_serial_bus类型）。
    初始化函数流程：
    int sensor_init(void) {
        /* +LMSqc15648 Update i2c mechanism to avoid static registering in kernel */
        #ifdef CONFIG_I2C_NEW_PROBE  
            struct i2c_board_info board_info = {         
                type :&quot;i2ccamera&quot;,         
                addr :0x30  
            };    
            
            struct i2c_adapter* i2c_adap=NULL;  
            PROLOG(&quot;&quot;);     
            i2c_adap = i2c_get_adapter(1);            //获取一号总线适配器    
            if ( i2c_adap==NULL ) {       
                CRITICAL(&quot;Can't get i2cadapter&quot;);    
            } else {          
                i2c_new_device(i2c_adap, &amp;board_info);  //创建一个新i2c设备}
        #endif
        /* -LMSqc15648 Update i2c mechanism to avoid static registering in kernel */  
        EPILOG(&quot;&quot;);  
        return 0;
   }       
   
   这个函数主要是根据borad_info创建了一个i2c_client设备，这在后面的i2c_init（）函数被调用时会匹配到该设备。
    文件中有一个camera_sensor数组，用来保存每个sensor实例：
        struct camera_sensor *Cams[] = {       
            &amp;camera_gc2015,       
            NULL
         };
         
    获取sensor数组的重要函数：
    structcamera_sensor **sensor_get_cameras() {
        return Cams;
    }       
    
    该文件的主要工作还是实现了一个camera_serial_bus结构对象camera_sbus_i2c，它是sensor同i2c总线通信的实现。
    struct camera_serial_bus camera_sbus_i2c = {
        /* +LMSqc11271'probe' is not working in device driver. */
        #ifdef CONFIG_I2C_NEW_PROBE      
            client:NULL,
        #endif
        /* -LMSqc11271'probe' is not working in device driver. */      
        init:i2c_init,      
        cleanup:i2c_cleanup,      
        set_devid:i2c_set_devid,      
        read:i2c_read,      
        write:i2c_write,      
        read:i2c_read,      
        read8:i2c_read8,      
        write8:i2c_write8,
   }; 
    
（二）sensor部分
       Sensor驱动部分的内容就是：根据sensor的datesheet填写出camera_sensor数据结构的函数实现，并创建个 camera_sensor对象，此对象会被sensor-core引用，下面以gc2015为例。
       Gc2015的驱动代码实现文件为gc2015.c，该文件中定义了一个camera_sensor对象：
    struct camera_sensor camera_gc2015 = {     
        name:&quot;gc2015&quot;,     
        detect:gc2015_detect,     
        isProbed:0,     
        clock:24,     
        yuvOrder:INPUT_SEQ_CbYCrY,//INPUT_SEQ_CrYCbY,     
        hsyncPol:INPUT_POL_VSYNC_HIGH,//INPUT_POL_VSYNC_HIGH,//INPUT_POL_VSYNC_LOW,     
        vsyncPol:INPUT_POL_HSYNC_LOW,//INPUT_POL_HSYNC_HIGH,//INPUT_POL_HSYNC_LOW,      
        sampleEdge:INPUT_SAMPLE_EDGE_POS,     
        fullrange:false,     
        init:gc2015_init,     
        cleanup:gc2015_cleanup,     
        open:gc2015_open,     
        close:gc2015_close,     
        enum_pixformat:gc2015_enum_pixformat,     
        try_format:gc2015_try_format,     
        set_format:gc2015_set_format,     
        stop_sensor:gc2015_stop_sensor,     
        start_sensor:gc2015_start_sensor,     
        query_control:gc2015_query_control,     
        get_control:gc2015_get_control,     
        set_control:gc2015_set_control,     
        
        ……     
        
        query_wb_mode:gc2015_query_wb_mode,     
        get_wb_mode:gc2015_get_wb_mode,     
        set_wb_mode:gc2015_set_wb_mode,     
        check_frame:gc2015_check_frame,     
        check_short_circuit:NULL,
    }; 
    
    这个文件的主要内容就是实现这些初始化函数，其中最为重要的是gc2015_detect（）函数，前文有介绍过，在v4l2框架里面的v4l2.c文件 的v4l2_init()函数中调用v4l2_detect()函数，它既是调用的这个gc2015_detect（）函数完成对 camera_sensor的检测和初始化的，下面来看看这个函数的具体实现。
    static int gc2015_detect(void) {       
        extern struct camera_serial_bus camera_sbus_i2c;       
        structcamera_serial_bus *sbus;          
        
        u6_gpio_write_pin(GC2015_GPIO_PD,GC2015_GPIO_PD_OFF);       
        msleep(100);        
        /*set the output camera clock (camclko) */       
        gc2015_set_Mclk(camera_gc2015.clock);           
        msleep(200);   
        printk(&quot;gc2015_detect\n&quot;);       
        
        if((rc = sbus-&gt;init())) {              //该函数调用注册一个i2c驱动              
            CRITICAL(&quot;Couldn'taccess I2c part ofcamera&quot;);              
            gotoerror;       
        }           
        
        sbus-&gt;set_devid(CAM_GC2015_I2C_ID);              //重新设定sensor设备的i2c地址        
        if ((rc = gc2015_write_reglist(gc2015_init_global)))              
            gotoerror;   
                    
        /*DeviceID*/       
        if((rc = gc2015_read_reg(0x00, &amp;pidh)))              
            gotoerror;       
            
        if((rc = gc2015_read_reg(0x01, &amp;pidl)))              
            gotoerror;    
              
    error:           
        sbus-&gt;cleanup();           
        /*activate the power down mode */       
        u6_gpio_write_pin(GC2015_GPIO_PD,GC2015_GPIO_PD_ON);        
        gc2015_unset_Mclk();        
        
        ……
        
    }       
     
    这个函数调用了sensor-core.c中的i2c关联对象的初始化函数，然后调用set_devid()函数设置sensor的硬件地址。
    static int i2c_init(void){       
        int err = 0;
        /* +LMSqc11271 'probe' is not working indevice driver. */
     #ifdef CONFIG_I2C_NEW_PROBE       
        structi2c_client *cam_i2c_client = NULL;
     #endif
     /* -LMSqc11271 'probe' is not working indevice driver. */       
     
        PROLOG(&quot;&quot;);        
        err = i2c_add_driver(&amp;i2c_driver);   //注册一个i2c驱动       
        if (err)              
            CRITICAL(&quot;Failedto add Camera I2Cdriver&quot;);
        /* +LMSqc11271 'probe' is not working indevice driver. */
     #ifdef CONFIG_I2C_NEW_PROBE       
        cam_i2c_client = camera_sbus_i2c.client;
     #endif
        /* -LMSqc11271 'probe' is not working indevice driver. */              
        if (cam_i2c_client ==NULL) {              
            i2c_del_driver(&amp;i2c_driver);              
            err= -ENODEV;       
        }        
        
        EPILOG(&quot;&quot;);       
        
        return err;
    }       
    
    注册一个i2c驱动，这册过程伴随着设备与驱动的匹配过程，当匹配成功后就调用相应的probe（）函数。
    static int sensor_i2c_probe(struct i2c_client *new_client, const struct i2c_device_id *id) {       
        PROLOG(&quot;&quot;);       
        
        i2c_set_clientdata(new_client, &amp;camera_sbus_i2c);       
        
        camera_sbus_i2c.client = new_client;       
        
        EPILOG(&quot;&quot;);       
        
        return 0;
        
    }       

    至此，sensor设备已准备好，v4l2框架便可访问sensor设备了。
     

</rich_text><rich_text scale="h3">7  Cam驱动部分：</rich_text><rich_text>
    涉及的文件：Cam-core.c (src\linux\modules\cam)
    Cam-lib.c (src\linux\modules\cam) 
    此驱动就是cam寄存器的函数封装，以及时钟信号的开关。本文件中的最重要数据cam_interface结构如下：
    struct cam_interface cam = {
        camPwr:NULL,     
        camClk:NULL,     
        jpegClk:NULL,     
        IsInit:0,     
        open_counter:0,      
        whendone_cb:NULL,      
        onerror_cb:NULL,      
        data_cb:NULL,     
        vdf:NULL,     
        wait_encode:0,     
        wait_header_generation:0,     
        wait_data_transfert:0,     
        wait_vsync:0,     
        preview_hdl:0,     
        zoom:1000,     
        brightness:CAM_BRIGHT_DFT,     
        saturation:CAM_SAT_DFT,     
        contrast:CAM_CONTRAST_DFT,     
        efx:NO_EFX,     
        previewRunning:FALSE,     
        immediateUpdate:FALSE,
    }       
    
    该模块的初始化函数：
    int cam_init(void) {       
        PROLOG(&quot;&quot;);        
        /* Reserve I/O addresses */       
        if (!request_mem_region(CAM_IF_START,CAM_IF_SIZE, &quot;CAM_IF&quot;)) {                   
            CRITICAL(&quot;request_mem_regionfailed&quot;);              
            return -EBUSY;       
        }        
        
        if (!cam.IsInit) {    /* do it one time */               
            /* Get the CAM &amp; CAMJPEGclocks */              
            cam.camClk = clk_get(0, &quot;CAM&quot;);              
            if (IS_ERR(cam.camClk)) {                     
                CRITICAL(&quot;Failed !(Could not get the CAM clock)&quot;);                     
                return -ENXIO;              
            }               
            
            cam.jpegClk = clk_get(0,&quot;CAMJPE&quot;);              
            if (IS_ERR(cam.jpegClk)) {                     
                CRITICAL(&quot;Failed !(Could not get the CAMJPEG clock)&quot;);                     
                return -ENXIO;              
            }               
            /* Get the CAMpower */              
            cam.camPwr = pwr_get(NULL, &quot;CAM&quot;);              
            if (IS_ERR(cam.camPwr)) {                     
                CRITICAL(&quot;Failed !(Could not get the CAM power)&quot;);                     
                return -ENXIO;              
             }              
             ……       
         }        
         
         EPILOG(&quot;&quot;);       
         
         return 0;
     }
     
     该函数就是对cam成员进行初始化，如申请内存，获取时钟和电源等。下面是驱动中重要的函数：
 
（1）cam模块的启动函数
    int cam_streaming_start(void *hdl,video_frame_t * frame, void *whendone_cb, void *onerror_cb, void *data_cb)
    在这里面（前面有说过）上层v4l2.c中的callback函数就是通过cam_streaming_start函数，注册到底层cam驱动中，当一帧数据完成时候，中断函数会响应，从而callback函数也会被调用，唤醒comple等待的函数。
 
（2）切换到下一帧
    void cam_update_stream_path(void *hdl,video_frame_t * frame)
 
（3）中断函数（cam_lib.c文件中定义）
    irqreturn_t cam_int_irq(int irq, void *client_data) {  
        u32isp_itstat, mem_itstat;   
        
        isp_itstat = cam_isp_isr_regs-&gt;cam_isp_mis;  
        mem_itstat =cam_mem_isr_regs-&gt;cam_mem_mis;  
        cam_jpe_regs-&gt;cam_jpe_status_mis; 
        
        ……   
        
        /***************** Memory interrupts ***********************/
        else if (mem_itstat &amp; CAM_IMSC_SP_FRAME_END) {                
            PDEBUG(&quot;SP_FRAME_END,%lx&quot;, jiffies);                
            cam_int_clear(0,CAM_IMSC_SP_FRAME_END, 0);                
            /*call of whendonecallback */                
            if (cam.whendone_cb != NULL) {                       
                if (isp_itstat &amp; CAM_IMSC_V_START) {                              
                    PTRACE(&quot;corruptedframe&quot;);                       
                } else {
                    ……                              
                    /*call user whendone */                              
                    cam.whendone_cb(cam.data_cb);                       
                    
                }                
             }         
          }  
       } 
       
       ……
    
    }
    所有cam模块内部的中断，都是此函数，红色标注部分为一帧数据到来，并最终调用到平台驱动的capture_callback（）。
</rich_text></node><node name="android启动流程" prog_lang="custom-colors" readonly="False" tags="" unique_id="1"><rich_text>
</rich_text><node name="bootloader" prog_lang="custom-colors" readonly="False" tags="" unique_id="2"><rich_text>摘要：本文讲解Android系统在启动过程中的关键动作，摈弃特定平台之间的差异，讨论共性的部分，至于启动更加详细的过程，需要结合代码分析，这里给出流程框架，旨在让大家对开机过程更明了。
 
关键词：U-boot、Linux、Android
 
目录：
       第一部分：Bootloader启动
一、Bootloader的定义和种类
二、Arm特定平台的Bootloader
三、U-boot启动流程分析
 
       第二部分：Linux启动
一、zImage是怎样炼成的？
二、linux的c启动阶段
 
       第三部分：Android启动
一、init进程
二、init启动的各种服务
              三、android启动图示
              
       对于Android整个启动过程来说，基本可以划分成三个阶段：Bootloader引导、Linux kernel启动、Android启动。下面分别对每个阶段一一展开讨论。
 
第一部分：Bootloader启动
一、             Bootloader的定义和种类
简单地说，BootLoader是在操作系统运行之前运行的一段程序，它可以将系统的软硬件
环境带到一个合适状态，为运行操作系统做好准备。这样描述是比较抽象的，但是它的任务确实不多，终极目标就是把OS拉起来运行。
 
在嵌入式系统世界里存在各种各样的Bootloader，种类划分也有多种方式。除了按照处
理器体系结构不同划分以外，还有功能复杂程度的不同。
先区分一下Bootloader和</rich_text><rich_text link="webs http://blog.csdn.net/lizhiguo0532/article/details/7017503#_msocom_1">Monitor[l1] </rich_text><rich_text>： 严格来说，Bootloader只是引导OS运行起来的代
码；而Monitor另外还提供了很多的命令行接口，可以进行调试、读写内存、烧写Flash、配置环境变量等。在开发过程中Monitor提供了 很好地调试功能，不过在开发结束之后，可以完全将其设置成一个Bootloader。所以习惯上将其叫做Bootloader。
 
 
</rich_text><rich_text justification="left"></rich_text><rich_text>

       更多bootloader还有：ROLO、Etherboot、ARMboot 、LinuxBIOS等。
       
       对于每种体系结构，都有一系列开放源码Bootloader可以选用:
       X86：X86的工作站和服务器上一般使用LILO和GRUB。
       ARM：最早有为ARM720处理器开发板所做的固件，又有了armboot，StrongARM平
台的blob，还有S3C2410处理器开发板上的vivi等。现在armboot已经并入了U-Boot，所以U-Boot也支持ARM/XSCALE平台。U-Boot已经成为ARM平台事实上的标准Bootloader。
       PowerPC：最早使用于ppcboot，不过现在大多数直接使用U-boot。
       MIPS：最早都是MIPS开发商自己写的bootloader，不过现在U-boot也支持MIPS架构。
       M68K：Redboot能够支持m68k系列的系统。
       
二、             Arm特定平台的bootloader
到目前为止，我们公司已经做过多个Arm平台的android方案，包括：marvell(pxa935)、
informax(im9815)、mediatek(mt6516/6517)、broadcom(bcm2157)。由于不同处理器芯片厂商对 arm  core的封装差异比较大，所以不同的arm处理器，对于上电引导都是由特定处理器芯片厂商自己开发的程序，这个上电引导程序通常比较简单，会初始化硬 件，提供下载模式等，然后才会加载通常的bootloader。
下面是几个arm平台的bootloader方案：
marvell(pxa935) :                bootROM + </rich_text><rich_text link="webs http://blog.csdn.net/lizhiguo0532/article/details/7017503#_msocom_4">OBM [l4] </rich_text><rich_text>+ BLOB
informax(im9815) :             bootROM + barbox + U-boot
mediatek(mt6516/6517) :     bootROM + </rich_text><rich_text link="webs http://blog.csdn.net/lizhiguo0532/article/details/7017503#_msocom_5">pre-loader[l5]</rich_text><rich_text>  + U-boot
broadcom(bcm2157) :          bootROM + boot1/boot2 + U-boot
 
为了明确U-boot之前的两个loader的作用，下面以broadcom平台为例，看下在上电之
后到U-boot的流程，如图1.2.1：
</rich_text><rich_text justification="left"></rich_text><rich_text>
                                          图1.2.1 broadcom平台上电流程
 
 
三、             U-boot启动流程分析
最常用的bootloader还是U-boot，可以引导多种操作系统，支持多种架构的CPU。它支持的操作系统有：Linux、NetBSD、 VxWorks、QNX、RTEMS、ARTOS、LynxOS等，支持的CPU架构有：ARM、PowerPC、MISP、X86、NIOS、 Xscale等。
 
手机系统不像其他的嵌入式系统，它还需要在启动的过程中关心CP的启动，这个时候就涉及到CP的image和唤醒时刻，而一般的嵌入式系统的uboot只负责引导OS内核。所以这里我们也暂不关心CP的启动，而主要关心AP侧。
从上面第二小节中可以看出，bootloader通常都包含有处理器厂商开发的上电引导程序，不过也不是所有的处理都是这样，比如三星的 S3C24X0系列，它的bootROM直接跳到U-boot中执行，首先由bootROM将U-boot的前4KB拷贝到处理器ISRAM，接着在U- boot的前4KB中必须保证要完成的两项主要工作：初始化DDR，nand和nand控制器，接着将U-boot剩余的code拷贝到SDRAM中，然 后跳到SDRAM的对应地址上去继续跑U-boot。
所以</rich_text><rich_text link="webs http://blog.csdn.net/lizhiguo0532/article/details/7017503#_msocom_6">U-boot[l6] </rich_text><rich_text>的启动过程，大致上可以分成两个阶段：第一阶段，汇编代码；第二阶段，c代码。
       
3.1 第一阶段
       U-boot的第一条指令从cpu/arm920t/start.S文件开始，第一阶段主要做了如下事情：
       
       1. 设置CPU进入SVC模式(系统管理模式)，cpsr[4:0]=0xd3。
       2. 关中断，INTMSK=0xFFFFFFFF, INTSUBMSK=0x3FF。
       3. 关看门狗，WTCON=0x0。
4. 调用s3c2410_cache_flush_all函数，使TLBS，I、D Cache，WB中数据失效。
5. 时钟设置CLKDIVN=0x3 , FCLK:HCLK:PCLK = 1:2:4。
6. 读取mp15的c1寄存器，将最高两位改成11，表示选择了异步时钟模型。
7. 检查系统的复位状态，以确定是不是从睡眠唤醒。
8.  ldr r0,_TEXT_BASE
    adr r1,_start
    cmp r0,r1
    blne cpu_init_crit
    根据这几条语句来判断系统是从nand启动的还是直接将程序下载到SDRAM中运行
的，这里涉及到</rich_text><rich_text link="webs http://blog.csdn.net/lizhiguo0532/article/details/7017503#_msocom_7">运行时域[l7] </rich_text><rich_text>和 位置无关代码的概念，ldr  r0,_TEXT_BASE的作用是将board/nextdvr2410/config.mk文件中定义的TEXT_BASE值 （0x33f80000）装载到r0中，adr  r1,_start该指令是条伪指令，在编译的时候会被转换成ADD或SUB指令根据当前pc值计算出_start标号的地址，这样的话就可以知道当前程 序在什么地址运行（位置无关代码：做成程序的所有指令都是相对寻址的指令，包括跳转指令等，这样代码就可以不在链接所指定的地址上运行）。在上电之后，系 统从nand启动，这里得到r0和r1值是不一样的，r0=0x33f80000，而r1=0x00000000。所以接下来会执行 cpu_init_crit函数。
 
9. cpu_init_crit函数，主要完成了两个工作：首先使ICache and Dcache，TLBs中早期内容失效，再设置p15  control register c1，关闭MMU，Dcache，但是打开了Icache和Fault  checking，（要求mmu和Dcache是必须要关闭的，而Icache可以打开可以关闭）；其次调用/board/nextdvr2410 /memsetup.S文件中的memsetup函数来建立对SDRAM的访问时序。
 
10. Relocate函数，加载nand flash中的uboot到SDRAM中，代码会加载到0x33f80000开始的地址，空间大小是512。
1). ndf2ram函数
a.  设置NFCONF，使能2410的nand 控制器，初始化ECC，disable chip等
b.  enable chip，复位chip，读nand状态，判断是否busy，空闲的话再次disable chip；
c.  为调用c函数准备堆栈空间，这里的堆栈是放在uboot代码在SDRAM空间的最后位置armboot_end开始的128KB地址处（包含3 words for abort-stack，实际的SP位置是128*1024-12B处）。
d.  调用c函数copy_uboot_to_ram():nandll_reset()  设置NFCONF（新增设置了时间参数，其余设置和前面一样），复位nand  flash；nandll_read_blocks(),传递了3个参数给它，0x33f80000,0x0,  9*NAND_BLOCK_SIZE.这里在读的过程中检查每个块的坏块标志，如果是坏块，则跳过不读。详情不叙，请看uboot的注释。该部分的c代码 在cpu/arm920t/Nand_cp.c文件中
e.  ok_nand_read函数：读取SDRAM的前4k内容和SRAM的4K内容进行比较，只要出现不一样的地方就会进入死循环状态，目的就是为了确保转移代码的正确性。
f.  跳回到调用ndf2ram函数处继续执行

2). ldr pc, _start_armboot
    _start_armboot: .word start_armboot
    这里将会进入第二阶段的c代码部分：start_armboot()函数，/lib_arm/board.c。
 
3.2 第二阶段
    第二阶段从文件/lib_arm/board.c的start_armboot()函数开始。
    
1.     定义一个struct global_data结构体指针gd，struct global_data结构体对象gd_data，
    定义一个struct bd_info结构体对象bd_data，
    定义一个指向函数的二级指针init_fnc_ptr，
    定义的全局结构体对象都是放在堆栈中的,gd是放在寄存器中的。
2.     gd=&amp;gd_data，gd-&gt;bd = &amp;bd_data，并且全部空间清0。
3.     init_fnc_ptr = init_sequence(一个初始化函数指针数组)。将会在接下来的for循环中提取出每一个函数来依次执行完。
init_fnc_t *init_sequence[] = {
    cpu_init,       /* 基本的处理器相关配置 -- cpu/arm920t/cpu.c */
    board_init,         
/* 基本的板级相关配置 -- board/nextdvr2410/nextdvr2410.c */
    interrupt_init,/* 初始化中断处理 -- cpu/arm920t/interrupt.c */
    env_init,       /* 初始化环境变量 -- common/env_flash.c */
    init_baudrate,  /* 初始化波特率设置 -- lib_arm/board.c */
    serial_init,    /* 串口通讯设置 -- cpu/arm920t/serial.c */
    console_init_f,/* 控制台初始化阶段1 -- common/console.c */
    display_banner,/* 打印u-boot信息 -- lib_arm/board.c */
    dram_init,  /* 配置可用的RAM -- board/nextdvr2410/nextdvr2410.c */
    display_dram_config,/* 显示RAM的配置大小 -- lib_arm/board.c */
#if defined(CONFIG_VCMA9)
         checkboard,     /* display board info */
#endif
    NULL,
};

cpu_init：根据需要设定IRQ，FIR堆栈。如果使用中断的话，中断堆栈就接在后面。 
board_init：设置LOCKTIME，配置MPLL，UPLL，配置IO  ports，设置gd-&gt;bd-&gt;bi_arch_number（553），gd-&gt;bd-&gt;bi_boot_params =  0x30000100设置boot参数地址，使能Icache和Dcache。
interrupt_init：使用timer 4来作为系统clock， 即时钟滴答， 10ms一次，到点就产生一个中断，但由于此时中断还没打开所以这个中断不会响应。
env_init：该函数主要做关于环境变量的工作，这个环境变量可以不用存放在nor或者nand  flash上，直接在内存中生成(default_environment)。不过对于那些掉电需要保存的参数来说，保存在flash上无疑是最可靠的方 式。有的uboot还支持冗余存储，也就是存两份做备份。
        在env初始化的时候，是通过env_init—&gt;nandll_read_blocks将位于nand第9块上的环境变量（16K）全部读入到0x33ef0000这个起始地址中来，在接下来将堆空间分配好之后，在函数env_relocate中，通过 在堆中获得一块区域来存放环境变量，env_ptr指向这块区域，接下来所谓的重新获得环境变量无非就是将原来0x33ef0000开始的16K数据拷贝 到env_ptr所指的区域中去。这里分第一次uboot启动（泛指只要在第一次运行saveenv指令之前所启动的uboot过程）和保存过环境变量的 情况，但实质是一样的，所不同的是，第一次uboot启动，nand第9块区域中的数据肯定不是什么环境变量，所以这是的crc校验肯定出错，所以这时系 统使用了默认的环境变量，但是只要这个默认的环境变量没有写到nand中(运行saveenv)的话，uboot的每次启动都被认为是第一次启动。而保存 过环境变量之后的话，在执行env_init的时候，就是从nand中读出了实际存在的环境变量参数，至于修不修改环境变量，保不保存，都没有上面的那种 情况出现了。
 
    init_baudrate：第一次启动uboot的时候，采用nextdvr2410nand.h中定义的115200默认波特率，后面的启动如果说在参数里设置了新的波特率的话就会用新的波特率来初始化。    
    display_banner：打印uboot的一些信息，版本信息：NC-Boot 1.5 日期-时间 ，coed范围，bss开始地址，IRQ、FIR堆栈地址。
    dram_init: gd-&gt;bd-&gt;bi_dram[0].start = PHYS_SDRAM_1;
    
    gd-&gt;bd-&gt;bi_dram[0].size  = PHYS_SDRAM_1_SIZE;设置板级数据中
    的SDRAM开始地址和大小
    display_dram_config：打印SDRAM的配置信息，如下：
                    …
    RAM Configuration:
    Bank#0: 30000000 64 MB
    …
    Checkboard: NULL
 
4.     配置可用的flash空间，并且打印出相关信息，flash_init()和display_flash_config()。
 
5.     mem_malloc_init()函数,分配堆空间
    CFG_MALLOC_LEN = 16K(CFG_ENV_SIZE)+128K
    mem_malloc_start = _armboot_start(0x33f80000)- CFG_MALLOC_LEN
    mem_malloc_end = _armboot_start(0x33f80000)
 
6.     env_relocate该函数的作用是将0x33ef0000开始16K的环境参数拷贝到堆空间中去。
 
7.    gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr  (&quot;ipaddr&quot;)通过这中方式获得环境变量列表中的ipaddr参数（开发板ip），获得环境变量中的MAC地址，设置到 gd-&gt;bd-&gt;bi_enetaddr[reg]中。
8.     devices_init函数，创建了devlist，但是只有一个串口设备注册在内。
9.     console_init_r函数：控制台完全初始化，此后可以使用函数serial_getc和serial_putc或者putc和getc来输出log。
 
10.  使能中断，如果有网卡设备，设置网卡MAC和IP地址。
 
11.  main_loop ()；定义于common/main.c。到此所有的初始化工作已经完成，main_loop在标准输入设备中接受命令，然后分析，查找和执行。
去掉所有无关紧要的宏和代码，main_loop()函数如下：
void main_loop()
{
    static char lastcommand[CFG_CBSIZE] = { 0, };
    int len;
    int rc = 1;
    int flag;
    char *s;
    int bootdelay;
 
    s = getenv (&quot;bootdelay&quot;);   //自动启动内核等待延时
    bootdelay = 
        s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
     
    s = getenv (&quot;bootcmd&quot;);  //取得环境中设置的启动命令行    
    if (bootdelay &gt;= 0 &amp;&amp; s &amp;&amp; !abortboot (bootdelay)){
        run_command (s, 0);
        //执行启动命令行,smdk2410.h中没有定义CONFIG_BOOTCOMMAND，所以没有命令执行。
    }
    
    for (;;) {
        len = readline(CFG_PROMPT);
        //读取键入的命令行到console_buffer
         
         flag = 0;       /* assume no special flags for now */
         if (len &gt; 0)
             strcpy (lastcommand, console_buffer);
            //拷贝命令行到lastcommand.
         else if (len == 0)
             flag |= CMD_FLAG_REPEAT;
             if (len == -1)
             puts (&quot;\n&quot;);
         else
             rc = run_command (lastcommand, flag);　//执行这个命令行。
   
     if (rc &lt;= 0) {
      /* invalid command or not repeatable, forget it */
      lastcommand[0] = 0;
    }
}
12.  在上面的main_loop函数中，通常在开发完成的阶段都会设置一个bootcmd的环境
变量，然后将延时bootdelay设置成0，这样当u-boot跑到这里的时候就不会因为用户按下了任意键就进入了命令行模式，可以直接运行 bootcmd的命令来直接加载kernel的Image然后移交控制权。如果进入了命令行模式，我们也可以手动输入命令来启动系统，输入的命令也是基本 和bootcmd一样。
 
不过值得一提的是，从这里开始到引导内核的函数do_bootimg_linux()之前，不同
厂商之间做的都和原始的U-boot代码差别挺大，不过万变不离其宗，都是加载各种各样的Image到SDRAM中，不过关于CP部分的Image 有的厂商是在这里加载，有的是kernel起来后来有kernel来加载，不过都需要加载的Image就是linux  kernel的Image。为了方便，只讨论加载kernel Image的情况。
    
    在继续往下之前，有必要提一下几种不同格式linux kernel编译之后所产生的镜像文件,包括其各种头和ramdisk的混合，容易让人迷糊。
    ramdisk是linux内核启动过程中需要使用的一种临时文件系统，它要么单独编译成ramdisk.img(也有叫initrd或者initramfs)，要么编译进内核。
     Linux编译之后最终会产生zImage文件，不过呢，为了迎合U-boot的要求，所以也有专门为U-boot的引导做一个uImage，这个只是加 了一个U-boot中定义的一个head而已，用于U-boot中检查，当然前面的ramdisk.img也是需要加这个头的，头里面有这个Image的 魔数，大小，类型等信息。现在的android中的u-boot也有要求加头的，他对U-boot进行了改进和优化，做成了自己的一套检查机制，所以现在 android编译出来linux部分的Image的名字叫boot.img。
    这个boot.img是zImage和ramdisk.img合成之后的，而且还加了专门的头，这个head和U-boot原始的不一样，具体的源码路径可以参考：system/core/mkbootimg/。
/*
** +-----------------+ 
** | boot header     | 1 page
** +-----------------+
** | kernel          | n pages  
** +-----------------+
** | ramdisk         | m pages  
** +-----------------+
** | second stage    | o pages
** +-----------------+
**
** n = (kernel_size + page_size - 1) / page_size
** m = (ramdisk_size + page_size - 1) / page_size
** o = (second_size + page_size - 1) / page_size
*/
Android就没有在ramdisk和zImage上单独重复加头了，不过近期做的mtk的平台，他们有点怪，除了上面的额外信息之外，还在这二者上单独加了标志字符串,ROOTFS和KERNEL。    
     了解了上面这些内容之后，对于从nand上加载uImage或者boot.img，都需要经过分离head进行检查，ok之后才会真正地将数据导入 SDRAM。另外别忘了的是，如果ramdisk.img是单独的，那么在加载linux  kernel的镜像的时候也需要将其加载进SDRAM，如果是编译到内核了，那就不用了。
    
    通常我们的uboot起来之后，我们会运行下面的命令之一来启动内核
tftp 0x30800000 uImage;bootm (地址可选)
或者
nand read 0x30800000 0x40000 0x200000 ; bootm
    
    例如informax的平台u-boot的bootcmd是：
    #define BOOTCMD 
&quot;mcu_clk 260;a7vector_SDRAM;dsp_clk 130;nand read 0x46000000 0x200000 0x400000;boot_from_flash boot&quot;
很明显，原始U-boot中没有boot_from_flash命令，是经过他们改造过的。不过功能基本一样。所以还是以bootm来引导uImage为例来讨论。
 
        bootm命令位于cmd_bootm.c文件中:
        U_BOOT_CMD(
            bootm,  CFG_MAXARGS,    1,  do_bootm,
            &quot;bootm   - boot application image from memory\n&quot;,
            &quot;[addr [arg ...]]\n    - boot application image stored in memory\n&quot;
            &quot;        passing arguments 'arg ...'; when booting a Linux kernel,\n&quot;
            &quot;        'arg' can be the address of an initrd image\n&quot;
);

在将nand上0x40000开始的2MB数据拷贝到SDRAM的0x30800000之后，就开始执行bootm命令，其所做的工作大致如下： 
12.1如果bootm命令没有带地址参数，将会采用默认地址0x30800000，带地址则保存下这个参数地址。
12.2 从SDRAM的0x30800000开始拷贝64字节到一个head结构体中进行crc32校验，校验ok之后将会调用调用函数print_image_hdr()打印出如下信息：
    Image Name:   Linux-2.6.8-rc2-nc-v1
    Created:      2010-05-04   4:14:19 UTC
    Image Type:   ARM Linux Kernel Image (uncompressed)
    Data Size:    1054712 Bytes =  1 MB
    Load Address: 30008000
    Entry Point:  30008000
 
12.3 跳过64字节的head，开始校验kernel的Image数据，校验码ok之后会打印：Verifying Checksum ... OK

12.4 核对cpu类型

12.5 检查Image的类型
 
12.6  禁止中断，检查内核的压缩类型，这里不是指的image和zImage的区别，而是有没有在这基础上进行ZIP或ZIP2的压缩。通常这里是没有这样的压缩的。所以接下来将0x30800000+64B开始的zImage数据搬运到ih_load（0x30008000）处，这个数据就是kernel的 Image数据。
 
12.7 根据head中OS的类型，如果是linux，head中类型值就是IH_OS_LINUX，所以接下来会执行u-boot到kernel的过渡程序。
do_bootm_linux (cmdtp, flag, argc, argv, addr, len_ptr, verify);
 
12.8定义thekernel函数指针，获取bootargs参数给commandline指针。
12.9 theKernel = (void (*)(int, int, uint))ntohl(hdr-&gt;ih_ep)，将内核的入口地址赋给thekernel函数指针。
12.10将传递给内核的参数放在0x30000100处，以tag的方式存放，主要放置了memory和cmdline的参数。
12.11关中断，关闭IDCache,同时使ID Cache数据失效。
12.12再次获取bi_arch_number参数为553。
12.13 theKernel (0, bd-&gt;bi_arch_number, bd-&gt;bi_boot_params)进入内核，第一个参数必须为0，第二个参数为机器类型553，第三个参数为传递给内核参数的其实地址0x30000100。
 
总结下，U-Boot调用内核之前，下面的条件必须满足：
a.  R0=0,R1为机器类型ID，参考linux/arch/arm/tools/mach-types,R2为启动参数tag列表在RAM中的基地址。
b.  CPU的工作模式必须为SVC模式,必须禁止中断（IRQS和FIRS）。
c.  数据cache和MMU必须关闭，指令cache可以打开也可以关闭。
 
这里移交控制权之后，u-boot的使命就算是完成了。说起来U-boot命运挺悲惨的，因为它重要而却最不受内核待见。接下来内核的启动更加复杂。
 </rich_text><table char_offset="862" col_max="400" col_min="40"><row><cell>Bootloader
</cell><cell>Monitor?
</cell><cell>描述
</cell><cell>X86
</cell><cell>ARM
</cell><cell>PowerPC
</cell></row><row><cell>U-boot
</cell><cell>是
</cell><cell>通用引导程序
</cell><cell>是
</cell><cell>是
</cell><cell>是
</cell></row><row><cell>RedBoot[l2] 
</cell><cell>是
</cell><cell>基于eCos的引导程序
</cell><cell>是
</cell><cell>是
</cell><cell>是
</cell></row><row><cell>BLOB[l3] 
</cell><cell>否
</cell><cell>(StrongARM构架)LART(主板)等硬件平台的引导程序
</cell><cell>否
</cell><cell>是
</cell><cell>否
</cell></row><row><cell>LILO
</cell><cell>否
</cell><cell>Linux磁盘引导程序
</cell><cell>是
</cell><cell>否
</cell><cell>否
</cell></row><row><cell>GRUB
</cell><cell>否
</cell><cell>GNU的LILO替代程序
</cell><cell>是
</cell><cell>否
</cell><cell>否
</cell></row><row><cell>Loadlin
</cell><cell>否
</cell><cell>从DOS引导Linux
</cell><cell>是
</cell><cell>否
</cell><cell>否
</cell></row><row><cell>Vivi
</cell><cell>是
</cell><cell>韩国mizi 公司开发的bootloader
</cell><cell>否
</cell><cell>是
</cell><cell>否
</cell></row><row><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell><cell>点击这里</cell></row></table><encoded_png char_offset="1920">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</encoded_png></node><node name="linux启动" prog_lang="custom-colors" readonly="False" tags="" unique_id="3"><rich_text scale="h1">第二部分：linux启动 </rich_text><rich_text>
</rich_text><rich_text scale="h2">一、zImage是怎样炼成的？</rich_text><rich_text>
    zImage是linux内核编译之后产生的最终文件，它的生成过程比较复杂，这里不谈编译过程，只聊聊编译的最后阶段：
    1.  arm-linux-gnu-ld用arch/arm/kernel/vmlinux.lds、arch/arm/kernel/head.o、
    arch/arm/kernel/init_task.o、各子目录下的built-in.o、lib/lib.a  、arch/arm/lib/lib.a生成顶层目录下的vmlinux （根据arch/arm/kernel/vmlinux.lds来链接  0xc0008000）
 
    2. 生成system.map, 置于顶层目录之下。
    3. arm-linux-gnu-objcopy，去掉顶层vmlinux两个段-R .note -R .comment
的调试信息，减小映像文件的大小，此时大概3M多，生成arch/arm/boot/Image。
 
    4. gzip -f -9 &lt; arch/arm/boot/compressed/../Image &gt;  arch/arm/boot/compressed/piggy.gz，读入arch/arm/boot/Image的内容，以最大压缩比进行压缩，生成 arch/arm/boot/compressed/目录下的piggy.gz。
 
    5. arm-linux-gnu-gcc，在arch/arm/boot/compressed/piggy.S文件中是直接引入piggy.gz的内容 （piggy.gz其实已经是二进制数据了），然后生成arch/arm/boot/compressed/piggy.o文件。下面是piggy.S的 内容
    其中所选择的行就是加入了piggy.gz的内容，通过编译生成piggy.o文件，以备后面接下来的ld链接。
 
    6.  arm-linux-gnu-ld，在arch/arm/boot/compressed/piggy.o的基础上，加入重定位地址和参数地址的同时，加 入解压缩的代码（arch/arm/boot/compressed/head.o、misc.o）,
    最后生成arch/arm/boot /compressed目录的vmlinux，此时在解压缩代码中还含有调试信息（根据arch/arm/boot/compressed /vmlinux.lds来链接 0x0）vmlinux.lds开始处。
    注意到了27行的吗？*(.piggydata)就表示需要将piggydata这个段放在这个位置，而piggydata这个段放的是什么呢？往后翻翻，看看第五步的图片，呵呵，其实就是将按最大压缩比压缩之后的Image，
    压缩之后叫piggy.gz中的二进制数据。
 
    7. arm-linux-gnu-objcopy，去掉解压缩代码中的调试信息段，最后生成arch/arm/boot/目录下的zImage。
    
    8. /bin/sh 
    /home/farsight/Resources/kernel/linux-2.6.14/scripts/mkuboot.sh -A  arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008000 -n  'Linux-2.6.14' -d arch/arm/boot/zImage arch/arm/boot/uImage
    调用mkimage在arch/arm/boot/zImage的基础上加入64字节的uImage头，和入口地址，装载地址， 最终生成arch/arm/boot/目录下的uImage文件。
        
    实际上zImage是经过了高压缩之后在和解压缩程序合并在一起生成的。知道了这些之后，我们就可以给linux的启动大致分成3段：zImage解压缩、kernel的汇编启动阶段、kernel的c启动阶段。
    前两个阶段因为都是汇编写成的，代码读起来晦涩难懂，内存分布复杂，涉及MMU、解压缩等众多知识。如果有对这部分感兴趣的，可以自行分析，遇到问题可以上网查资料或者找我，这里就不详细分析了。下面是第二阶段汇编启动的主线，可以了解下：
    1. 确定 processor type 
    2. 确定 machine type
    3. 手动创建页表  
    4. 调用平台特定的cpu setup函数,设置中断地址，刷新Cache，开启Cache 
                         (在struct proc_info_list中,in proc-arm920.S) 
    5. 开启mmu I、D cache ，设置cp15的控制寄存器，设置TTB寄存器为0x30004000
    6. 切换数据（根据需要赋值数据段，清bss段，保存processor ID 和 machine type 
        和 cp15的控制寄存器值）
    7. 最终跳转到start_kernel    
(在__switch_data的结束的时候,调用了 b start_kernel)
 
二、linux的c启动阶段
    经过解压缩和汇编启动两个阶段，将会进入init/Main.c中的start_kernel()函数去继续执行。(2.6.1x、2.6.2x和2.6.3x之间的差异比较大，下面的分析基于2.6.14)
    1. printk(linux_banner)打印内核的一些信息，版本，作者，编译器版本，日期等信息。
 
    2. 接下来执行是一个极其重要的函数setup_arch(),主要做一些板级初始化，cpu初始化，tag参数解析，u-boot传递的cmdline解析，建立mmu工作页表(memtable_init)，初始化内存布局， 调用 mmap_io建立GPIO,IRQ,MEMCTRL,UART，及其他外设的静态映射表，对时钟,定时器，uart进行初始化,  
    cpu_init(): {
        打印一些关于cpu的信息，比如cpu id，cache  大小等。
        另外重要的是设置了IRQ、ABT、UND三种模式的stack空间，分别都是12个字节。最后将系统切换到svc模式
    }。
 
    3. sched_init():初始化每个处理器的可运行队列，设置系统初始化进程即0号进程。
 
    4. 建立系统内存页区(zone)链表  build_all_zonelists()。
 
    5. printk(KERN_NOTICE &quot;Kernel command line: %s\n&quot;, saved_command_line);
    打印出从uboot传递过来的command_line字符串，在setup_arch函数中获得的。
 
    6.  parse_early_param()，这里分析的是系统能够辨别的一些早期参数（这个函数甚至可以去掉，__setup形式的参数），
    而且在分析的时候并不是以setup_arch(&amp;command_line)传出来的command_line为基础，而是以最原生态的 saved_command_line为基础的。
 
    7. parse_args(&quot;Booting kernel&quot;, command_line, __start___param,
                __stop___param - __start___param,
                &amp;unknown_bootoption);
    对于比较新的版本真正起作用的函数，与parse_early_param()相比，此处对解析列表的处理范围加大了，解析列表中除了包括系统以setup定义的启动参数，还包括模块中定义的param参数以及系统不能辨别的参数。
    __start___param是param参数的起始地址，在System.map文件中能看到
    __stop___param - __start___param是参数个数
    unknown_bootoption是对应与启动参数不是param的相应处理函数（查看parse_one()就知道怎么回事）。
 
    8. 在前面的setup_arch -&gt; paging_init -&gt; memtable_init函数中为系统创建页表的时候，中断向量表的虚地址init_maps,是用alloc_bootmem_low_pages分配的，
    ARM规定中断向量表的地址只能是0或0xFFFF0000，所以该函数里有部分代码的作用就是映射一个物理页到0或0xFFFF0000。
    trap_init函数做了以下的工作：
    把放在.Lcvectors处的系统8个意外入口跳转指令搬到高端中断向量0xffff0000处，再将__stubs_start到__stubs_end之间的各种意外初始化代码搬到0xffff0200处等。
 
    9. init_IRQ()
     初始化系统中所有的中断描述结构数组：irq_desc[NR_IRQS]。接着执行init_arch_irq函数，该函数是在setup_arch函 数最后初始化的一个全局函数指针，指向了smdk2410_init_irq函数（in  mach-smdk2410.c）,实际上是调用了   s3c24xx_init_irq函数。在该函数中，首先清除所有的中断未决标志，之后就初始化中断的 触发方式和屏蔽位，还有中断句柄初始化，这里不是最终用户的中断函数，而是do_level_IRQ或者do_edge_IRQ函数，在这两个函数中都使 用过__do_irq函数来找到真正最终驱动程序注册在系统中的中断处理函数。
 
    10. softirq_init():内核的软中断机制初始化函数。
 
    12.      console_init():
    初始化系统的控制台结构，该函数执行后调用printk函数将log_buf中所有符合打印级别的系统信息打印到控制台上。
 
    13. profile_init()函数
    /* 对系统剖析做相关初始化， 系统剖析用于系统调用*/
    //profile是用来对系统剖析的，在系统调试的时候有用
    //需要打开内核选项，并且在bootargs中有profile这一项才能开启这个功能/*
    profile只是内核的一个调试性能的工具，这个可以通过menuconfig中profiling support打开。
    
    14. vfs_caches_init()
    该函数主要完成的是文件系统相关的初始化，cache、inode等高速缓存的建立，在mnt_init()函数中有注册并初始化sysfs、rootfs文件系统，这里只是在内存中建立他们的架构，
    创建了超级块，并没有真正挂 载上去。关于这个rootfs需要说明的是，这个文件系统生命期更加短暂的，为什么？之前说的ramdisk大家是否还记得，ramdisk即将在后面释放到内存空间，
    来代替这里的rootfs出现在根目录之下，而这个rootfs则退居二线，隐藏在一个二级目录中。本来在非android的系统上，这个 ramdisk也是一个暂时的文件系统，
    之后也会被真正的yaffs2之类的文件系统替换。不过呢，在android上，这个ramdisk还是挂载在根 目录下的，只是将system、userdata等真实文件系统挂载了对应的二级目录下。
        
     关于这部分ramdisk内容，有兴趣的下来可以继续探讨。
        
    15.      mem_init():
    最后内存初始化，释放前边标志为保留的所有页面,这个函数结束之后就不能再使
    用alloc_bootmem(),alloc_bootmem_low(),alloc_bootmem_pages()等申请低端内存的函数来申请内存，也就不能申请大块的连续物理内存了。
    
    16.     中间还省略了很多内容，涉及到很多东西，这里也没有时间详细讨论，有兴趣的自
    己研究代码吧！下面直接跳到start_kernel()函数的最后的一个重要函数:rest_init()。
    
    17.     rest_init函数创建了两个线程之后，自己调用cpu_idle()函数隐退了。
    创建的第一个线程，习惯上我们将其叫做1号内核线程，第二个线程叫2号内核线程，因为创建它们的父进程叫0号启动进程。
    说明一下：2.6.14的内核这里只创建了一个内核线程叫init线程，而上面创建两
    个线程的内核版本至少都是2.6.2x了，所以为了后面能和android的启动接上，所以这里开始linux转到2.2.29去。
 
    static noinline void __init_refok rest_init(void) __releases(kernel_lock)
    {
        int pid;
         
        …
        kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
        pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
        kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);
        …
        cpu_idle();
    }
    kthreadd这个线程之前的部门交流会上讨论过，新版本的linux将线程创建这个艰巨的工作专门交给了这个叫kthreadd的线程来完成。
    接下来既然0号启动进程idle了，那么剩下的工作就都转移到线程kernel_init中去了。
 
    18. kernel_init()
    这个线程的任务还是比较艰巨的，第一个重要任务就是调用函数do_basic_setup()，先调用driver_init()来构建sysfs的目录架构，然后调用do_initcalls()函数来一次执行linux编译时设置的系统函数。
     这里主要工作就是注册系统设备的驱动程序，关于driver和device的注册顺序，是可以互相交换，
    例如 
        通常的三星平台都有一个struct machine_desc结构体来描述平台相关的启动代码：
        MACHINE_START(SMDK2410, &quot;SMDK2410&quot;) /* @TODO: request a new identifier and switch
                    * to SMDK2410 */
        /* Maintainer: Jonas Dietsche */
        .phys_io    = S3C2410_PA_UART,
        .io_pg_offst    = (((u32)S3C24XX_VA_UART) &gt;&gt; 18) &amp; 0xfffc,
        .boot_params    = S3C2410_SDRAM_PA + 0x100,
        .map_io     = smdk2410_map_io,
        .init_irq   = s3c24xx_init_irq,
        .init_machine   = smdk2410_init,
        .timer      = &amp;s3c24xx_timer,
        MACHINE_END
    所有devices的注册都是在smdk2410_init()函数中调用函数：
    platform_add_devices(smdk2410_devices, ARRAY_SIZE(smdk2410_devices));
    来完成，所以drivers的注册就放在后面了。不过这样注册是有一个坏处的，就是不能准确地控制driver代码中probe的执行先后顺序。
    现在mtk平台上的devices和drivers注册顺序想法，也就是先注册上drivers，然后再注册devices，这样的话，就可以控制probe函数的执行先后。
    
    include/linux/init.h文件中有这些优先级的定义：
    #define pure_initcall(fn)        __define_initcall(&quot;0&quot;,fn,0)
     
    #define core_initcall(fn)        __define_initcall(&quot;1&quot;,fn,1)
    #define core_initcall_sync(fn)       __define_initcall(&quot;1s&quot;,fn,1s)
    #define postcore_initcall(fn)        __define_initcall(&quot;2&quot;,fn,2)
    #define postcore_initcall_sync(fn)   __define_initcall(&quot;2s&quot;,fn,2s)
    #define arch_initcall(fn)        __define_initcall(&quot;3&quot;,fn,3)
    #define arch_initcall_sync(fn)       __define_initcall(&quot;3s&quot;,fn,3s)
    #define subsys_initcall(fn)      __define_initcall(&quot;4&quot;,fn,4)
    #define subsys_initcall_sync(fn) __define_initcall(&quot;4s&quot;,fn,4s)
    #define fs_initcall(fn)          __define_initcall(&quot;5&quot;,fn,5)
    #define fs_initcall_sync(fn)     __define_initcall(&quot;5s&quot;,fn,5s)
    #define rootfs_initcall(fn)      __define_initcall(&quot;rootfs&quot;,fn,rootfs)
    #define device_initcall(fn)      __define_initcall(&quot;6&quot;,fn,6)
    #define device_initcall_sync(fn) __define_initcall(&quot;6s&quot;,fn,6s)
    #define late_initcall(fn)        __define_initcall(&quot;7&quot;,fn,7)
    #define late_initcall_sync(fn)       __define_initcall(&quot;7s&quot;,fn,7s)
    当然函数的执行属性从1~7，通常我们见到的设备都是6、7级的。另外系统中所有的initcalll函数都是可以从linux根目录下的system.map中查看得到。
 
    接下来的一段代码就是来释放前面提到的ramdisk.img的：
    if (!ramdisk_execute_command)
         ramdisk_execute_command = &quot;/init&quot;;
     
    if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
         ramdisk_execute_command = NULL;
         prepare_namespace();
    }
    释放出来的ramdisk呈现出来的目录就是android编译出来之后，在out/…/root的目录一样了，这个目录下有一个init可执行程序，下面就准备启动它。
     
    接着调用init_post()函数，来打开console设备，这个时候我们的控制台就可以操作了，最后会执行以下代码来寻找和启动init程序：
    if (execute_command) {
         run_init_process(execute_command);
         printk(KERN_WARNING &quot;Failed to execute %s.  Attempting &quot;
                     &quot;defaults...\n&quot;, execute_command);
    }
    run_init_process(&quot;/sbin/init&quot;);
    run_init_process(&quot;/etc/init&quot;);
    run_init_process(&quot;/bin/init&quot;);
    run_init_process(&quot;/bin/sh&quot;);
     
    panic(&quot;No init found.  Try passing init= option to kernel.&quot;);
     
    这里执行的init程序需要我们在u-boot传给kernel的cmdline中使用init=/init
    来告知kernel，或者kernel启动代码中直接写死。否则在上面的那些目录中找不到init的话，系统就用panic机制将这个警告信息保存在nand的panic分区，在下次启动的时候，会自动将这个分区的信息输出。
     
    init进程是linux起来之后启动的第一个用户进程，android系统也就是在这个进
    程的基础上启动的。进程号是1。
</rich_text></node></node><node name="bus register" prog_lang="custom-colors" readonly="False" tags="" unique_id="4"><rich_text>    上面分析了kobject.kset,ktype.这三个结构联合起来一起构成了整个设备模型的基石.而bus.device.device_driver.则是基于kobject.kset.ktype之上的架构.
    在这里,总线,设备,驱动被有序的组和在一起.Bus.device.device_driver三者之间的关系如下图所示: 如上图所示.
      struct bus_type的p-&gt;drivers_kset(struct kset)指向注册在上面的驱动程序.它的p-&gt;device_kset(struct kset)上挂着注册在上面的设备.
    每次有一个新的设备注册到上面,都会去匹配右边的驱动,看是否能匹配上.如果匹配成功,则将设备结构的is_registerd域置为0.然后将设备添加到驱动的p-&gt;klist_devices域.
    同理,每注册一个驱动,都会去匹配左边的设备,.如果匹配成功,将则设备加到驱动的p-&gt;klist_devices域.再将设备的is_registerd置为0/这就是linux设备模型用来管理设备和驱动的基本架构. 我们来跟踪一下代码来看下详细的操作. 
    注册一个总线的接口为bus_register().我们照例分段分析: 
    int bus_register(struct bus_type *bus){     
        int retval;     struct bus_type_private *priv;     //分配存储空间
             
        priv = kzalloc(sizeof(struct bus_type_private), GFP_KERNEL);    
        if (!priv)         
            return -ENOMEM;      
            
        priv-&gt;bus = bus;     
        bus-&gt;p = priv;      
        BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier); 
             
        retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, &quot;%s&quot;, bus-&gt;name);     
        if (retval)         
            goto out;      
            
        priv-&gt;subsys.kobj.kset = bus_kset;                          
        priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;    
        priv-&gt;drivers_autoprobe = 1;      
        retval = kset_register(&amp;priv-&gt;subsys);     
        if (retval)         
            goto out;
            
     首先,先为struct bus_type的私有区分配空间,然后将其和struct bus_type关联起来.由于struct bus_type也要在sysfs文件中表示一个节点,因此,它也内嵌也一个kset的结构.这就是priv-&gt;subsys.
     首先,它为这个kset的名称赋值为bus的名称,然后将priv-&gt;subsys.kobj.kset指向bus_kset. priv-&gt;subsys.kobj.ktype指向bus_ktype;然后调用kset_reqister()将priv-&gt;subsys注册.这里涉及到的接口都在之前分析过.注册过后,应该会在bus_kset所表示的目录下创建一个总线名称的目录.并且用户空间的hotplug应该会检测到一个add事件.我们来看一下bus_kset到底指向的是什么:     
     bus_kset = kset_create_and_add(&quot;bus&quot;, &amp;bus_uevent_ops, NULL);
   从此可以看出.这个bus_kset在sysfs中的结点就是/sys/bus.在这里注册的struct bus_types就会在/sys/bus/下面出现.      
    retval = bus_create_file(bus, &amp;bus_attr_uevent);     
    if (retval)         
        goto bus_uevent_fail;
        
    bus_create_file()就是在priv-&gt;subsys.kobj的这个kobject上建立一个普通属性的文件.这个文件的属性对应在bus_attr_uevent.
   读写操作对应在priv-&gt;subsys.kobj.ktype中.我们到后面才统一分析bus注册时候的文件创建      
    priv-&gt;devices_kset = kset_create_and_add(&quot;devices&quot;, NULL, 
                                &amp;priv-&gt;subsys.kobj);     
    if (!priv-&gt;devices_kset) {         
        retval = -ENOMEM;         
        goto bus_devices_fail;     
    }
          
    priv-&gt;drivers_kset = kset_create_and_add(&quot;drivers&quot;, NULL, 
                                &amp;priv-&gt;subsys.kobj); 
    if (!priv-&gt;drivers_kset) {         
        retval = -ENOMEM;         
        goto bus_drivers_fail;     
    }
          
    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put); 
    klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);
   这段代码会在bus所在的目录下建立两个目录,分别为devices和drivers.并初始化挂载设备和驱动的链表      
    retval = add_probe_files(bus);     
    if (retval)         
        goto bus_probe_files_fail;
        
    retval = bus_add_attrs(bus);     
    if (retval)         
        goto bus_attrs_fail;      
        
    pr_debug(&quot;bus: '%s': registered/n&quot;, bus-&gt;name);     
    
    return 0;
    
   在这里,会为bus_attr_drivers_probe, bus_attr_drivers_autoprobe.注册bus_type中的属性建立文件 
    bus_attrs_fail:     
        remove_probe_files(bus);
    bus_probe_files_fail:     
        kset_unregister(bus-&gt;p-&gt;drivers_kset);
    bus_drivers_fail:     
        kset_unregister(bus-&gt;p-&gt;devices_kset);
    bus_devices_fail:     
        bus_remove_file(bus, &amp;bus_attr_uevent);
    bus_uevent_fail:     
        kset_unregister(&amp;bus-&gt;p-&gt;subsys);     
        kfree(bus-&gt;p);
    out:     
    return retval;
}
    这段代码为出错处理; 
    struct kset *kset_create_and_add(const char *name,  struct kset_uevent_ops *uevent_ops, 
                                                             struct kobject *parent_kobj){     
        struct kset *kset;     
        int error;
             
     //创建一个kset     
        kset = kset_create(name, uevent_ops, parent_kobj);     
        if (!kset)         
            return NULL;
                 
      //注册kset     
        error = kset_register(kset);     
        if (error) {        
         //如果注册失败,释放kset         
            kfree(kset);         
            return NULL;     
        }     
        
        return kset;
        }
         
        kset_create()用来创建一个struct kset结构.代码如下:
        static struct kset *kset_create(const char *name,                   
                                    struct kset_uevent_ops *uevent_ops,                   
                                    struct kobject *parent_kobj) {     
                                    struct kset *kset;      
                                    
            kset = kzalloc(sizeof(*kset), GFP_KERNEL);     
            if (!kset)         
                return NULL;
                     
            kobject_set_name(&amp;kset-&gt;kobj, name);     
            kset-&gt;uevent_ops = uevent_ops;     
            kset-&gt;kobj.parent = parent_kobj;      
            kset-&gt;kobj.ktype = &amp;kset_ktype;     
            kset-&gt;kobj.kset = NULL;      
            return kset;
        }
        
     我们注意,在这里创建kset时.为其内嵌的kobject指定其struct kobj_type ktype结构为kset_ktype.这个结构的定义如下:
        static struct kobj_type kset_ktype = {     
                .sysfs_ops    = &amp;kobj_sysfs_ops,
                .release = kset_release,
        };
        
      属性文件的读写操作全部都包含在sysfs_ops成员里.kobj_sysfs_ops的定义如下:
      struct sysfs_ops kobj_sysfs_ops = {     
            .show    = kobj_attr_show,     
            .store   = kobj_attr_store,
     }; 
     
     创建好了kset之后,会调用kset_register().这个函数就是kset操作的核心代码了.如下:
     int kset_register(struct kset *k) {     
        int err;
              
        if (!k)         
            return -EINVAL;
                  
        kset_init(k);     
        err = kobject_add_internal(&amp;k-&gt;kobj);     
        if (err)         
            return err;
                 
       kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD);     
       return 0;
    }
     
    void kset_init(struct kset *k)
    {
        kobject_init_internal(&amp;k-&gt;kobj);             //只是对kobj中的成员变量做一些赋值的初始化
        INIT_LIST_HEAD(&amp;k-&gt;list);
        spin_lock_init(&amp;k-&gt;list_lock);
    }  
    
    static int kobject_add_internal(struct kobject *kobj) {     
        int error = 0;     
        struct kobject *parent;
              
        if (!kobj)         
            return -ENOENT;     //如果kobject的名字为空.退出
                 
        if (!kobj-&gt;name || !kobj-&gt;name[0]) {         
            pr_debug(&quot;kobject: (%p): attempted to be registered with empty &quot;               &quot;name!/n&quot;, kobj);         
            WARN_ON(1);         
            return -EINVAL;     
      }
           
    //取kobject的父结点     
    parent = kobject_get(kobj-&gt;parent);
         
   //如果kobject的父结点没有指定，就将kset-&gt;kobject做为它的父结点     
    /* join kset if set, use it as parent if we do not already have one */     
    if (kobj-&gt;kset) {         
        if (!parent)              
            parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);         
        kobj_kset_join(kobj);         
        kobj-&gt;parent = parent;     
    }     
   //调试用     
    pr_debug(&quot;kobject: '%s' (%p): %s: parent: '%s', set: '%s'/n&quot;,          kobject_name(kobj), kobj, __FUNCTION__,          parent ? kobject_name(parent) : &quot;&lt;NULL&gt;&quot;,          kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : &quot;&lt;NULL&gt;&quot;);      
   //在sysfs中创建kobject的相关元素     
   error = create_dir(kobj);                              
   if (error) {         
        //v如果创建失败。减少相关的引用计数         
        kobj_kset_leave(kobj);         
        kobject_put(parent);         
        kobj-&gt;parent = NULL;          /* be noisy on error issues */         
        if (error == -EEXIST)              
            printk(KERN_ERR &quot;%s failed for %s with &quot;
                                    &quot;-EEXIST, don't try to register things with &quot;
                                    &quot;the same name in the same directory./n&quot;,                     __FUNCTION__, kobject_name(kobj));
        else              
            printk(KERN_ERR &quot;%s failed for %s (%d)/n&quot;,
                                 __FUNCTION__, kobject_name(kobj), error);         
            dump_stack();     
    } else         
     //如果创建成功。将state_in_sysfs建为1。表示该object已经在sysfs中了         
        kobj-&gt;state_in_sysfs = 1;      
     return error;
  } 
 这段代码比较简单，它主要完成kobject父结点的判断和选定，然后再调用create_dir（）在sysfs创建相关信息。该函数代码如下：
  static int create_dir(struct kobject *kobj) {     
    int error = 0;     
    
    if (kobject_name(kobj)) {          
      //为kobject创建目录         
      error = sysfs_create_dir(kobj);         
      if (!error) {              
      //为kobject-&gt;ktype中的属性创建文件              
        error = populate_dir(kobj);              
        if (error)                   
            sysfs_remove_dir(kobj);         
    }     
 }     
 
 return error;
 } 
 
 int sysfs_create_dir(struct kobject * kobj){     
    struct sysfs_dirent *parent_sd, *sd;     
    int error = 0;      
    
    BUG_ON(!kobj);     /*如果kobject的parnet存在。就在目录点的目录下创建这个目录。如果没有父结点不存在，就在/sys下面创建结点。*/     
    if (kobj-&gt;parent)         
        parent_sd = kobj-&gt;parent-&gt;sd;     
    else         
        parent_sd = &amp;sysfs_root;      //在sysfs中创建目录     
     //create_dir（）就是在sysfs中创建目录的接口，在之前已经详细分析过了     
     error = create_dir(kobj, parent_sd, kobject_name(kobj), &amp;sd);     
     if (!error)         
        kobj-&gt;sd = sd;     
     return error;
  }
  接着看为kobject-&gt;ktype中的属性创建文件。这是在populate_dir（）中完成的。代码如下：
  static int populate_dir(struct kobject *kobj){     
    struct kobj_type *t = get_ktype(kobj);     
    struct attribute *attr;     
    int error = 0;     
    int i;      
    
    if (t &amp;&amp; t-&gt;default_attrs) {         
        for (i = 0; (attr = t-&gt;default_attrs[i]) != NULL; i++) {              
            error = sysfs_create_file(kobj, attr);              
            if (error)                   
                break;         
        }     
    }
         
    return error;
 }
 这段代码比较简单。它遍历ktype中的属性。然后为其建立文件。请注意：文件的操作最后都会回溯到ktype-&gt;sysfs_ops的show和store这两个函数中.假如对于上面的bus_register()函数传入的参数为：
 struct bus_type ldd_bus_type = {
        .name = &quot;ldd&quot;,
        .match = ldd_match,
        .hotplug  = ldd_hotplug,
};
则通过bus_register()函数调用后，在/sys/bus/目录下出现的框图大概是这样的：。。。。在kset_init()里会初始化kset中的其它字段.然后调用kobject_add_internal()为其内嵌的kobject结构建立空间层次结构.
之后因为添加了kset.会产生一个事件.这个事件是通过用户空间的hotplug程序处理的.这就是kset明显不同于kobject的地方.</rich_text></node><node name="device register" prog_lang="custom-colors" readonly="False" tags="" unique_id="5"><rich_text>    这篇文章也是从别的地方转载的，我的目的是搞清楚：当调用device_register()函数向系统注册一个设备的时候，我注册进去的设备是如何和他 父设备关联起来的，以及如何加入到他所在的总线设备中的，但针对这个问题，好像通过这篇文章了解的并不透彻。但具体到代码分析的最后关于设备和驱动是如何 绑定的，这并不是我这篇文章的重点，但大概看了一下，有点类型i2c总线上设备和驱动的匹配过程。
看下图：
 
</rich_text><rich_text justification="left"></rich_text><rich_text>
在分析程序的过程中看到了把kobj-&gt;kset赋值为(kset)device_kset(即图中黑线实现的部分),但没有看到什么时候把 dev-&gt;kobj-&gt;parent赋值为device_kset-&gt;kobj(图中的红线实现的部分)，在调用函数 setup_parent()中是对dev-&gt;kobject-&gt;parent赋值了，但不明白在setup_parent()函数中是怎么 找到device_kset的。说实在话，对setup_parent()函数不明白，也没分析清楚。（在此补充一下，分析了一下 setup_parent()函数，实现了红线的部分）
 
这篇文章将那个3个注册函数说说，把整个设备模型框架搭建起来，当然，是重点部分了。在这之前希望你已经懂得总线、设备、驱动的数据结构及其里面的有关数据结构。关于调用的函数，如果显示为粗体，那么在下面我有分析。
 
转载于：</rich_text><rich_text link="webs http://student.csdn.net/space.php?uid=111596&amp;do=blog&amp;id=56043">http://student.csdn.net/space.php?uid=111596&amp;do=blog&amp;id=56043</rich_text><rich_text>

来自：drivers/base/core.c
int device_register(struct device *dev)
{
    device_initialize(dev);                 //初始化设备
    return device_add(dev);              //添加设备
}

void device_initialize(struct device *dev)
{
    //图中的黑线实现部分的代码
    dev-&gt;kobj.kset = devices_kset;                //设置设备的kobject所属集合，devices_kset其实在第一层，sys/devices/
    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);       //初始化设备的kobject
    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);           //初始化设备的DMA池，用于传递大数据
    mutex_init(&amp;dev-&gt;mutex);                              //初始化互斥锁
    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);
    spin_lock_init(&amp;dev-&gt;devres_lock);               //初始化自旋锁，用于同步子设备链表
    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);         //初始化子设备链表头
    device_pm_init(dev);
    set_dev_node(dev, -1);
}

int device_add(struct device *dev)
{
    struct device *parent = NULL;
    struct class_interface *class_intf;
    int error = -EINVAL;

    dev = get_device(dev);         //增加设备的kobject的引用计数
    if (!dev)
        goto done;

    if (!dev-&gt;p) {                  
        error = device_private_init(dev);             //初始化设备的私有成员
        if (error)
            goto done;
    }

    /*
     * for statically allocated devices, which should all be converted
     * some day, we need to initialize the name. We prevent reading back
     * the name, and force the use of dev_name()
     */
    if (dev-&gt;init_name) {
        dev_set_name(dev, &quot;%s&quot;, dev-&gt;init_name);         //设置设备kobject的名称
        dev-&gt;init_name = NULL;
    }

    if (!dev_name(dev)) {
        error = -EINVAL;
        goto name_error;
    }

    pr_debug(&quot;device: '%s': %s/n&quot;, dev_name(dev), __func__);

    parent = get_device(dev-&gt;parent);         //增加父设备kobject的引用
    setup_parent(dev, parent);                    //设置该设备kobject父对象（父对象是谁呢）

    /* use parent numa_node */
    if (parent)
        set_dev_node(dev, dev_to_node(parent));

    /* first, register with generic layer. */
    /* we require the name to be set before, and pass NULL */
    error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);          //将设备kobject添加进父对象设备模型
    if (error)
        goto Error;

    /* notify platform of device entry */
    if (platform_notify)
        platform_notify(dev);

    error = device_create_file(dev, &amp;uevent_attr);
    if (error)
        goto attrError;

    if (MAJOR(dev-&gt;devt)) {
        error = device_create_file(dev, &amp;devt_attr);
        if (error)
            goto ueventattrError;

        error = device_create_sys_dev_entry(dev);
        if (error)
            goto devtattrError;

        devtmpfs_create_node(dev);
    }

    error = device_add_class_symlinks(dev);
    if (error)
        goto SymlinkError;
    error = device_add_attrs(dev);
    if (error)
        goto AttrsError;
   调用bus_add_device在sysfs中添加两个链接：一个在总线目录下指向设备，另一个在设备的目录下指向总线子系统。
    error = bus_add_device(dev);          //将设备添加进总线中
    if (error)
        goto BusError;
    error = dpm_sysfs_add(dev);
    if (error)
        goto DPMError;
    device_pm_add(dev);

    /* Notify clients of device addition.  This call must come
     * after dpm_sysf_add() and before kobject_uevent().
     */
    if (dev-&gt;bus)
        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
                         BUS_NOTIFY_ADD_DEVICE, dev);

    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);
    bus_probe_device试图自动探测设备。如果能够找到合适的驱动程序，则将设备添加到bus-&gt;klist_devices.设备还需要添加到父结点的子结点链表中，图中蓝色线的实现部分（此前，设备知道其父结点，但父结点不知道子结点的存在）
    bus_probe_device(dev);                                       //现在该为设备在总线上寻找合适的驱动了
    if (parent)
        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,
                   &amp;parent-&gt;p-&gt;klist_children);                   //将设备添加到父设备的子设备链表中

    if (dev-&gt;class) {
        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;class_mutex);
        /* tie the class to the device */
        klist_add_tail(&amp;dev-&gt;knode_class,
                   &amp;dev-&gt;class-&gt;p-&gt;class_devices);

        /* notify any interfaces that the device is here */
        list_for_each_entry(class_intf,
                    &amp;dev-&gt;class-&gt;p-&gt;class_interfaces, node)
            if (class_intf-&gt;add_dev)
                class_intf-&gt;add_dev(dev, class_intf);
        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;class_mutex);
    }
done:
    put_device(dev);
    return error;
 DPMError:
    bus_remove_device(dev);
 BusError:
    device_remove_attrs(dev);
 AttrsError:
    device_remove_class_symlinks(dev);
 SymlinkError:
    if (MAJOR(dev-&gt;devt))
        devtmpfs_delete_node(dev);
    if (MAJOR(dev-&gt;devt))
        device_remove_sys_dev_entry(dev);
 devtattrError:
    if (MAJOR(dev-&gt;devt))
        device_remove_file(dev, &amp;devt_attr);
 ueventattrError:
    device_remove_file(dev, &amp;uevent_attr);
 attrError:
    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);
    kobject_del(&amp;dev-&gt;kobj);
 Error:
    cleanup_device_parent(dev);
    if (parent)
        put_device(parent);
name_error:
    kfree(dev-&gt;p);
    dev-&gt;p = NULL;
    goto done;
}
 
int device_private_init(struct device *dev)
{
    dev-&gt;p = kzalloc(sizeof(*dev-&gt;p), GFP_KERNEL);
    if (!dev-&gt;p)
        return -ENOMEM;
    dev-&gt;p-&gt;device = dev;                                                //指向设备自己
    klist_init(&amp;dev-&gt;p-&gt;klist_children, klist_children_get,
           klist_children_put);             //初始化设备私有成员的子设备链表，还有两个函数，关于增加和减少子设备引用计数的
    return 0;
}
static void setup_parent(struct device *dev, struct device *parent)
{
    struct kobject *kobj;
    kobj = get_device_parent(dev, parent);        //得到设备kobject的父对象
    if (kobj)
        dev-&gt;kobj.parent = kobj;
}
int bus_add_device(struct device *dev)
{
    struct bus_type *bus = bus_get(dev-&gt;bus);
    int error = 0;

    if (bus) {
        pr_debug(&quot;bus: '%s': add device %s/n&quot;, bus-&gt;name, dev_name(dev));
        error = device_add_attrs(bus, dev);
        if (error)
            goto out_put;
        error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,
                        &amp;dev-&gt;kobj, dev_name(dev));
        if (error)
            goto out_id;
        error = sysfs_create_link(&amp;dev-&gt;kobj,
                &amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, &quot;subsystem&quot;);
        if (error)
            goto out_subsys;
        error = make_deprecated_bus_links(dev);
        if (error)
            goto out_deprecated;
        klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);      //关键点了，将设备添加进总线的设备链表
    }
    return 0;

out_deprecated:
    sysfs_remove_link(&amp;dev-&gt;kobj, &quot;subsystem&quot;);
out_subsys:
    sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));
out_id:
    device_remove_attrs(bus, dev);
out_put:
    bus_put(dev-&gt;bus);
    return error;
}
void bus_probe_device(struct device *dev)
{
    struct bus_type *bus = dev-&gt;bus;
    int ret;

    if (bus &amp;&amp; bus-&gt;p-&gt;drivers_autoprobe) {        //如果需要自动匹配驱动
        ret = device_attach(dev);                          //为设备寻找驱动
        WARN_ON(ret &lt; 0);
    }
}
int device_attach(struct device *dev)
{
    int ret = 0;

    device_lock(dev);          //锁住设备
    if (dev-&gt;driver) {                                    //如果设备有驱动
        ret = device_bind_driver(dev);          //那么将设备和驱动绑定
        if (ret == 0)
            ret = 1;
        else {
            dev-&gt;driver = NULL;
            ret = 0;
        }
    } else {
        pm_runtime_get_noresume(dev);
        ret = bus_for_each_drv(dev-&gt;bus, NULL, dev, __device_attach); //否则，在总线上寻找驱动与该设备进行匹配
        pm_runtime_put_sync(dev);
    }
    device_unlock(dev);
    return ret;
}
int device_bind_driver(struct device *dev)
{
    int ret;

    ret = driver_sysfs_add(dev);    
    if (!ret)
        driver_bound(dev);   //驱动绑定设备
    return ret;
}
int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
             void *data, int (*fn)(struct device_driver *, void *))
{
    struct klist_iter i;
    struct device_driver *drv;
    int error = 0;

    if (!bus)
        return -EINVAL;

    klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,
                 start ? &amp;start-&gt;p-&gt;knode_bus : NULL);   //初始化i结构体
    while ((drv = next_driver(&amp;i)) &amp;&amp; !error)   //遍历总线上的驱动
        error = fn(drv, data);                            //将驱动和设备进行匹配，这里的fn=__device_attach
    klist_iter_exit(&amp;i);
    return error;
}
 
static int __device_attach(struct device_driver *drv, void *data)
{
    struct device *dev = data;

    if (!driver_match_device(drv, dev))     //现用总线上的match匹配函数进行低级匹配
        return 0;

    return driver_probe_device(drv, dev);   //在来高级匹配
}
 
static inline int driver_match_device(struct device_driver *drv,  struct device *dev)
{
    return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;      //看到没，这里要调用总线上定义的match函数
}
 
int driver_probe_device(struct device_driver *drv, struct device *dev)
{
    int ret = 0;

    if (!device_is_registered(dev))  //设备是否注册
        return -ENODEV;

    pr_debug(&quot;bus: '%s': %s: matched device %s with driver %s/n&quot;,
         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);

    pm_runtime_get_noresume(dev);
    pm_runtime_barrier(dev);
    ret = really_probe(dev, drv);  //调用真正的匹配
    pm_runtime_put_sync(dev);

    return ret;
}
 
static int really_probe(struct device *dev, struct device_driver *drv)
{
    int ret = 0;

    atomic_inc(&amp;probe_count);
    pr_debug(&quot;bus: '%s': %s: probing driver %s with device %s/n&quot;,
         drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));
    WARN_ON(!list_empty(&amp;dev-&gt;devres_head));

    dev-&gt;driver = drv;
    if (driver_sysfs_add(dev)) {
        printk(KERN_ERR &quot;%s: driver_sysfs_add(%s) failed/n&quot;,
            __func__, dev_name(dev));
        goto probe_failed;
    }

    if (dev-&gt;bus-&gt;probe) {         //现用总线上定义的probe函数尝试一下
        ret = dev-&gt;bus-&gt;probe(dev);
        if (ret)
            goto probe_failed;
    } else if (drv-&gt;probe) {       //如果不行，在用驱动上的probe尝试
        ret = drv-&gt;probe(dev);
        if (ret)
            goto probe_failed;
    }

    driver_bound(dev);      //驱动绑定设备
    ret = 1;
    pr_debug(&quot;bus: '%s': %s: bound device %s to driver %s/n&quot;,
         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);
    goto done;

probe_failed:
    devres_release_all(dev);
    driver_sysfs_remove(dev);
    dev-&gt;driver = NULL;

    if (ret != -ENODEV &amp;&amp; ret != -ENXIO) {
        /* driver matched but the probe failed */
        printk(KERN_WARNING
               &quot;%s: probe of %s failed with error %d/n&quot;,
               drv-&gt;name, dev_name(dev), ret);
    }
    /*
     * Ignore errors returned by -&gt;probe so that the next driver can try
     * its luck.
     */
    ret = 0;
done:
    atomic_dec(&amp;probe_count);
    wake_up(&amp;probe_waitqueue);
    return ret;
}
 
</rich_text><encoded_png char_offset="204">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YccojRtuuKGjo6OmpoYxVlFRsWHDhnPnzu3du3dwcBCpIhr+A4GAx+MRQoyMjLzxxhu5XK6lpWXDhg11dXWo9dfW1t59990HDhwYGxtbunTp1NTU+++/f+7cuY0bN27durW5uRnZWSgUCoVCeFNo0UskEolEArVXj8eDsIVBfDJ0RlVVXdczmQz6fKLRaHV19e233z41NbV///4///nPb7755sDAACGktbX1jjvuQFVaUZTy8vK33nrLNM1QKKTren9//wMPPNDa2lpbW9vR0bFz506/35/JZGZmZkzT1DStsbHR5/PhnRqG0dnZCQDo5h4dHT137lxZWdk999yDs0g2m121atV3vvOdw4cPnz59empqChUgdBZJy4b0q5imWeCBuSaLHgF1Xad28oMc7Wix+qSb9j8VDA3TNM3v96M+i5EupaWl9fX17e3t11133cqVK5ubm5HCOMWu9r7Qy1BSUiK9usPDw08//fTFixd7enp27dp18803NzY2EkKGhoZM0zx58uT4+PjU1FRVVVUqlfJ6vR6Px+12r1mz5vTp0/F4HBl6UVFRMBj0+Xxbt27t6OjA+A9FUZYtW9bS0nL69Gm3211eXo6jGl23GP8xPT391ltv9fX1lZSUeDyef/7zn+gwdbvd+/fvTyQSk5OTK1euLCsrGx0dVRRlx44dra2t2CcIYTI0BFkzxutwznO5nKZpqqpOTU0dOnToxIkThmEkk8mioqKOjo6GhgYMAMKIIsuydF0vLS299dZb161bl06n33rrrb179x4/fvzcuXOvv/76zp07t23bVlNTE4lEDh48qOv6vn37jhw58u1vf3vZsmX3339/IBDgnE9MTPj9/qampmg0ms1mH3vssXA43NraWl9fTwjp7OxEJ8nw8DAG1vT19T355JNo5NF1PRAIJJPJ999/H59ROByenJxEh0k6ncYcHrA97x/Xy7eYZdEjoHyuGIYGtq/gapUFVgVAIEALFABEo9Gqqqr29vba2tq2trbm5ubq6moMrM1msxiijEbDD6gfpVIpTdO8Xm8wGCwuLjYMA8lUc3NzUVERYywajZ48efLIkSPIKN1ut67rGCWnqmppaWllZeXk5CQA6LqOzGtqakoG66BKjnQPAGKxGGa2YLgf0kZE4QsXLjDGcO324uJixH10TCNcRqNRAJicnEQAKi0tJYTIQBMh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</encoded_png></node><node name="i2c" prog_lang="custom-colors" readonly="False" tags="" unique_id="6"><rich_text>
</rich_text><node name="i2c bus" prog_lang="custom-colors" readonly="False" tags="" unique_id="7"><rich_text>在drivers/i2c/busses下包含各种I2C总线驱动，如S3C2440的I2C总线驱动i2c-s3c2410.c，使用GPIO模拟I2C总线的驱动i2c-gpio.c，这里只分析i2c-gpio.c。
i2c-gpio.c它是gpio模拟I2C总线的驱动，总线也是个设备，在这里将总线当作平台设备处理，那驱动当然是平台设备驱动，看它的驱动注册和注销函数。

1. static int __init i2c_gpio_init(void)  
2. {  
3.     int ret;  
4.   
5.     ret = platform_driver_register(&amp;i2c_gpio_driver);  
6.     if (ret)  
7.         printk(KERN_ERR &quot;i2c-gpio: probe failed: %d\n&quot;, ret);  
8.   
9.     return ret;  
10. }  
11. module_init(i2c_gpio_init);  
12.   
13. static void __exit i2c_gpio_exit(void)  
14. {  
15.     platform_driver_unregister(&amp;i2c_gpio_driver);  
16. }  
17. module_exit(i2c_gpio_exit);  

没有什么好说的，它的初始化和注销函数就是注册和注销一个平台设备驱动，直接看它的platform_driver结构i2c_gpio_driver
1. static struct platform_driver i2c_gpio_driver = {  
2.     .driver     = {  
3.         .name   = &quot;i2c-gpio&quot;,  
4.         .owner  = THIS_MODULE,  
5.     },  
6.     .probe      = i2c_gpio_probe,  
7.     .remove     = __devexit_p(i2c_gpio_remove),  
8. };  
小提示：是不是我们应该注册一个平台设备，以和这个驱动匹配，那先来注册这个平台设备。
先定义这个平台设备结构，至于怎么注册平台设备我想大家都应该知道吧。
1. #if defined(CONFIG_I2C_GPIO) | \   
2.     defined(CONFIG_I2C_GPIO_MODULE)   
3. static struct i2c_gpio_platform_data i2c_gpio_adapter_data = {   
4.     .sda_pin = PINID_GPMI_D05,   
5.     .scl_pin = PINID_GPMI_D04,   
6.     .udelay = 5, //100KHz   
7.     .timeout = 100,   
8.     .sda_is_open_drain = 1,   
9.     .scl_is_open_drain = 1,   
10. };   
11.   
12. static struct platform_device i2c_gpio = {   
13.     .name = &quot;i2c-gpio&quot;,   
14.     .id = 0,   
15.     .dev = {   
16.         .platform_data = &amp;i2c_gpio_adapter_data,   
17.         .release = mxs_nop_release,   
18.         },   
19. };   
20. #endif  
在这里struct platform_device结构中的name字段要和struct platform_driver中driver字段中name字段要相同，因为平台总线就是通过这个来判断设备和驱动是否匹配的。注意这里的id将它赋值了0，至于到底有什么用，后面再来细看。这个结构里面还包含一个最重要的数据i2c_gpio_adapter_data，它struct  i2c_gpio_platform_data结构类型变量，这个结构体类型定义在include/linux/i2c-gpio.h中。
1. struct i2c_gpio_platform_data {  
2.     unsigned int    sda_pin;  
3.     unsigned int    scl_pin;  
4.     int     udelay;  
5.     int     timeout;  
6.     unsigned int    sda_is_open_drain:1;  
7.     unsigned int    scl_is_open_drain:1;  
8.     unsigned int    scl_is_output_only:1;  
9. };  
这个结构体主要描述gpio模拟i2c总线，sda_pin和scl_pin表示使用哪两个IO管脚来模拟I2C总线，udelay和timeout分别为它的时钟频率和超时时间，sda_is_open_drain和scl_is_open_drain表示sda、scl这两个管脚是否是开漏(opendrain)电路，如果是设置为1，scl_is_output_only表示scl这个管脚是否只是作为输出，如果是设置为1。
回到驱动中，看其中最重要的i2c_gpio_probe。
1. static int __devinit i2c_gpio_probe(struct platform_device *pdev)  
2. {  
3.     struct i2c_gpio_platform_data *pdata;  
4.     struct i2c_algo_bit_data *bit_data;  
5.     struct i2c_adapter *adap;  
6.     int ret;  
7.   
8.     pdata = pdev-&gt;dev.platform_data;  
9.     if (!pdata)  
10.         return -ENXIO;  
11.   
12.     ret = -ENOMEM;  
13.     adap = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);  
14.     if (!adap)  
15.         goto err_alloc_adap;  
16.     bit_data = kzalloc(sizeof(struct i2c_algo_bit_data), GFP_KERNEL);  
17.     if (!bit_data)  
18.         goto err_alloc_bit_data;  
19.   
20.     ret = gpio_request(pdata-&gt;sda_pin, &quot;sda&quot;);  
21.     if (ret)  
22.         goto err_request_sda;  
23.     ret = gpio_request(pdata-&gt;scl_pin, &quot;scl&quot;);  
24.     if (ret)  
25.         goto err_request_scl;  
26.   
27.     if (pdata-&gt;sda_is_open_drain) {  
28.         gpio_direction_output(pdata-&gt;sda_pin, 1);  
29.         bit_data-&gt;setsda = i2c_gpio_setsda_val;  
30.     } else {  
31.         gpio_direction_input(pdata-&gt;sda_pin);  
32.         bit_data-&gt;setsda = i2c_gpio_setsda_dir;  
33.     }  
34.   
35.     if (pdata-&gt;scl_is_open_drain || pdata-&gt;scl_is_output_only) {  
36.         gpio_direction_output(pdata-&gt;scl_pin, 1);  
37.         bit_data-&gt;setscl = i2c_gpio_setscl_val;  
38.     } else {  
39.         gpio_direction_input(pdata-&gt;scl_pin);  
40.         bit_data-&gt;setscl = i2c_gpio_setscl_dir;  
41.     }  
42.   
43.     if (!pdata-&gt;scl_is_output_only)  
44.         bit_data-&gt;getscl = i2c_gpio_getscl;  
45.     bit_data-&gt;getsda = i2c_gpio_getsda;  
46.   
47.     if (pdata-&gt;udelay)  
48.         bit_data-&gt;udelay = pdata-&gt;udelay;  
49.     else if (pdata-&gt;scl_is_output_only)  
50.         bit_data-&gt;udelay = 50;           /* 10 kHz */  
51.     else  
52.         bit_data-&gt;udelay = 5;            /* 100 kHz */  
53.   
54.     if (pdata-&gt;timeout)  
55.         bit_data-&gt;timeout = pdata-&gt;timeout;  
56.     else  
57.         bit_data-&gt;timeout = HZ / 10;     /* 100 ms */  
58.   
59.     bit_data-&gt;data = pdata;  
60.   
61.     adap-&gt;owner = THIS_MODULE;  
62.     snprintf(adap-&gt;name, sizeof(adap-&gt;name), &quot;i2c-gpio%d&quot;, pdev-&gt;id);  
63.     adap-&gt;algo_data = bit_data;  
64.     adap-&gt;class = I2C_CLASS_HWMON | I2C_CLASS_SPD;  
65.     adap-&gt;dev.parent = &amp;pdev-&gt;dev;  
66.   
67.     /* 
68.      * If &quot;dev-&gt;id&quot; is negative we consider it as zero. 
69.      * The reason to do so is to avoid sysfs names that only make 
70.      * sense when there are multiple adapters. 
71.      */  
72.     adap-&gt;nr = (pdev-&gt;id != -1) ? pdev-&gt;id : 0;  
73.     ret = i2c_bit_add_numbered_bus(adap);  
74.     if (ret)  
75.         goto err_add_bus;  
76.   
77.     platform_set_drvdata(pdev, adap);  
78.   
79.     dev_info(&amp;pdev-&gt;dev, &quot;using pins %u (SDA) and %u (SCL%s)\n&quot;,  
80.          pdata-&gt;sda_pin, pdata-&gt;scl_pin,  
81.          pdata-&gt;scl_is_output_only  
82.          ? &quot;, no clock stretching&quot; : &quot;&quot;);  
83.   
84.     return 0;  
85.   
86. err_add_bus:  
87.     gpio_free(pdata-&gt;scl_pin);  
88. err_request_scl:  
89.     gpio_free(pdata-&gt;sda_pin);  
90. err_request_sda:  
91.     kfree(bit_data);  
92. err_alloc_bit_data:  
93.     kfree(adap);  
94. err_alloc_adap:  
95.     return ret;  
96. }  
从这句开始pdata= pdev-&gt;dev.platform_data;这不正是我们在平台设备结构中定义的数据吗。然后是使用kzalloc申请两段内存空间，一个是为结构struct  i2c_adapter申请的，另一个是为结构structi2c_algo_bit_data申请的。
struct i2c_adapter结构定义在include/linux/i2c.h中
1. struct i2c_adapter {  
2.     struct module *owner;  
3.     unsigned int id;  
4.     unsigned int class;       /* classes to allow probing for */  
5.     const struct i2c_algorithm *algo; /* the algorithm to access the bus */  
6.     void *algo_data;  
7.   
8.     /* data fields that are valid for all devices   */  
9.     u8 level;           /* nesting level for lockdep */  
10.     struct mutex bus_lock;  
11.   
12.     int timeout;            /* in jiffies */  
13.     int retries;  
14.     struct device dev;      /* the adapter device */  
15.   
16.     int nr;  
17.     char name[48];  
18.     struct completion dev_released;  
19. };  
在I2C子系统中，I2C适配器使用结构struct i2c_adapter描述，代表一条实际的I2C总线。
struct i2c_algo_bit_data结构定义在include/linux/i2c-algo-bit.h中
1. struct i2c_algo_bit_data {  
2.     void *data;     /* private data for lowlevel routines */  
3.     void (*setsda) (void *data, int state);  
4.     void (*setscl) (void *data, int state);  
5.     int  (*getsda) (void *data);  
6.     int  (*getscl) (void *data);  
7.   
8.     /* local settings */  
9.     int udelay;     /* half clock cycle time in us, 
10.                    minimum 2 us for fast-mode I2C, 
11.                    minimum 5 us for standard-mode I2C and SMBus, 
12.                    maximum 50 us for SMBus */  
13.     int timeout;        /* in jiffies */  
14. };  
这个结构主要用来定义对GPIO管脚的一些操作，还是回到probe中
接下来使用gpio_request去申请这个两个GPIO管脚，申请的目的是为了防止重复使用管脚。然后是根据struct i2c_gpio_platform_data结构中定义的后面三个数据对struct  i2c_algo_bit_data结构中的函数指针做一些赋值操作。接下来是I2C时钟频率和超时设置，如果在struct i2c_gpio_platform_data结构中定义了值，那么就采用定义的值，否则就采用默认的值。然后是对struct  i2c_adapter结构的一些赋值操作，比如指定它的父设备为这里的平台设备，前面在平台设备中定义了一个id，这里用到了，赋给了struct i2c_adapter中的nr成员，这个值表示总线号，这里的总线号和硬件无关，只是在软件上的区分。然后到了最后的主角i2c_bit_add_numbered_bus，这个函数定义在drivers/i2c/algos/i2c-algo-bit.c中
1. int i2c_bit_add_numbered_bus(struct i2c_adapter *adap)  
2. {  
3.     int err;  
4.   
5.     err = i2c_bit_prepare_bus(adap);  
6.     if (err)  
7.         return err;  
8.   
9.     return i2c_add_numbered_adapter(adap);  
10. }  
先看i2c_bit_prepare_bus函数
1. static int i2c_bit_prepare_bus(struct i2c_adapter *adap)  
2. {  
3.     struct i2c_algo_bit_data *bit_adap = adap-&gt;algo_data;  
4.   
5.     if (bit_test) {  
6.         int ret = test_bus(bit_adap, adap-&gt;name);  
7.         if (ret &lt; 0)  
8.             return -ENODEV;  
9.     }  
10.   
11.     /* register new adapter to i2c module... */  
12.     adap-&gt;algo = &amp;i2c_bit_algo;  
13.     adap-&gt;retries = 3;  
14.   
15.     return 0;  
16. }  
bit_test为模块参数，这里不管它，看这样一句adap-&gt;algo= &amp;i2c_bit_algo;
来看这个结构定义
1. static const struct i2c_algorithm i2c_bit_algo = {  
2.     .master_xfer    = bit_xfer,  
3.     .functionality  = bit_func,  
4. };  
先看这个结构类型在哪里定义的include/linux/i2c.h
1. struct i2c_algorithm {  
2.     /* If an adapter algorithm can't do I2C-level access, set master_xfer 
3.        to NULL. If an adapter algorithm can do SMBus access, set 
4.        smbus_xfer. If set to NULL, the SMBus protocol is simulated 
5.        using common I2C messages */  
6.     /* master_xfer should return the number of messages successfully 
7.        processed, or a negative value on error */  
8.     int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,  
9.                int num);  
10.     int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,  
11.                unsigned short flags, char read_write,  
12.                u8 command, int size, union i2c_smbus_data *data);  
13.   
14.     /* To determine what the adapter supports */  
15.     u32 (*functionality) (struct i2c_adapter *);  
16. };  
其实也没什么，就三个函数指针外加一长串注释
这个结构的master_xfer指针为主机的数据传输，具体来看bit_xfer这个函数，这个函数和I2C协议相关，I2C协议规定要先发送起始信号，才能开始进行数据的传输，最后数据传输完成后发送停止信号，看接下来代码对I2C协议要熟悉，所以这里的关键点是I2C协议。
1. static int bit_xfer(struct i2c_adapter *i2c_adap,  
2.             struct i2c_msg msgs[], int num)  
3. {  
4.     struct i2c_msg *pmsg;  
5.     struct i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;  
6.     int i, ret;  
7.     unsigned short nak_ok;  
8.   
9.     bit_dbg(3, &amp;i2c_adap-&gt;dev, &quot;emitting start condition\n&quot;);  
10.     /*发送起始信号*/  
11.     i2c_start(adap);  
12.     for (i = 0; i &lt; num; i++) {  
13.         pmsg = &amp;msgs[i];  
14.         nak_ok = pmsg-&gt;flags &amp; I2C_M_IGNORE_NAK;  
15.         if (!(pmsg-&gt;flags &amp; I2C_M_NOSTART)) {  
16.             if (i) {  
17.                 bit_dbg(3, &amp;i2c_adap-&gt;dev, &quot;emitting &quot;  
18.                     &quot;repeated start condition\n&quot;);  
19.                 i2c_repstart(adap);  
20.             }  
21.             ret = bit_doAddress(i2c_adap, pmsg);  
22.             if ((ret != 0) &amp;&amp; !nak_ok) {  
23.                 bit_dbg(1, &amp;i2c_adap-&gt;dev, &quot;NAK from &quot;  
24.                     &quot;device addr 0x%02x msg #%d\n&quot;,  
25.                     msgs[i].addr, i);  
26.                 goto bailout;  
27.             }  
28.         }  
29.         if (pmsg-&gt;flags &amp; I2C_M_RD) {  
30.             /* read bytes into buffer*/  
31.             ret = readbytes(i2c_adap, pmsg);  
32.             if (ret &gt;= 1)  
33.                 bit_dbg(2, &amp;i2c_adap-&gt;dev, &quot;read %d byte%s\n&quot;,  
34.                     ret, ret == 1 ? &quot;&quot; : &quot;s&quot;);  
35.             if (ret &lt; pmsg-&gt;len) {  
36.                 if (ret &gt;= 0)  
37.                     ret = -EREMOTEIO;  
38.                 goto bailout;  
39.             }  
40.         } else {  
41.             /* write bytes from buffer */  
42.             ret = sendbytes(i2c_adap, pmsg);  
43.             if (ret &gt;= 1)  
44.                 bit_dbg(2, &amp;i2c_adap-&gt;dev, &quot;wrote %d byte%s\n&quot;,  
45.                     ret, ret == 1 ? &quot;&quot; : &quot;s&quot;);  
46.             if (ret &lt; pmsg-&gt;len) {  
47.                 if (ret &gt;= 0)  
48.                     ret = -EREMOTEIO;  
49.                 goto bailout;  
50.             }  
51.         }  
52.     }  
53.     ret = i;  
54.   
55. bailout:  
56.     bit_dbg(3, &amp;i2c_adap-&gt;dev, &quot;emitting stop condition\n&quot;);  
57.     i2c_stop(adap);  
58.     return ret;  
59. }  
1.发送起始信号
i2c_start(adap);
看这个函数前，先看I2C协议怎么定义起始信号的
</rich_text><rich_text justification="left"></rich_text><rich_text>
起始信号就是在SCL为高电平期间，SDA从高到低的跳变，再来看代码是怎么实现的
1. static void i2c_start(struct i2c_algo_bit_data *adap)  
2. {  
3.     /* assert: scl, sda are high */  
4.     setsda(adap, 0);  
5.     udelay(adap-&gt;udelay);  
6.     scllo(adap);  
7. }  
这些setsda和setscl这些都是使用的总线的函数，在这里是使用的i2c-gpio.c中定义的函数，还记得那一系列判断赋值吗。
1. #define setsda(adap, val)   adap-&gt;setsda(adap-&gt;data, val)  
2. #define setscl(adap, val)   adap-&gt;setscl(adap-&gt;data, val)  
3. #define getsda(adap)        adap-&gt;getsda(adap-&gt;data)  
4. #define getscl(adap)        adap-&gt;getscl(adap-&gt;data)  
2.往下是个大的for循环
到了这里又不得不说这个struct i2c_msg结构，这个结构定义在include/linux/i2c.h中
1. struct i2c_msg {  
2.     __u16 addr; /* slave address            */  
3.     __u16 flags;  
4. #define I2C_M_TEN       0x0010  /* this is a ten bit chip address */  
5. #define I2C_M_RD        0x0001  /* read data, from slave to master */  
6. #define I2C_M_NOSTART       0x4000  /* if I2C_FUNC_PROTOCOL_MANGLING */  
7. #define I2C_M_REV_DIR_ADDR  0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */  
8. #define I2C_M_IGNORE_NAK    0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */  
9. #define I2C_M_NO_RD_ACK     0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */  
10. #define I2C_M_RECV_LEN      0x0400  /* length will be first received byte */  
11.     __u16 len;      /* msg length               */  
12.     __u8 *buf;      /* pointer to msg data          */  
13. };  
这个结构专门用于数据传输相关的addr为I2C设备地址，flags为一些标志位，len为数据的长度，buf为数据。这里宏定义的一些标志还是需要了解一下。
I2C_M_TEN表示10位设备地址
I2C_M_RD读标志
I2C_M_NOSTART无起始信号标志
I2C_M_IGNORE_NAK忽略应答信号标志
回到for，这里的num代表有几个struct i2c_msg，进入for语句，接下来是个if语句，判断这个设备是否定义了I2C_M_NOSTART标志，这个标志主要用于写操作时，不必重新发送起始信号和设备地址，但是对于读操作就不同了，要调用i2c_repstart这个函数去重新发送起始信号，调用bit_doAddress函数去重新构造设备地址字节，来看这个函数。
1. static int bit_doAddress(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)  
2. {  
3.     unsigned short flags = msg-&gt;flags;  
4.     unsigned short nak_ok = msg-&gt;flags &amp; I2C_M_IGNORE_NAK;  
5.     struct i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;  
6.   
7.     unsigned char addr;  
8.     int ret, retries;  
9.   
10.     retries = nak_ok ? 0 : i2c_adap-&gt;retries;  
11.   
12.     if (flags &amp; I2C_M_TEN) {  
13.         /* a ten bit address */  
14.         addr = 0xf0 | ((msg-&gt;addr &gt;&gt; 7) &amp; 0x03);  
15.         bit_dbg(2, &amp;i2c_adap-&gt;dev, &quot;addr0: %d\n&quot;, addr);  
16.         /* try extended address code...*/  
17.         ret = try_address(i2c_adap, addr, retries);  
18.         if ((ret != 1) &amp;&amp; !nak_ok)  {  
19.             dev_err(&amp;i2c_adap-&gt;dev,  
20.                 &quot;died at extended address code\n&quot;);  
21.             return -EREMOTEIO;  
22.         }  
23.         /* the remaining 8 bit address */  
24.         ret = i2c_outb(i2c_adap, msg-&gt;addr &amp; 0x7f);  
25.         if ((ret != 1) &amp;&amp; !nak_ok) {  
26.             /* the chip did not ack / xmission error occurred */  
27.             dev_err(&amp;i2c_adap-&gt;dev, &quot;died at 2nd address code\n&quot;);  
28.             return -EREMOTEIO;  
29.         }  
30.         if (flags &amp; I2C_M_RD) {  
31.             bit_dbg(3, &amp;i2c_adap-&gt;dev, &quot;emitting repeated &quot;  
32.                 &quot;start condition\n&quot;);  
33.             i2c_repstart(adap);  
34.             /* okay, now switch into reading mode */  
35.             addr |= 0x01;  
36.             ret = try_address(i2c_adap, addr, retries);  
37.             if ((ret != 1) &amp;&amp; !nak_ok) {  
38.                 dev_err(&amp;i2c_adap-&gt;dev,  
39.                     &quot;died at repeated address code\n&quot;);  
40.                 return -EREMOTEIO;  
41.             }  
42.         }  
43.     } else {        /* normal 7bit address  */  
44.         addr = msg-&gt;addr &lt;&lt; 1;  
45.         if (flags &amp; I2C_M_RD)  
46.             addr |= 1;  
47.         if (flags &amp; I2C_M_REV_DIR_ADDR)  
48.             addr ^= 1;  
49.         ret = try_address(i2c_adap, addr, retries);  
50.         if ((ret != 1) &amp;&amp; !nak_ok)  
51.             return -ENXIO;  
52.     }  
53.   
54.     return 0;  
55. }  
这里先做了一个判断，10位设备地址和7位设备地址分别做不同的处理，通常一条I2C总线上不会挂那么多I2C设备，所以10位地址不常用，直接看对7位地址的处理。struct  i2c_msg中addr中是真正的设备地址，而这里发送的addr高7位才是设备地址，最低位为读写位，如果为读，最低位为1，如果为写，最低位为0。所以要将struct  i2c_msg中addr向左移1位，如果定义了I2C_M_RD标志，就将addr或上1，前面就说过，这个标志就代表读，如果是写，这里就不用处理，因为最低位本身就是0。最后调用try_address函数将这个地址字节发送出去。
1. static int try_address(struct i2c_adapter *i2c_adap,  
2.                unsigned char addr, int retries)  
3. {  
4.     struct i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;  
5.     int i, ret = 0;  
6.   
7.     for (i = 0; i &lt;= retries; i++) {  
8.         ret = i2c_outb(i2c_adap, addr);  
9.         if (ret == 1 || i == retries)  
10.             break;  
11.         bit_dbg(3, &amp;i2c_adap-&gt;dev, &quot;emitting stop condition\n&quot;);  
12.         i2c_stop(adap);  
13.         udelay(adap-&gt;udelay);  
14.         yield();  
15.         bit_dbg(3, &amp;i2c_adap-&gt;dev, &quot;emitting start condition\n&quot;);  
16.         i2c_start(adap);  
17.     }  
18.     if (i &amp;&amp; ret)  
19.         bit_dbg(1, &amp;i2c_adap-&gt;dev, &quot;Used %d tries to %s client at &quot;  
20.             &quot;0x%02x: %s\n&quot;, i + 1,  
21.             addr &amp; 1 ? &quot;read from&quot; : &quot;write to&quot;, addr &gt;&gt; 1,  
22.             ret == 1 ? &quot;success&quot; : &quot;failed, timeout?&quot;);  
23.     return ret;  
24. }  
最主要的就是调用i2c_outb发送一个字节，retries为重复次数，看前面adap-&gt;retries= 3;
如果发送失败，也就是设备没有给出应答信号，那就发送停止信号，发送起始信号，再发送这个地址字节，这就叫retries。来看这个具体的i2c_outb函数
1. static int i2c_outb(struct i2c_adapter *i2c_adap, unsigned char c)  
2. {  
3.     int i;  
4.     int sb;  
5.     int ack;  
6.     struct i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;  
7.   
8.     /* assert: scl is low */  
9.     for (i = 7; i &gt;= 0; i--) {  
10.         sb = (c &gt;&gt; i) &amp; 1;  
11.         setsda(adap, sb);  
12.         udelay((adap-&gt;udelay + 1) / 2);  
13.         if (sclhi(adap) &lt; 0) { /* timed out */  
14.             bit_dbg(1, &amp;i2c_adap-&gt;dev, &quot;i2c_outb: 0x%02x, &quot;  
15.                 &quot;timeout at bit #%d\n&quot;, (int)c, i);  
16.             return -ETIMEDOUT;  
17.         }  
18.         /* FIXME do arbitration here: 
19.          * if (sb &amp;&amp; !getsda(adap)) -&gt; ouch! Get out of here. 
20.          * 
21.          * Report a unique code, so higher level code can retry 
22.          * the whole (combined) message and *NOT* issue STOP. 
23.          */  
24.         scllo(adap);  
25.     }  
26.     sdahi(adap);  
27.     if (sclhi(adap) &lt; 0) { /* timeout */  
28.         bit_dbg(1, &amp;i2c_adap-&gt;dev, &quot;i2c_outb: 0x%02x, &quot;  
29.             &quot;timeout at ack\n&quot;, (int)c);  
30.         return -ETIMEDOUT;  
31.     }  
32.   
33.     /* read ack: SDA should be pulled down by slave, or it may 
34.      * NAK (usually to report problems with the data we wrote). 
35.      */  
36.     ack = !getsda(adap);    /* ack: sda is pulled low -&gt; success */  
37.     bit_dbg(2, &amp;i2c_adap-&gt;dev, &quot;i2c_outb: 0x%02x %s\n&quot;, (int)c,  
38.         ack ? &quot;A&quot; : &quot;NA&quot;);  
39.   
40.     scllo(adap);  
41.     return ack;  
42.     /* assert: scl is low (sda undef) */  
43. }  
这个函数有两个参数，一个是structi2c_adapter代表I2C主机，一个是发送的字节数据。那么I2C是怎样将一个字节数据发送出去的呢，那再来看看协议。
</rich_text><rich_text justification="left"></rich_text><rich_text>

首先是发送字节数据的最高位，在时钟为高电平期间将一位数据发送出去，最后是发送字节数据的最低位。发送完成之后，我们需要一个ACK信号，要不然我怎么知道发送成功没有，ACK信号就是在第九个时钟周期时数据线为低，所以在一个字节数据传送完成后，还要将数据线拉高，我们看程序中就是这一句sdahi(adap);等待这个ACK信号的到来，这样一个字节数据就发送完成。
回到bit_xfer函数中，前面只是将设备地址字节发送出去了，那么接下来就是该发送数据了。
注意：这里的数据包括操作设备的基地址
如果是读则调用readbytes函数去读，如果是写则调用sendbytes去写，先看readbytes函数
1. static int readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)  
2. {  
3.     int inval;  
4.     int rdcount = 0;    /* counts bytes read */  
5.     unsigned char *temp = msg-&gt;buf;  
6.     int count = msg-&gt;len;  
7.     const unsigned flags = msg-&gt;flags;  
8.   
9.     while (count &gt; 0) {  
10.         inval = i2c_inb(i2c_adap);  
11.         if (inval &gt;= 0) {  
12.             *temp = inval;  
13.             rdcount++;  
14.         } else {   /* read timed out */  
15.             break;  
16.         }  
17.   
18.         temp++;  
19.         count--;  
20.   
21.         /* Some SMBus transactions require that we receive the 
22.            transaction length as the first read byte. */  
23.         if (rdcount == 1 &amp;&amp; (flags &amp; I2C_M_RECV_LEN)) {  
24.             if (inval &lt;= 0 || inval &gt; I2C_SMBUS_BLOCK_MAX) {  
25.                 if (!(flags &amp; I2C_M_NO_RD_ACK))  
26.                     acknak(i2c_adap, 0);  
27.                 dev_err(&amp;i2c_adap-&gt;dev, &quot;readbytes: invalid &quot;  
28.                     &quot;block length (%d)\n&quot;, inval);  
29.                 return -EREMOTEIO;  
30.             }  
31.             /* The original count value accounts for the extra 
32.                bytes, that is, either 1 for a regular transaction, 
33.                or 2 for a PEC transaction. */  
34.             count += inval;  
35.             msg-&gt;len += inval;  
36.         }  
37.   
38.         bit_dbg(2, &amp;i2c_adap-&gt;dev, &quot;readbytes: 0x%02x %s\n&quot;,  
39.             inval,  
40.             (flags &amp; I2C_M_NO_RD_ACK)  
41.                 ? &quot;(no ack/nak)&quot;  
42.                 : (count ? &quot;A&quot; : &quot;NA&quot;));  
43.   
44.         if (!(flags &amp; I2C_M_NO_RD_ACK)) {  
45.             inval = acknak(i2c_adap, count);  
46.             if (inval &lt; 0)  
47.                 return inval;  
48.         }  
49.     }  
50.     return rdcount;  
51. }  
其中一个大的while循环，调用i2c_inb去读一个字节，count为数据的长度，单位为多少个字节，
那就来看i2c_inb函数。
1. static int i2c_inb(struct i2c_adapter *i2c_adap)  
2. {  
3.     /* read byte via i2c port, without start/stop sequence  */  
4.     /* acknowledge is sent in i2c_read.         */  
5.     int i;  
6.     unsigned char indata = 0;  
7.     struct i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;  
8.   
9.     /* assert: scl is low */  
10.     sdahi(adap);  
11.     for (i = 0; i &lt; 8; i++) {  
12.         if (sclhi(adap) &lt; 0) { /* timeout */  
13.             bit_dbg(1, &amp;i2c_adap-&gt;dev, &quot;i2c_inb: timeout at bit &quot;  
14.                 &quot;#%d\n&quot;, 7 - i);  
15.             return -ETIMEDOUT;  
16.         }  
17.         indata *= 2;  
18.         if (getsda(adap))  
19.             indata |= 0x01;  
20.         setscl(adap, 0);  
21.         udelay(i == 7 ? adap-&gt;udelay / 2 : adap-&gt;udelay);  
22.     }  
23.     /* assert: scl is low */  
24.     return indata;  
25. }  
再来看sendbytes函数
1. static int sendbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)  
2. {  
3.     const unsigned char *temp = msg-&gt;buf;  
4.     int count = msg-&gt;len;  
5.     unsigned short nak_ok = msg-&gt;flags &amp; I2C_M_IGNORE_NAK;  
6.     int retval;  
7.     int wrcount = 0;  
8.   
9.     while (count &gt; 0) {  
10.         retval = i2c_outb(i2c_adap, *temp);  
11.   
12.         /* OK/ACK; or ignored NAK */  
13.         if ((retval &gt; 0) || (nak_ok &amp;&amp; (retval == 0))) {  
14.             count--;  
15.             temp++;  
16.             wrcount++;  
17.   
18.         /* A slave NAKing the master means the slave didn't like 
19.          * something about the data it saw.  For example, maybe 
20.          * the SMBus PEC was wrong. 
21.          */  
22.         } else if (retval == 0) {  
23.             dev_err(&amp;i2c_adap-&gt;dev, &quot;sendbytes: NAK bailout.\n&quot;);  
24.             return -EIO;  
25.   
26.         /* Timeout; or (someday) lost arbitration 
27.          * 
28.          * FIXME Lost ARB implies retrying the transaction from 
29.          * the first message, after the &quot;winning&quot; master issues 
30.          * its STOP.  As a rule, upper layer code has no reason 
31.          * to know or care about this ... it is *NOT* an error. 
32.          */  
33.         } else {  
34.             dev_err(&amp;i2c_adap-&gt;dev, &quot;sendbytes: error %d\n&quot;,  
35.                     retval);  
36.             return retval;  
37.         }  
38.     }  
39.     return wrcount;  
40. }  
也是一个大的while循环，同发送地址字节一样，也是调用i2c_outb去发送一个字节，count也是数据长度，由于i2c_outb函数在前面发送设备地址那里已经介绍了，这里也就不贴出来了。
还是回到bit_xfer函数，数据传输完成后，调用i2c_stop函数发送停止信号。我们看停止信号函数怎么去实现的。
1. static void i2c_stop(struct i2c_algo_bit_data *adap)  
2. {  
3.     /* assert: scl is low */  
4.     sdalo(adap);  
5.     sclhi(adap);  
6.     setsda(adap, 1);  
7.     udelay(adap-&gt;udelay);  
8. }  
看前面发送起始信号的那张图，停止信号就是在时钟为高电平期间，数据线从低到高的跳变。我们看程序是先将数据线拉低，将时钟线拉高，最后将数据拉高，这样就够成了一个停止信号。
还是回到i2c_bit_add_numbered_bus这个函数中来，看另外一个函数调用i2c_add_numbered_adapter。
1. int i2c_add_numbered_adapter(struct i2c_adapter *adap)  
2. {  
3.     int id;  
4.     int status;  
5.   
6.     if (adap-&gt;nr &amp; ~MAX_ID_MASK)  
7.         return -EINVAL;  
8.   
9. retry:  
10.     if (idr_pre_get(&amp;i2c_adapter_idr, GFP_KERNEL) == 0)  
11.         return -ENOMEM;  
12.   
13.     mutex_lock(&amp;core_lock);  
14.     /* &quot;above&quot; here means &quot;above or equal to&quot;, sigh; 
15.      * we need the &quot;equal to&quot; result to force the result 
16.      */  
17.     status = idr_get_new_above(&amp;i2c_adapter_idr, adap, adap-&gt;nr, &amp;id);  
18.     if (status == 0 &amp;&amp; id != adap-&gt;nr) {  
19.         status = -EBUSY;  
20.         idr_remove(&amp;i2c_adapter_idr, id);  
21.     }  
22.     mutex_unlock(&amp;core_lock);  
23.     if (status == -EAGAIN)  
24.         goto retry;  
25.   
26.     if (status == 0)  
27.         status = i2c_register_adapter(adap);  
28.     return status;  
29. }  
最重要的是这句i2c_register_adapter，注册这条I2C总线，进去看看
1. static int i2c_register_adapter(struct i2c_adapter *adap)  
2. {  
3.     int res = 0, dummy;  
4.   
5.     /* Can't register until after driver model init */  
6.     if (unlikely(WARN_ON(!i2c_bus_type.p))) {  
7.         res = -EAGAIN;  
8.         goto out_list;  
9.     }  
10.   
11.     mutex_init(&amp;adap-&gt;bus_lock);  
12.   
13.     /* Set default timeout to 1 second if not already set */  
14.     if (adap-&gt;timeout == 0)  
15.         adap-&gt;timeout = HZ;  
16.   
17.     dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr);  
18.     adap-&gt;dev.bus = &amp;i2c_bus_type;  
19.     adap-&gt;dev.type = &amp;i2c_adapter_type;  
20.     res = device_register(&amp;adap-&gt;dev);  
21.     if (res)  
22.         goto out_list;  
23.   
24.     dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);  
25.   
26. #ifdef CONFIG_I2C_COMPAT  
27.     res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,  
28.                        adap-&gt;dev.parent);  
29.     if (res)  
30.         dev_warn(&amp;adap-&gt;dev,  
31.              &quot;Failed to create compatibility class link\n&quot;);  
32. #endif  
33.   
34.     /* create pre-declared device nodes */  
35.     if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)  
36.         i2c_scan_static_board_info(adap);  
37.   
38.     /* Notify drivers */  
39.     mutex_lock(&amp;core_lock);  
40.     dummy = bus_for_each_drv(&amp;i2c_bus_type, NULL, adap,  
41.                  i2c_do_add_adapter);  
42.     mutex_unlock(&amp;core_lock);  
43.   
44.     return 0;  
45.   
46. out_list:  
47.     mutex_lock(&amp;core_lock);  
48.     idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);  
49.     mutex_unlock(&amp;core_lock);  
50.     return res;  
51. }  
看内核代码有时就会这样，会陷入内核代码的汪洋大海中，而拔不出来，直接后果是最后都忘记看这段代码的目的，丧失继续看下去的信心。所以为了避免这样情况出现，所以最好在开始看代码的时候要明确目标，我通过这段代码到底要了解什么东西，主干要抓住，其它枝叶就不要看了。
在这里我认为主要的有
1.注册这个I2C总线设备
1. adap-&gt;dev.bus = &amp;i2c_bus_type;  
2. adap-&gt;dev.type = &amp;i2c_adapter_type;  
3. res = device_register(&amp;adap-&gt;dev);  
这个设备的总线类型为i2c_bus_type
1. struct bus_type i2c_bus_type = {  
2.     .name       = &quot;i2c&quot;,  
3.     .match      = i2c_device_match,  
4.     .probe      = i2c_device_probe,  
5.     .remove     = i2c_device_remove,  
6.     .shutdown   = i2c_device_shutdown,  
7.     .suspend    = i2c_device_suspend,  
8.     .resume     = i2c_device_resume,  
9. };  
看一下它的match函数
1. static int i2c_device_match(struct device *dev, struct device_driver *drv)  
2. {  
3.     struct i2c_client   *client = i2c_verify_client(dev);  
4.     struct i2c_driver   *driver;  
5.   
6.     if (!client)  
7.         return 0;  
8.   
9.     driver = to_i2c_driver(drv);  
10.     /* match on an id table if there is one */  
11.     if (driver-&gt;id_table)  
12.         return i2c_match_id(driver-&gt;id_table, client) != NULL;  
13.   
14.     return 0;  
15. }  
这个match函数主要用来匹配我们的I2C设备和I2C驱动的，如果匹配成功，最后会调用驱动的probe函数，来看它如何匹配的。
1. static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,  
2.                         const struct i2c_client *client)  
3. {  
4.     while (id-&gt;name[0]) {  
5.         if (strcmp(client-&gt;name, id-&gt;name) == 0)  
6.             return id;  
7.         id++;  
8.     }  
9.     return NULL;  
10. }  
就是判断I2C设备的name字段和驱动中id_table中定义的name字段是否相等。
2.往这条总线上添加设备
1. static void i2c_scan_static_board_info(struct i2c_adapter *adapter)  
2. {  
3.     struct i2c_devinfo  *devinfo;  
4.   
5.     down_read(&amp;__i2c_board_lock);  
6.     list_for_each_entry(devinfo, &amp;__i2c_board_list, list) {  
7.         if (devinfo-&gt;busnum == adapter-&gt;nr  
8.                 &amp;&amp; !i2c_new_device(adapter,  
9.                         &amp;devinfo-&gt;board_info))  
10.             dev_err(&amp;adapter-&gt;dev,  
11.                 &quot;Can't create device at 0x%02x\n&quot;,  
12.                 devinfo-&gt;board_info.addr);  
13.     }  
14.     up_read(&amp;__i2c_board_lock);  
15. }  
遍历__i2c_board_list这条链表，看下面的if语句，首先要让struct i2c_devinfo结构中的busnum等于struct  i2c_adapter中的nr，我们前面也说了，这个nr就是i2c总线的总线号，这里可以理解为是在往这条总线上添加设备。所以，如果我们要向I2C注册一个I2C设备的话，直接向__i2c_board_list添加一个设备信息就可以了，先来看这个设备信息结构是怎么定义的。
1. struct i2c_board_info {  
2.     char        type[I2C_NAME_SIZE];  
3.     unsigned short  flags;  
4.     unsigned short  addr;  
5.     void        *platform_data;  
6.     struct dev_archdata *archdata;  
7.     int     irq;  
8. };  
定义这样一个信息呢一般使用一个宏I2C_BOARD_INFO
1. #define I2C_BOARD_INFO(dev_type, dev_addr) \  
2.     .type = dev_type, .addr = (dev_addr)  
dev_type为设备的名字，前面也说了，这个name一定要和I2C驱动相同。addr为设备的地址。
定义了这样一组信息之后呢，接下来当然是往链表添加这些信息了。
1. int __init  
2. i2c_register_board_info(int busnum,  
3.     struct i2c_board_info const *info, unsigned len)  
4. {  
5.     int status;  
6.   
7.     down_write(&amp;__i2c_board_lock);  
8.   
9.     /* dynamic bus numbers will be assigned after the last static one */  
10.     if (busnum &gt;= __i2c_first_dynamic_bus_num)  
11.         __i2c_first_dynamic_bus_num = busnum + 1;  
12.   
13.     for (status = 0; len; len--, info++) {  
14.         struct i2c_devinfo  *devinfo;  
15.   
16.         devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);  
17.         if (!devinfo) {  
18.             pr_debug(&quot;i2c-core: can't register boardinfo!\n&quot;);  
19.             status = -ENOMEM;  
20.             break;  
21.         }  
22.   
23.         devinfo-&gt;busnum = busnum;  
24.         devinfo-&gt;board_info = *info;  
25.         list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);  
26.     }  
27.   
28.     up_write(&amp;__i2c_board_lock);  
29.   
30.     return status;  
31. }  
第一个参数呢需要注意，它是I2C总线号，一定要和具体的I2C总线对应。我们看又定义了这样一个结构struct i2c_devinfo。
1. struct i2c_devinfo {  
2.     struct list_head    list;  
3.     int         busnum;  
4.     struct i2c_board_info   board_info;  
5. };  
最后是调用list_add_tail往__i2c_board_list这条链表添加设备信息。
然后是i2c_new_device
1. struct i2c_client *  
2. i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)  
3. {  
4.     struct i2c_client   *client;  
5.     int         status;  
6.   
7.     /*为I2C设备申请内存*/  
8.     client = kzalloc(sizeof *client, GFP_KERNEL);  
9.     if (!client)  
10.         return NULL;  
11.   
12.     /*指定I2C设备的总线*/  
13.     client-&gt;adapter = adap;  
14.   
15.     client-&gt;dev.platform_data = info-&gt;platform_data;  
16.   
17.     if (info-&gt;archdata)  
18.         client-&gt;dev.archdata = *info-&gt;archdata;  
19.   
20.     client-&gt;flags = info-&gt;flags;  
21.     client-&gt;addr = info-&gt;addr; /*I2C设备地址*/  
22.     client-&gt;irq = info-&gt;irq;  
23.   
24.     strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));  
25.   
26.     /*检查这个地址有没有被设备占用*/  
27.     /* Check for address business */  
28.     status = i2c_check_addr(adap, client-&gt;addr);  
29.     if (status)  
30.         goto out_err;  
31.   
32.     client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev; /*指定设备的父设备*/  
33.     client-&gt;dev.bus = &amp;i2c_bus_type; /*指定设备的总线类型*/  
34.     client-&gt;dev.type = &amp;i2c_client_type;  
35.   
36.     dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap),  
37.              client-&gt;addr);  
38.     status = device_register(&amp;client-&gt;dev); /*注册设备*/  
39.     if (status)  
40.         goto out_err;  
41.   
42.     dev_dbg(&amp;adap-&gt;dev, &quot;client [%s] registered with bus id %s\n&quot;,  
43.         client-&gt;name, dev_name(&amp;client-&gt;dev));  
44.   
45.     return client;  
46.   
47. out_err:  
48.     dev_err(&amp;adap-&gt;dev, &quot;Failed to register i2c client %s at 0x%02x &quot;  
49.         &quot;(%d)\n&quot;, client-&gt;name, client-&gt;addr, status);  
50.     kfree(client);  
51.     return NULL;  
52. }  
这个函数的功能是新建一个I2C设备并注册它，在I2C子系统中，I2C设备使用结构structi2c_client描述，那么首先要申请内存空间，I2C设备的主机是谁，必须知道挂载到哪条总线上的，然后就是一些赋值操作，最后就是注册设备，那么这个设备就实实在在的挂在到这条总线上了，这也是新的I2C设备注册方式。
3.i2c_do_add_adapter
你看说着说着就跑远了
1. static int i2c_do_add_adapter(struct device_driver *d, void *data)  
2. {  
3.     struct i2c_driver *driver = to_i2c_driver(d);  
4.     struct i2c_adapter *adap = data;  
5.   
6.     /* Detect supported devices on that bus, and instantiate them */  
7.     i2c_detect(adap, driver);  
8.   
9.     /* Let legacy drivers scan this bus for matching devices */  
10.     if (driver-&gt;attach_adapter) {  
11.         /* We ignore the return code; if it fails, too bad */  
12.         driver-&gt;attach_adapter(adap);  
13.     }  
14.     return 0;  
15. }  
前面通过i2c_scan_static_board_info往I2C总线上添加设备是新的方式，而这里调用每个I2C设备驱动的attach_adapter函数，然后在attach_adapter函数中去实现设备的注册，这是老的方式，i2c-dev.c中就是采用的这种方式。至此，总线这块就看完了。
</rich_text><encoded_png char_offset="11945">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</encoded_png><encoded_png char_offset="18895">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</encoded_png></node><node name="i2c driver" prog_lang="custom-colors" readonly="False" tags="" unique_id="8"><rich_text>struct i2c_driver {
	unsigned int class;

	/* Notifies the driver that a new bus has appeared or is about to be
	 * removed. You should avoid using this, it will be removed in a
	 * near future.
	 */
	int (*attach_adapter)(struct i2c_adapter *) __deprecated;
	int (*detach_adapter)(struct i2c_adapter *) __deprecated;

	/* Standard driver model interfaces */
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);

	/* driver model interfaces that don't relate to enumeration  */
	void (*shutdown)(struct i2c_client *);
	int (*suspend)(struct i2c_client *, pm_message_t mesg);
	int (*resume)(struct i2c_client *);

	/* Alert callback, for example for the SMBus alert protocol.
	 * The format and meaning of the data value depends on the protocol.
	 * For the SMBus alert protocol, there is a single bit of data passed
	 * as the alert response's low bit (&quot;event flag&quot;).
	 */
	void (*alert)(struct i2c_client *, unsigned int data);

	/* a ioctl like command that can be used to perform specific functions
	 * with the device.
	 */
	int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);

	struct device_driver driver;
	const struct i2c_device_id *id_table;

	/* Device detection callback for automatic device creation */
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const unsigned short *address_list;
	struct list_head clients;
};

</rich_text><rich_text scale="h3" weight="heavy">1.以ft5x_ts.c为范例:</rich_text><rich_text>
static const struct i2c_device_id ft5x_ts_id[] = {
	{ CTP_NAME, 0 },
	{}
};
MODULE_DEVICE_TABLE(i2c, ft5x_ts_id);

static struct i2c_driver ft5x_ts_driver = {
	.class          = I2C_CLASS_HWMON,
	.probe		= ft5x_ts_probe,
	.remove		= __devexit_p(ft5x_ts_remove),
	.id_table	= ft5x_ts_id,
	.suspend        = ft5x_ts_suspend,
	.resume         = ft5x_ts_resume,
	.driver	= {
		.name	= CTP_NAME,
		.owner	= THIS_MODULE,
	},
	.address_list	= normal_i2c,
};

static int __init ft5x_ts_init(void) {
    ft5x_ts_driver.detect = ctp_detect;
    ret = i2c_add_driver(&amp;ft5x_ts_driver);
}

i2c_add_driver定义在linux/i2c.h中的一个宏，它实际调用
int i2c_register_driver(struct module *owner, struct i2c_driver *driver)
{
	int res;

	/* Can't register until after driver model init */
	if (unlikely(WARN_ON(!i2c_bus_type.p)))
		return -EAGAIN;

	/* add the driver to the list of i2c drivers in the driver core */
	driver-&gt;driver.owner = owner;
	driver-&gt;driver.bus = &amp;i2c_bus_type;

	/* When registration returns, the driver core
	 * will have called probe() for all matching-but-unbound devices.
	 */
	res = driver_register(&amp;driver-&gt;driver);
	if (res)
		return res;

	/* Drivers should switch to dev_pm_ops instead. */
	if (driver-&gt;suspend)
		pr_warn(&quot;i2c-core: driver [%s] using legacy suspend method\n&quot;,
			driver-&gt;driver.name);
	if (driver-&gt;resume)
		pr_warn(&quot;i2c-core: driver [%s] using legacy resume method\n&quot;,
			driver-&gt;driver.name);

	pr_debug(&quot;i2c-core: driver [%s] registered\n&quot;, driver-&gt;driver.name);

	INIT_LIST_HEAD(&amp;driver-&gt;clients);
	/* Walk the adapters that are already present */
	i2c_for_each_dev(driver, __process_new_driver); 

	return 0;
}

扫描i2c bus的adapter设备。
int i2c_for_each_dev(void *data, int (*fn)(struct device *, void *))
{
	int res;

	mutex_lock(&amp;core_lock);
	res = bus_for_each_dev(&amp;i2c_bus_type, NULL, data, fn);
	mutex_unlock(&amp;core_lock);

	return res;
}
EXPORT_SYMBOL_GPL(i2c_for_each_dev);

static int __process_new_driver(struct device *dev, void *data)
{
	if (dev-&gt;type != &amp;i2c_adapter_type)
		return 0;
	return i2c_do_add_adapter(data, to_i2c_adapter(dev));
}

i2c_do_add_adapter调用
static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)
{
	const unsigned short *address_list;
	struct i2c_client *temp_client;
	int i, err = 0;
	int adap_id = i2c_adapter_id(adapter);

	address_list = driver-&gt;address_list;            //ft5x_ts的address_list!=NULL, driver-&gt;detect != NULL
	if (!driver-&gt;detect || !address_list)
		return 0;

	/* Stop here if the classes do not match */
	if (!(adapter-&gt;class &amp; driver-&gt;class))
		return 0;

	/* Set up a temporary client to help detect callback */
	temp_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
	if (!temp_client)
		return -ENOMEM;
	temp_client-&gt;adapter = adapter;

	for (i = 0; address_list[i] != I2C_CLIENT_END; i += 1) {
		dev_dbg(&amp;adapter-&gt;dev, &quot;found normal entry for adapter %d, &quot;
			&quot;addr 0x%02x\n&quot;, adap_id, address_list[i]);
		temp_client-&gt;addr = address_list[i];
		err = i2c_detect_address(temp_client, driver);
		if (unlikely(err))
			break;
	}

	kfree(temp_client);
	return err;
}

static int i2c_detect_address(struct i2c_client *temp_client,
			      struct i2c_driver *driver)
{
	struct i2c_board_info info;
	struct i2c_adapter *adapter = temp_client-&gt;adapter;
	int addr = temp_client-&gt;addr;
	int err;

	/* Make sure the address is valid */
	err = i2c_check_addr_validity(addr);
	if (err) {
		dev_warn(&amp;adapter-&gt;dev, &quot;Invalid probe address 0x%02x\n&quot;,
			 addr);
		return err;
	}

	/* Skip if already in use */
	if (i2c_check_addr_busy(adapter, addr))
		return 0;
#ifndef CONFIG_ARCH_SUN7I
	/* Make sure there is something at this address */
	if (!i2c_default_probe(adapter, addr))
		return 0;
#endif

	/* Finally call the custom detection function */
	memset(&amp;info, 0, sizeof(struct i2c_board_info));
	info.addr = addr;
	err = driver-&gt;detect(temp_client, &amp;info);                   //调用ctp_detect()
	if (err) {
		/* -ENODEV is returned if the detection fails. We catch it
		   here as this isn't an error. */
		return err == -ENODEV ? 0 : err;
	}

	/* Consistency check */
	if (info.type[0] == '\0') {
		dev_err(&amp;adapter-&gt;dev, &quot;%s detection function provided &quot;
			&quot;no name for 0x%x\n&quot;, driver-&gt;driver.name,
			addr);
	} else {
		struct i2c_client *client;

		/* Detection succeeded, instantiate the device */
		dev_dbg(&amp;adapter-&gt;dev, &quot;Creating %s at 0x%02x\n&quot;,
			info.type, info.addr);
		client = i2c_new_device(adapter, &amp;info);                //注册新的设备, 注册的过程中匹配相应的驱动
		if (client)
			list_add_tail(&amp;client-&gt;detected, &amp;driver-&gt;clients);
		else
			dev_err(&amp;adapter-&gt;dev, &quot;Failed creating %s at 0x%02x\n&quot;,
				info.type, info.addr);
	}
	return 0;
}

struct i2c_client *
i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
{
	struct i2c_client	*client;
	int			status;

	client = kzalloc(sizeof *client, GFP_KERNEL);
	if (!client)
		return NULL;

	client-&gt;adapter = adap;

	client-&gt;dev.platform_data = info-&gt;platform_data;

	if (info-&gt;archdata)
		client-&gt;dev.archdata = *info-&gt;archdata;

	client-&gt;flags = info-&gt;flags;
	client-&gt;addr = info-&gt;addr;
	client-&gt;irq = info-&gt;irq;

	strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));

	/* Check for address validity */
	status = i2c_check_client_addr_validity(client);
	if (status) {
		dev_err(&amp;adap-&gt;dev, &quot;Invalid %d-bit I2C address 0x%02hx\n&quot;,
			client-&gt;flags &amp; I2C_CLIENT_TEN ? 10 : 7, client-&gt;addr);
		goto out_err_silent;
	}

	/* Check for address business */
	status = i2c_check_addr_busy(adap, client-&gt;addr);
	if (status)
		goto out_err;

	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;
	client-&gt;dev.bus = &amp;i2c_bus_type;
	client-&gt;dev.type = &amp;i2c_client_type;
	client-&gt;dev.of_node = info-&gt;of_node;

	/* For 10-bit clients, add an arbitrary offset to avoid collisions */
	dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap),
		     client-&gt;addr | ((client-&gt;flags &amp; I2C_CLIENT_TEN)
				     ? 0xa000 : 0));
	status = device_register(&amp;client-&gt;dev);
	if (status)
		goto out_err;

	dev_dbg(&amp;adap-&gt;dev, &quot;client [%s] registered with bus id %s\n&quot;,
		client-&gt;name, dev_name(&amp;client-&gt;dev));

	return client;

out_err:
	dev_err(&amp;adap-&gt;dev, &quot;Failed to register i2c client %s at 0x%02x &quot;
		&quot;(%d)\n&quot;, client-&gt;name, client-&gt;addr, status);
out_err_silent:
	kfree(client);
	return NULL;
}

</rich_text><rich_text scale="h1" weight="heavy">2. i2c数据结构</rich_text><rich_text>
static const struct dev_pm_ops i2c_device_pm_ops = {
	.suspend = i2c_device_pm_suspend,
	.resume = i2c_device_pm_resume,
	.freeze = i2c_device_pm_freeze,
	.thaw = i2c_device_pm_thaw,
	.poweroff = i2c_device_pm_poweroff,
	.restore = i2c_device_pm_restore,
	SET_RUNTIME_PM_OPS(
		pm_generic_runtime_suspend,
		pm_generic_runtime_resume,
		pm_generic_runtime_idle
	)
};

struct bus_type i2c_bus_type = {
	.name		= &quot;i2c&quot;,
	.match		= i2c_device_match,
	.probe		= i2c_device_probe,
	.remove		= i2c_device_remove,
	.shutdown	= i2c_device_shutdown,
	.pm		= &amp;i2c_device_pm_ops,
};
EXPORT_SYMBOL_GPL(i2c_bus_type);

static struct device_type i2c_client_type = {
	.groups		= i2c_dev_attr_groups,
	.uevent		= i2c_device_uevent,
	.release	= i2c_client_dev_release,
};
</rich_text></node></node><node name="linux设备模型" prog_lang="custom-colors" readonly="False" tags="" unique_id="9"><rich_text>
</rich_text><node name="kobject，kset，ktype" prog_lang="custom-colors" readonly="False" tags="" unique_id="13"><rich_text>一、sysfs文件系统下的每个目录对应于一个kobj，kset是kobj的封装，内嵌了一个kobj，其代表kset自身，ktype代表属性 操作集，但由于通用性，因此把ktype单独剥离出来，kobj，kset，ktype成为了各个驱动模型最底层的关联元素，并由此形成了sys下的各种 拓扑结构。
二、关于kobject
      首先看一下kobject的原型
          
 </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject {
</rich_text><rich_text foreground="#008080"> 2</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text>        *name;         </rich_text><rich_text foreground="#008000">//名字
</rich_text><rich_text foreground="#008080"> 3</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> list_head    entry;         </rich_text><rich_text foreground="#008000">//连接到kset建立层次结构
</rich_text><rich_text foreground="#008080"> 4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject        *parent;       </rich_text><rich_text foreground="#008000">//指向父节点，面向对象的层次架构
</rich_text><rich_text foreground="#008080"> 5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset        *kset;        
</rich_text><rich_text foreground="#008080"> 6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobj_type    *ktype;        </rich_text><rich_text foreground="#008000">//属性文件
</rich_text><rich_text foreground="#008080"> 7</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> sysfs_dirent    *sd;
</rich_text><rich_text foreground="#008080"> 8</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kref        kref;          </rich_text><rich_text foreground="#008000">//引用计数
</rich_text><rich_text foreground="#008080"> 9</rich_text><rich_text>     unsigned </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> state_initialized:</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;      </rich_text><rich_text foreground="#008000">//初始化状态...
</rich_text><rich_text foreground="#008080">10</rich_text><rich_text>     unsigned </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> state_in_sysfs:</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">11</rich_text><rich_text>     unsigned </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> state_add_uevent_sent:</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">12</rich_text><rich_text>     unsigned </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> state_remove_uevent_sent:</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">13</rich_text><rich_text>     unsigned </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> uevent_suppress:</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">14</rich_text><rich_text> };

   分析一下kobject的初始化过程
   初始化函数为
          
  </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> ---</rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> kobject_init_and_add(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kobj, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobj_type *ktype,  </rich_text><rich_text foreground="#008000">//参数为kobject和属性结构体
</rich_text><rich_text foreground="#008080">  2</rich_text><rich_text>              </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *parent, </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *fmt, ...)
</rich_text><rich_text foreground="#008080">  3</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">  4</rich_text><rich_text>     va_list args;
</rich_text><rich_text foreground="#008080">  5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080">  6</rich_text><rich_text>     kobject_init(kobj, ktype);   
</rich_text><rich_text foreground="#008080">  7</rich_text><rich_text>     va_start(args, fmt);
</rich_text><rich_text foreground="#008080">  8</rich_text><rich_text>     retval = kobject_add_varg(kobj, parent, fmt, args);
</rich_text><rich_text foreground="#008080">  9</rich_text><rich_text>     va_end(args);
</rich_text><rich_text foreground="#008080"> 10</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080"> 11</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 12</rich_text><rich_text> ---</rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> kobject_init(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kobj, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobj_type *ktype)
</rich_text><rich_text foreground="#008080"> 13</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 14</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *err_str;
</rich_text><rich_text foreground="#008080"> 15</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!kobj) {                        </rich_text><rich_text foreground="#008000">//kobj为NULL错误退出
</rich_text><rich_text foreground="#008080"> 16</rich_text><rich_text>         err_str = </rich_text><rich_text foreground="#800000">&quot;invalid kobject pointer!&quot;</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 17</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080"> 18</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 19</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!ktype) {                       </rich_text><rich_text foreground="#008000">//ktype为NULL错误退出
</rich_text><rich_text foreground="#008080"> 20</rich_text><rich_text>         err_str = </rich_text><rich_text foreground="#800000">&quot;must have a ktype to be initialized properly!/n&quot;</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 21</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080"> 22</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 23</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (kobj-&gt;state_initialized) {   </rich_text><rich_text foreground="#008000">//如果初始化状态为1报错
</rich_text><rich_text foreground="#008080"> 24</rich_text><rich_text>         </rich_text><rich_text foreground="#008000">/* do not error out as sometimes we can recover */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 25</rich_text><rich_text>         printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;kobject (%p): tried to init an initialized &quot;</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 26</rich_text><rich_text>                </rich_text><rich_text foreground="#800000">&quot;object, something is seriously wrong./n&quot;</rich_text><rich_text>, kobj);
</rich_text><rich_text foreground="#008080"> 27</rich_text><rich_text>         dump_stack();
</rich_text><rich_text foreground="#008080"> 28</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 29</rich_text><rich_text>     kobject_init_internal(kobj);       </rich_text><rich_text foreground="#008000">//初始化kobj 
</rich_text><rich_text foreground="#008080"> 30</rich_text><rich_text>     kobj-&gt;ktype = ktype;            </rich_text><rich_text foreground="#008000">//关联obj和ktype
</rich_text><rich_text foreground="#008080"> 31</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 32</rich_text><rich_text> error:
</rich_text><rich_text foreground="#008080"> 33</rich_text><rich_text>     printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;kobject (%p): %s/n&quot;</rich_text><rich_text>, kobj, err_str);
</rich_text><rich_text foreground="#008080"> 34</rich_text><rich_text>     dump_stack();
</rich_text><rich_text foreground="#008080"> 35</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 36</rich_text><rich_text> -------</rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> kobject_init_internal(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kobj)
</rich_text><rich_text foreground="#008080"> 37</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 38</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!kobj)
</rich_text><rich_text foreground="#008080"> 39</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 40</rich_text><rich_text>     kref_init(&amp;kobj-&gt;kref);        </rich_text><rich_text foreground="#008000">//计数变成1
</rich_text><rich_text foreground="#008080"> 41</rich_text><rich_text>     INIT_LIST_HEAD(&amp;kobj-&gt;entry);  </rich_text><rich_text foreground="#008000">//都指向自己，prev和next
</rich_text><rich_text foreground="#008080"> 42</rich_text><rich_text>     kobj-&gt;state_in_sysfs = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 43</rich_text><rich_text>     kobj-&gt;state_add_uevent_sent = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 44</rich_text><rich_text>     kobj-&gt;state_remove_uevent_sent = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 45</rich_text><rich_text>     kobj-&gt;state_initialized = </rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 46</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 47</rich_text><rich_text> -------</rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> kobject_add_varg(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kobj, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *parent,
</rich_text><rich_text foreground="#008080"> 48</rich_text><rich_text>                 </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *fmt, va_list vargs)
</rich_text><rich_text foreground="#008080"> 49</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 50</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080"> 51</rich_text><rich_text>     retval = kobject_set_name_vargs(kobj, fmt, vargs);  </rich_text><rich_text foreground="#008000">//设置名字，名字中不能有“/”
</rich_text><rich_text foreground="#008080"> 52</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval) {
</rich_text><rich_text foreground="#008080"> 53</rich_text><rich_text>         printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;kobject: can not set name properly!/n&quot;</rich_text><rich_text>);
</rich_text><rich_text foreground="#008080"> 54</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080"> 55</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 56</rich_text><rich_text>     kobj-&gt;parent = parent;                 </rich_text><rich_text foreground="#008000">//设置parent，其父节点
</rich_text><rich_text foreground="#008080"> 57</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> kobject_add_internal(kobj);
</rich_text><rich_text foreground="#008080"> 58</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 59</rich_text><rich_text> ----</rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> kobject_add_internal(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kobj)
</rich_text><rich_text foreground="#008080"> 60</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 61</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 62</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *parent;
</rich_text><rich_text foreground="#008080"> 63</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!kobj)
</rich_text><rich_text foreground="#008080"> 64</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -ENOENT;
</rich_text><rich_text foreground="#008080"> 65</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!kobj-&gt;name || !kobj-&gt;name[</rich_text><rich_text foreground="#800080">0</rich_text><rich_text>]) {             </rich_text><rich_text foreground="#008000">//名字不能为空
</rich_text><rich_text foreground="#008080"> 66</rich_text><rich_text>         WARN(</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>, </rich_text><rich_text foreground="#800000">&quot;kobject: (%p): attempted to be registered with empty &quot;</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 67</rich_text><rich_text>              </rich_text><rich_text foreground="#800000">&quot;name!/n&quot;</rich_text><rich_text>, kobj);
</rich_text><rich_text foreground="#008080"> 68</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -EINVAL;
</rich_text><rich_text foreground="#008080"> 69</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 70</rich_text><rich_text>     parent = kobject_get(kobj-&gt;parent);  </rich_text><rich_text foreground="#008000">//如果parent为真，则增加kobj-&gt;kref计数，也就是父节点的引用计数
</rich_text><rich_text foreground="#008080"> 71</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* join kset if set, use it as parent if we do not already have one */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 72</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (kobj-&gt;kset) {                   
</rich_text><rich_text foreground="#008080"> 73</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!parent)
</rich_text><rich_text foreground="#008080"> 74</rich_text><rich_text>             parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);  </rich_text><rich_text foreground="#008000">//如果kobj-parent父节点为NULL那么就用kobj-&gt;kset-&gt;kobj
</rich_text><rich_text foreground="#008080"> 75</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//  作其父节点，并增加其引用计数
</rich_text><rich_text foreground="#008080"> 76</rich_text><rich_text>         kobj_kset_join(kobj);                         </rich_text><rich_text foreground="#008000">//把kobj的entry成员添加到kobj-&gt;kset&gt;list的尾部，现在的层次就是
</rich_text><rich_text foreground="#008080"> 77</rich_text><rich_text>         kobj-&gt;parent = parent;                     </rich_text><rich_text foreground="#008000">//kobj-&gt;kset-&gt;list指向kobj-&gt;parent 
</rich_text><rich_text foreground="#008080"> 78</rich_text><rich_text>     }                                                     </rich_text><rich_text foreground="#008000">//    -&gt;parent 指向kset-&gt;kobj                          
</rich_text><rich_text foreground="#008080"> 79</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;kobject: '%s' (%p): %s: parent: '%s', set: '%s'/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080"> 80</rich_text><rich_text>          kobject_name(kobj), kobj, __func__,
</rich_text><rich_text foreground="#008080"> 81</rich_text><rich_text>          parent ? kobject_name(parent) : </rich_text><rich_text foreground="#800000">&quot;&lt;NULL&gt;&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080"> 82</rich_text><rich_text>          kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : </rich_text><rich_text foreground="#800000">&quot;&lt;NULL&gt;&quot;</rich_text><rich_text>);
</rich_text><rich_text foreground="#008080"> 83</rich_text><rich_text>     error = create_dir(kobj);   </rich_text><rich_text foreground="#008000">//利用kobj创建目录和属性文件，其中会判断，如果parent为NULL那么就在sysfs_root下创建
</rich_text><rich_text foreground="#008080"> 84</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error) {
</rich_text><rich_text foreground="#008080"> 85</rich_text><rich_text>         kobj_kset_leave(kobj);
</rich_text><rich_text foreground="#008080"> 86</rich_text><rich_text>         kobject_put(parent);
</rich_text><rich_text foreground="#008080"> 87</rich_text><rich_text>         kobj-&gt;parent = NULL;
</rich_text><rich_text foreground="#008080"> 88</rich_text><rich_text>         </rich_text><rich_text foreground="#008000">/* be noisy on error issues */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 89</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error == -EEXIST)
</rich_text><rich_text foreground="#008080"> 90</rich_text><rich_text>             printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;%s failed for %s with &quot;</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 91</rich_text><rich_text>                    </rich_text><rich_text foreground="#800000">&quot;-EEXIST, don't try to register things with &quot;</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 92</rich_text><rich_text>                    </rich_text><rich_text foreground="#800000">&quot;the same name in the same directory./n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080"> 93</rich_text><rich_text>                    __func__, kobject_name(kobj));
</rich_text><rich_text foreground="#008080"> 94</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">else</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 95</rich_text><rich_text>             printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;%s failed for %s (%d)/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080"> 96</rich_text><rich_text>                    __func__, kobject_name(kobj), error);
</rich_text><rich_text foreground="#008080"> 97</rich_text><rich_text>         dump_stack();
</rich_text><rich_text foreground="#008080"> 98</rich_text><rich_text>     } </rich_text><rich_text foreground="#0000ff">else</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 99</rich_text><rich_text>         kobj-&gt;state_in_sysfs = </rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">100</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080">101</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">102</rich_text><rich_text> ---</rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> create_dir(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kobj)
</rich_text><rich_text foreground="#008080">103</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">104</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">105</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (kobject_name(kobj)) {
</rich_text><rich_text foreground="#008080">106</rich_text><rich_text>         error = sysfs_create_dir(kobj);       </rich_text><rich_text foreground="#008000">//创建目录
</rich_text><rich_text foreground="#008080">107</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!error) {
</rich_text><rich_text foreground="#008080">108</rich_text><rich_text>             error = populate_dir(kobj);   </rich_text><rich_text foreground="#008000">//创建属性文件
</rich_text><rich_text foreground="#008080">109</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080">110</rich_text><rich_text>                 sysfs_remove_dir(kobj);
</rich_text><rich_text foreground="#008080">111</rich_text><rich_text>         }
</rich_text><rich_text foreground="#008080">112</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">113</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080">114</rich_text><rich_text> }
 
三、关于 kset
      首先看一下kset的原型
         
</rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset {
</rich_text><rich_text foreground="#008080">2</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> list_head list;  </rich_text><rich_text foreground="#008000">//连接着他下面的kobj成员，与kobj-entry关联
</rich_text><rich_text foreground="#008080">3</rich_text><rich_text>     spinlock_t list_lock;
</rich_text><rich_text foreground="#008080">4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject kobj;    </rich_text><rich_text foreground="#008000">//代表kset自己
</rich_text><rich_text foreground="#008080">5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset_uevent_ops *uevent_ops;
</rich_text><rich_text foreground="#008080">6</rich_text><rich_text> };

       再来看一下kset的初始化操作，kset表现为更高级一点的kobj，其初始化操作仍然是围绕其内部的kobj展开的。
 </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *kset_create_and_add(</rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *name,
</rich_text><rich_text foreground="#008080"> 2</rich_text><rich_text>                  </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset_uevent_ops *uevent_ops,
</rich_text><rich_text foreground="#008080"> 3</rich_text><rich_text>                  </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *parent_kobj)
</rich_text><rich_text foreground="#008080"> 4</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *kset;
</rich_text><rich_text foreground="#008080"> 6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080"> 7</rich_text><rich_text>     kset = kset_create(name, uevent_ops, parent_kobj);  </rich_text><rich_text foreground="#008000">//创建kset，关联操作函数和其父节点
</rich_text><rich_text foreground="#008080"> 8</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!kset)
</rich_text><rich_text foreground="#008080"> 9</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> NULL;
</rich_text><rich_text foreground="#008080">10</rich_text><rich_text>     error = kset_register(kset);
</rich_text><rich_text foreground="#008080">11</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error) {
</rich_text><rich_text foreground="#008080">12</rich_text><rich_text>         kfree(kset);
</rich_text><rich_text foreground="#008080">13</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> NULL;
</rich_text><rich_text foreground="#008080">14</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">15</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> kset;
</rich_text><rich_text foreground="#008080">16</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">17</rich_text><rich_text> ---</rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *kset_create(</rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *name,
</rich_text><rich_text foreground="#008080">18</rich_text><rich_text>                 </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset_uevent_ops *uevent_ops,
</rich_text><rich_text foreground="#008080">19</rich_text><rich_text>                 </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *parent_kobj)
</rich_text><rich_text foreground="#008080">20</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">21</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *kset;
</rich_text><rich_text foreground="#008080">22</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080">23</rich_text><rich_text>     kset = kzalloc(</rich_text><rich_text foreground="#0000ff">sizeof</rich_text><rich_text>(*kset), GFP_KERNEL);  </rich_text><rich_text foreground="#008000">//申请结构体内存
</rich_text><rich_text foreground="#008080">24</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!kset)
</rich_text><rich_text foreground="#008080">25</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> NULL;
</rich_text><rich_text foreground="#008080">26</rich_text><rich_text>     retval = kobject_set_name(&amp;kset-&gt;kobj, name);  </rich_text><rich_text foreground="#008000">//设置名字
</rich_text><rich_text foreground="#008080">27</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval) {
</rich_text><rich_text foreground="#008080">28</rich_text><rich_text>         kfree(kset);
</rich_text><rich_text foreground="#008080">29</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> NULL;
</rich_text><rich_text foreground="#008080">30</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">31</rich_text><rich_text>     kset-&gt;uevent_ops = uevent_ops;               </rich_text><rich_text foreground="#008000">//关联操作函数
</rich_text><rich_text foreground="#008080">32</rich_text><rich_text>     kset-&gt;kobj.parent = parent_kobj;             </rich_text><rich_text foreground="#008000">//关联父节点
</rich_text><rich_text foreground="#008080">33</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/*
</rich_text><rich_text foreground="#008080">34</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * The kobject of this kset will have a type of kset_ktype and belong to
</rich_text><rich_text foreground="#008080">35</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * no kset itself.  That way we can properly free it when it is
</rich_text><rich_text foreground="#008080">36</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * finished being used.
</rich_text><rich_text foreground="#008080">37</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">38</rich_text><rich_text>     kset-&gt;kobj.ktype = &amp;kset_ktype;            </rich_text><rich_text foreground="#008000">//关联属性文件
</rich_text><rich_text foreground="#008080">39</rich_text><rich_text>     kset-&gt;kobj.kset = NULL;                    
</rich_text><rich_text foreground="#008080">40</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> kset;
</rich_text><rich_text foreground="#008080">41</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">42</rich_text><rich_text> ----</rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> kset_register(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *k)
</rich_text><rich_text foreground="#008080">43</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">44</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> err;
</rich_text><rich_text foreground="#008080">45</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!k)
</rich_text><rich_text foreground="#008080">46</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -EINVAL;
</rich_text><rich_text foreground="#008080">47</rich_text><rich_text>     kset_init(k);
</rich_text><rich_text foreground="#008080">48</rich_text><rich_text>     err = kobject_add_internal(&amp;k-&gt;kobj);     </rich_text><rich_text foreground="#008000">//调用kobj操作函数    
</rich_text><rich_text foreground="#008080">49</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (err)
</rich_text><rich_text foreground="#008080">50</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> err;
</rich_text><rich_text foreground="#008080">51</rich_text><rich_text>     kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD);
</rich_text><rich_text foreground="#008080">52</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">53</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">54</rich_text><rich_text> ----</rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> kset_init(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *k)
</rich_text><rich_text foreground="#008080">55</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">56</rich_text><rich_text>     kobject_init_internal(&amp;k-&gt;kobj);          </rich_text><rich_text foreground="#008000">//调用kobj操作函数
</rich_text><rich_text foreground="#008080">57</rich_text><rich_text>     INIT_LIST_HEAD(&amp;k-&gt;list);
</rich_text><rich_text foreground="#008080">58</rich_text><rich_text>     spin_lock_init(&amp;k-&gt;list_lock);
</rich_text><rich_text foreground="#008080">59</rich_text><rich_text> }</rich_text></node><node name="bus，device，driver分析(一)" prog_lang="custom-colors" readonly="False" tags="" unique_id="12"><rich_text>  内核的开发者将总线，设备，驱动这三者用软件思想抽象了出来，巧妙的建立了其间的关系，使之更形象化。结合前面所学的知识，总的来说其三者间的关系为 bus有两条链表，分别用于挂接设备和驱动，指定了其自身bus的device或者driver最后都会分别连接到对应bus的这两条链表上，而总线又有 其始端，为bus_kset，一个driver可以对应于几个设备，因此driver同样有其设备链表，用于挂接可以操作的设备，其自身也有bus挂接 点，用于将自身挂接到对应bus（每个driver只属于一条总线），而对于device，一个设备只属于一条总线，只能有一个driver与其对应，因 此对于device，都是单一的，一个driver挂接点，一个bus挂接点，device与bus相同的是都有始端，device为 devices_kset，因此device的注册同时会出现在对应的bus目录和device总目录下。好了，下面就以源码为例分别分析一下 bus，device，driver的注册过程。
 
一、bus的注册
      bus的注册比较简单，首先来看一下bus的结构：
     
 </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type {
</rich_text><rich_text foreground="#008080"> 2</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text>        *name;                </rich_text><rich_text foreground="#008000">//名字
</rich_text><rich_text foreground="#008080"> 3</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_attribute    *bus_attrs;           </rich_text><rich_text foreground="#008000">//bus属性集
</rich_text><rich_text foreground="#008080"> 4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_attribute    *dev_attrs;           </rich_text><rich_text foreground="#008000">//device属性集
</rich_text><rich_text foreground="#008080"> 5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> driver_attribute    *drv_attrs;           </rich_text><rich_text foreground="#008000">//driver属性集
</rich_text><rich_text foreground="#008080"> 6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*match)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv);
</rich_text><rich_text foreground="#008080"> 7</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*uevent)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobj_uevent_env *env);
</rich_text><rich_text foreground="#008080"> 8</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*probe)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080"> 9</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*remove)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">10</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> (*shutdown)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">11</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*suspend)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev, pm_message_t state);
</rich_text><rich_text foreground="#008080">12</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*resume)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">13</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> dev_pm_ops *pm;
</rich_text><rich_text foreground="#008080">14</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type_private *p;                   </rich_text><rich_text foreground="#008000">//bus的私有成员
</rich_text><rich_text foreground="#008080">15</rich_text><rich_text> };
</rich_text><rich_text foreground="#008080">16</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//其中重点看一下私有成员结构体：
</rich_text><rich_text foreground="#008080">17</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type_private {
</rich_text><rich_text foreground="#008080">18</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset subsys;                           </rich_text><rich_text foreground="#008000">//bus内嵌的kset，代表其自身
</rich_text><rich_text foreground="#008080">19</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *drivers_kset;                    
</rich_text><rich_text foreground="#008080">20</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *devices_kset;
</rich_text><rich_text foreground="#008080">21</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist klist_devices;                   </rich_text><rich_text foreground="#008000">//包含devices链表及其操作函数
</rich_text><rich_text foreground="#008080">22</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist klist_drivers;                   </rich_text><rich_text foreground="#008000">//driver链表及其操作函数
</rich_text><rich_text foreground="#008080">23</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> blocking_notifier_head bus_notifier;
</rich_text><rich_text foreground="#008080">24</rich_text><rich_text>     unsigned </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> drivers_autoprobe:</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;              </rich_text><rich_text foreground="#008000">//匹配成功自动初始化标志
</rich_text><rich_text foreground="#008080">25</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus;                          
</rich_text><rich_text foreground="#008080">26</rich_text><rich_text> };
  无论是bus，driver，还是device其本身特征都放在私有成员里，其注册时，都会申请并填充这个结构体，下面具体分析一下bus的注册流程，从bus_register开始：
     
</rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> bus_register(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus)
</rich_text><rich_text foreground="#008080"> 2</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 3</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080"> 4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type_private *priv;
</rich_text><rich_text foreground="#008080"> 5</rich_text><rich_text>     priv = kzalloc(</rich_text><rich_text foreground="#0000ff">sizeof</rich_text><rich_text>(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type_private), GFP_KERNEL);    </rich_text><rich_text foreground="#008000">//进入时bus_type-&gt;bus_type_private为NULL
</rich_text><rich_text foreground="#008080"> 6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!priv)                                                      </rich_text><rich_text foreground="#008000">//该函数主要是对其的设置
</rich_text><rich_text foreground="#008080"> 7</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -ENOMEM;
</rich_text><rich_text foreground="#008080"> 8</rich_text><rich_text>     priv-&gt;bus = bus;                                                </rich_text><rich_text foreground="#008000">//私有成员的bus回指该bus
</rich_text><rich_text foreground="#008080"> 9</rich_text><rich_text>     bus-&gt;p = priv;                                                  </rich_text><rich_text foreground="#008000">//初始化bus-&gt;p,即其私有属性
</rich_text><rich_text foreground="#008080">10</rich_text><rich_text>     BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);
</rich_text><rich_text foreground="#008080">11</rich_text><rich_text>     retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, </rich_text><rich_text foreground="#800000">&quot;%s&quot;</rich_text><rich_text>, bus-&gt;name);  </rich_text><rich_text foreground="#008000">//设置该bus的名字，bus是kset的封装
</rich_text><rich_text foreground="#008080">12</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval)
</rich_text><rich_text foreground="#008080">13</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">out</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">14</rich_text><rich_text>                                                       </rich_text><rich_text foreground="#008000">//bus_kset即为所有bus的总起始端点
</rich_text><rich_text foreground="#008080">15</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//围绕bus内嵌的kset初始化，和kset的初始化时围绕
</rich_text><rich_text foreground="#008080">16</rich_text><rich_text>     priv-&gt;subsys.kobj.kset = bus_kset;                </rich_text><rich_text foreground="#008000">//kobj相似，没有parent时，就会用kset的kobj，此处即是
</rich_text><rich_text foreground="#008080">17</rich_text><rich_text>     priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;                    </rich_text><rich_text foreground="#008000">//属性操作级别统一为bus_ktype
</rich_text><rich_text foreground="#008080">18</rich_text><rich_text>     priv-&gt;drivers_autoprobe = </rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;                                    </rich_text><rich_text foreground="#008000">//设置该标志，当有driver注册时，会自动匹配devices
</rich_text><rich_text foreground="#008080">19</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//上的设备并用probe初始化，
</rich_text><rich_text foreground="#008080">20</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//当有device注册时也同样找到  driver并会初始化
</rich_text><rich_text foreground="#008080">21</rich_text><rich_text>     retval = kset_register(&amp;priv-&gt;subsys);                          </rich_text><rich_text foreground="#008000">//注册kset，创建目录结构，以及层次关系
</rich_text><rich_text foreground="#008080">22</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval)
</rich_text><rich_text foreground="#008080">23</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">out</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">24</rich_text><rich_text>     retval = bus_create_file(bus, &amp;bus_attr_uevent);                </rich_text><rich_text foreground="#008000">//当前bus目录下生成bus_attr_uevent属性文件
</rich_text><rich_text foreground="#008080">25</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval)
</rich_text><rich_text foreground="#008080">26</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> bus_uevent_fail;
</rich_text><rich_text foreground="#008080">27</rich_text><rich_text>     priv-&gt;devices_kset = kset_create_and_add(</rich_text><rich_text foreground="#800000">&quot;devices&quot;</rich_text><rich_text>, NULL,       </rich_text><rich_text foreground="#008000">//初始化bus目录下的devices目录，里面级联了该bus下设备，
</rich_text><rich_text foreground="#008080">28</rich_text><rich_text>                          &amp;priv-&gt;subsys.kobj);                    </rich_text><rich_text foreground="#008000">//仍然以kset为原型
</rich_text><rich_text foreground="#008080">29</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!priv-&gt;devices_kset) {
</rich_text><rich_text foreground="#008080">30</rich_text><rich_text>         retval = -ENOMEM;
</rich_text><rich_text foreground="#008080">31</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> bus_devices_fail;
</rich_text><rich_text foreground="#008080">32</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">33</rich_text><rich_text>     priv-&gt;drivers_kset = kset_create_and_add(</rich_text><rich_text foreground="#800000">&quot;drivers&quot;</rich_text><rich_text>, NULL,       </rich_text><rich_text foreground="#008000">//初始化bus目录下的drivers目录，里面级联了该bus下设备的driver
</rich_text><rich_text foreground="#008080">34</rich_text><rich_text>                          &amp;priv-&gt;subsys.kobj);
</rich_text><rich_text foreground="#008080">35</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!priv-&gt;drivers_kset) {
</rich_text><rich_text foreground="#008080">36</rich_text><rich_text>         retval = -ENOMEM;
</rich_text><rich_text foreground="#008080">37</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> bus_drivers_fail;
</rich_text><rich_text foreground="#008080">38</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">39</rich_text><rich_text>     klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);  </rich_text><rich_text foreground="#008000">//初始化klist_devices里的操作函数成员
</rich_text><rich_text foreground="#008080">40</rich_text><rich_text>     klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);                            </rich_text><rich_text foreground="#008000">//klist_drivers里的操作函数置空
</rich_text><rich_text foreground="#008080">41</rich_text><rich_text>     retval = add_probe_files(bus);                                           </rich_text><rich_text foreground="#008000">//增加bus_attr_drivers_probe和bus_attr_drivers_autoprobe
</rich_text><rich_text foreground="#008080">42</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval)                                                              </rich_text><rich_text foreground="#008000">//属性文件
</rich_text><rich_text foreground="#008080">43</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> bus_probe_files_fail;
</rich_text><rich_text foreground="#008080">44</rich_text><rich_text>     retval = bus_add_attrs(bus);                                             </rich_text><rich_text foreground="#008000">//增加默认的属性文件
</rich_text><rich_text foreground="#008080">45</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (retval)
</rich_text><rich_text foreground="#008080">46</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> bus_attrs_fail;
</rich_text><rich_text foreground="#008080">47</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;bus: '%s': registered/n&quot;</rich_text><rich_text>, bus-&gt;name);
</rich_text><rich_text foreground="#008080">48</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">49</rich_text><rich_text> bus_attrs_fail:                                                               </rich_text><rich_text foreground="#008000">//以下为错误处理
</rich_text><rich_text foreground="#008080">50</rich_text><rich_text>     remove_probe_files(bus);
</rich_text><rich_text foreground="#008080">51</rich_text><rich_text> bus_probe_files_fail:
</rich_text><rich_text foreground="#008080">52</rich_text><rich_text>     kset_unregister(bus-&gt;p-&gt;drivers_kset);
</rich_text><rich_text foreground="#008080">53</rich_text><rich_text> bus_drivers_fail:
</rich_text><rich_text foreground="#008080">54</rich_text><rich_text>     kset_unregister(bus-&gt;p-&gt;devices_kset);
</rich_text><rich_text foreground="#008080">55</rich_text><rich_text> bus_devices_fail:
</rich_text><rich_text foreground="#008080">56</rich_text><rich_text>     bus_remove_file(bus, &amp;bus_attr_uevent);
</rich_text><rich_text foreground="#008080">57</rich_text><rich_text> bus_uevent_fail:
</rich_text><rich_text foreground="#008080">58</rich_text><rich_text>     kset_unregister(&amp;bus-&gt;p-&gt;subsys);
</rich_text><rich_text foreground="#008080">59</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">out</rich_text><rich_text>:
</rich_text><rich_text foreground="#008080">60</rich_text><rich_text>     kfree(bus-&gt;p);
</rich_text><rich_text foreground="#008080">61</rich_text><rich_text>     bus-&gt;p = NULL;
</rich_text><rich_text foreground="#008080">62</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> retval;
</rich_text><rich_text foreground="#008080">63</rich_text><rich_text> }
    由此可见，bus又是kset的封装，bus_register主要完成了其私有成员bus_type_private的初始化，并初始化了其下的两个目 录devices和drivers，及其属性文件，bus有个自己的根目录也就是bus有个起始端点，是bus_kset，经过此番的注册，bus目录下 将会出现我们注册的bus，并且其下会有device和driver两个子目录，代表它下面的driver和device链表。
二、driver的注册
  下面看一下driver是怎么和bus关联起来的，首先看下driver的结构：
    
 </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver {
</rich_text><rich_text foreground="#008080"> 2</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text>        *name;            </rich_text><rich_text foreground="#008000">//名字
</rich_text><rich_text foreground="#008080"> 3</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type        *bus;        </rich_text><rich_text foreground="#008000">//其所在的bus
</rich_text><rich_text foreground="#008080"> 4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> module        *owner;
</rich_text><rich_text foreground="#008080"> 5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text>        *mod_name;    </rich_text><rich_text foreground="#008000">/* used for built-in modules */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">bool</rich_text><rich_text> suppress_bind_attrs;    </rich_text><rich_text foreground="#008000">/* disables bind/unbind via sysfs */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 7</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">#if</rich_text><rich_text> defined(CONFIG_OF)
</rich_text><rich_text foreground="#008080"> 8</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> of_device_id    *of_match_table;
</rich_text><rich_text foreground="#008080"> 9</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">#endif</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">10</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*probe) (</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);        </rich_text><rich_text foreground="#008000">//匹配成功时可能会调用到的函数
</rich_text><rich_text foreground="#008080">11</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*remove) (</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">12</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> (*shutdown) (</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">13</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*suspend) (</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev, pm_message_t state);
</rich_text><rich_text foreground="#008080">14</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*resume) (</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">15</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> attribute_group **groups;
</rich_text><rich_text foreground="#008080">16</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> dev_pm_ops *pm;
</rich_text><rich_text foreground="#008080">17</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> driver_private *p;                 </rich_text><rich_text foreground="#008000">//私有成员，表示driver
</rich_text><rich_text foreground="#008080">18</rich_text><rich_text> };
</rich_text><rich_text foreground="#008080">19</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//重点看下driver的私有成员
</rich_text><rich_text foreground="#008080">20</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> driver_private {
</rich_text><rich_text foreground="#008080">21</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject kobj;                      </rich_text><rich_text foreground="#008000">//代表driver自身
</rich_text><rich_text foreground="#008080">22</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist klist_devices;               </rich_text><rich_text foreground="#008000">//可以操控的设备链表
</rich_text><rich_text foreground="#008080">23</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_node knode_bus;              </rich_text><rich_text foreground="#008000">//挂接到bus的节点
</rich_text><rich_text foreground="#008080">24</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> module_kobject *mkobj;             </rich_text><rich_text foreground="#008000">//模块相关
</rich_text><rich_text foreground="#008080">25</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *driver;             </rich_text><rich_text foreground="#008000">//回指该driver
</rich_text><rich_text foreground="#008080">26</rich_text><rich_text> };
  如同bus一样，重点的仍是可以代表其自身的私有属性，下面具体看一下driver的注册过程，从driver_register开始：
    
  </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> driver_register(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv)
</rich_text><rich_text foreground="#008080">  2</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">  3</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080">  4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *other;
</rich_text><rich_text foreground="#008080">  5</rich_text><rich_text>     BUG_ON(!drv-&gt;bus-&gt;p);
</rich_text><rich_text foreground="#008080">  6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||           </rich_text><rich_text foreground="#008000">//driver和bus的同名操作函数如果同时存在，会出现警告
</rich_text><rich_text foreground="#008080">  7</rich_text><rich_text>         (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||         </rich_text><rich_text foreground="#008000">//并且会优先选用bus的
</rich_text><rich_text foreground="#008080">  8</rich_text><rich_text>         (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))
</rich_text><rich_text foreground="#008080">  9</rich_text><rich_text>         printk(KERN_WARNING </rich_text><rich_text foreground="#800000">&quot;Driver '%s' needs updating - please use &quot;</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 10</rich_text><rich_text>             </rich_text><rich_text foreground="#800000">&quot;bus_type methods/n&quot;</rich_text><rich_text>, drv-&gt;name);
</rich_text><rich_text foreground="#008080"> 11</rich_text><rich_text>     other = driver_find(drv-&gt;name, drv-&gt;bus);        </rich_text><rich_text foreground="#008000">//进入bus的driver链表，确认该driver是否已经注册
</rich_text><rich_text foreground="#008080"> 12</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (other) {
</rich_text><rich_text foreground="#008080"> 13</rich_text><rich_text>         put_driver(other);                            </rich_text><rich_text foreground="#008000">//找到了再减少引用计数，并且报错退出
</rich_text><rich_text foreground="#008080"> 14</rich_text><rich_text>         printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;Error: Driver '%s' is already registered, &quot;</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 15</rich_text><rich_text>             </rich_text><rich_text foreground="#800000">&quot;aborting.../n&quot;</rich_text><rich_text>, drv-&gt;name);
</rich_text><rich_text foreground="#008080"> 16</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -EBUSY;
</rich_text><rich_text foreground="#008080"> 17</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 18</rich_text><rich_text>     ret = bus_add_driver(drv);                       </rich_text><rich_text foreground="#008000">//如果没有注册，那么把该driver加入所在bus
</rich_text><rich_text foreground="#008080"> 19</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (ret)
</rich_text><rich_text foreground="#008080"> 20</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080"> 21</rich_text><rich_text>     ret = driver_add_groups(drv, drv-&gt;groups);
</rich_text><rich_text foreground="#008080"> 22</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (ret)
</rich_text><rich_text foreground="#008080"> 23</rich_text><rich_text>         bus_remove_driver(drv);
</rich_text><rich_text foreground="#008080"> 24</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080"> 25</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 26</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/****************************************************
</rich_text><rich_text foreground="#008080"> 27</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 跟踪一下driver_find(drv-&gt;name, drv-&gt;bus)
</rich_text><rich_text foreground="#008080"> 28</rich_text><rich_text> </rich_text><rich_text foreground="#008000">****************************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 29</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *driver_find(</rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *name, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus)
</rich_text><rich_text foreground="#008080"> 30</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 31</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *k = kset_find_obj(bus-&gt;p-&gt;drivers_kset, name);  </rich_text><rich_text foreground="#008000">//bus-&gt;p-&gt;drivers_kset代表bus下
</rich_text><rich_text foreground="#008080"> 32</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> driver_private *priv;                                    </rich_text><rich_text foreground="#008000">//的driver目录，此处会遍历bus的    
</rich_text><rich_text foreground="#008080"> 33</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//driver链表，通过driver内嵌的
</rich_text><rich_text foreground="#008080"> 34</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (k) {                                                        </rich_text><rich_text foreground="#008000">//kobj名字比较
</rich_text><rich_text foreground="#008080"> 35</rich_text><rich_text>         priv = to_driver(k);
</rich_text><rich_text foreground="#008080"> 36</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> priv-&gt;driver;                                 </rich_text><rich_text foreground="#008000">//如果找到同名的kobj那么返回该driver
</rich_text><rich_text foreground="#008080"> 37</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 38</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> NULL;
</rich_text><rich_text foreground="#008080"> 39</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 40</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//看一下kset_find_obj吧:
</rich_text><rich_text foreground="#008080"> 41</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *kset_find_obj(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kset *kset, </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text> *name)
</rich_text><rich_text foreground="#008080"> 42</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 43</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *k;
</rich_text><rich_text foreground="#008080"> 44</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject *ret = NULL;
</rich_text><rich_text foreground="#008080"> 45</rich_text><rich_text>     spin_lock(&amp;kset-&gt;list_lock);
</rich_text><rich_text foreground="#008080"> 46</rich_text><rich_text>     list_for_each_entry(k, &amp;kset-&gt;list, entry) {                   </rich_text><rich_text foreground="#008000">//遍历bus下的driver链表，如果
</rich_text><rich_text foreground="#008080"> 47</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (kobject_name(k) &amp;&amp; !strcmp(kobject_name(k), name)) {   </rich_text><rich_text foreground="#008000">//找到那么返回找到的kobj，并且把
</rich_text><rich_text foreground="#008080"> 48</rich_text><rich_text>             ret = kobject_get(k);                                  </rich_text><rich_text foreground="#008000">//该driver的kobj引用计数+1
</rich_text><rich_text foreground="#008080"> 49</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">break</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 50</rich_text><rich_text>         }
</rich_text><rich_text foreground="#008080"> 51</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 52</rich_text><rich_text>     spin_unlock(&amp;kset-&gt;list_lock);
</rich_text><rich_text foreground="#008080"> 53</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080"> 54</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 55</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/************************************************
</rich_text><rich_text foreground="#008080"> 56</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 再来跟踪一下driver_register里面的另外一个函数
</rich_text><rich_text foreground="#008080"> 57</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× bus_add_driver(drv)
</rich_text><rich_text foreground="#008080"> 58</rich_text><rich_text> </rich_text><rich_text foreground="#008000">************************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 59</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> bus_add_driver(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv) 
</rich_text><rich_text foreground="#008080"> 60</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 61</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus;
</rich_text><rich_text foreground="#008080"> 62</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> driver_private *priv;
</rich_text><rich_text foreground="#008080"> 63</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080"> 64</rich_text><rich_text>     bus = bus_get(drv-&gt;bus);                                        </rich_text><rich_text foreground="#008000">//取得其所在bus的指针
</rich_text><rich_text foreground="#008080"> 65</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!bus)
</rich_text><rich_text foreground="#008080"> 66</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -EINVAL;
</rich_text><rich_text foreground="#008080"> 67</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;bus: '%s': add driver %s/n&quot;</rich_text><rich_text>, bus-&gt;name, drv-&gt;name);   </rich_text><rich_text foreground="#008000">//开始初始化这个driver的私有成员，
</rich_text><rich_text foreground="#008080"> 68</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//和bus类似
</rich_text><rich_text foreground="#008080"> 69</rich_text><rich_text>     priv = kzalloc(</rich_text><rich_text foreground="#0000ff">sizeof</rich_text><rich_text>(*priv), GFP_KERNEL);
</rich_text><rich_text foreground="#008080"> 70</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!priv) {
</rich_text><rich_text foreground="#008080"> 71</rich_text><rich_text>         error = -ENOMEM;
</rich_text><rich_text foreground="#008080"> 72</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> out_put_bus;
</rich_text><rich_text foreground="#008080"> 73</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 74</rich_text><rich_text>     klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);                   </rich_text><rich_text foreground="#008000">//设备操作函数清空，设备链表初始化
</rich_text><rich_text foreground="#008080"> 75</rich_text><rich_text>     priv-&gt;driver = drv;                                             
</rich_text><rich_text foreground="#008080"> 76</rich_text><rich_text>     drv-&gt;p = priv;
</rich_text><rich_text foreground="#008080"> 77</rich_text><rich_text>     priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;                          </rich_text><rich_text foreground="#008000">//kset指定到bus下面
</rich_text><rich_text foreground="#008080"> 78</rich_text><rich_text>     error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,   </rich_text><rich_text foreground="#008000">//建立层次结构和属性文件
</rich_text><rich_text foreground="#008080"> 79</rich_text><rich_text>                      </rich_text><rich_text foreground="#800000">&quot;%s&quot;</rich_text><rich_text>, drv-&gt;name);
</rich_text><rich_text foreground="#008080"> 80</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 81</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> out_unregister;
</rich_text><rich_text foreground="#008080"> 82</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) {                            </rich_text><rich_text foreground="#008000">//bus的自动匹配如果设置为真，
</rich_text><rich_text foreground="#008080"> 83</rich_text><rich_text>         error = driver_attach(drv);                                  </rich_text><rich_text foreground="#008000">//那么到bus的devices上去匹配设备
</rich_text><rich_text foreground="#008080"> 84</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 85</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> out_unregister;
</rich_text><rich_text foreground="#008080"> 86</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 87</rich_text><rich_text>     klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);        </rich_text><rich_text foreground="#008000">//把driver挂接到bus的driver链表
</rich_text><rich_text foreground="#008080"> 88</rich_text><rich_text>     module_add_driver(drv-&gt;owner, drv);
</rich_text><rich_text foreground="#008080"> 89</rich_text><rich_text>     error = driver_create_file(drv, &amp;driver_attr_uevent);            </rich_text><rich_text foreground="#008000">//以下添加该driver相关属性文件
</rich_text><rich_text foreground="#008080"> 90</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error) {
</rich_text><rich_text foreground="#008080"> 91</rich_text><rich_text>         printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;%s: uevent attr (%s) failed/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080"> 92</rich_text><rich_text>             __func__, drv-&gt;name);
</rich_text><rich_text foreground="#008080"> 93</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 94</rich_text><rich_text>     error = driver_add_attrs(bus, drv);
</rich_text><rich_text foreground="#008080"> 95</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error) {
</rich_text><rich_text foreground="#008080"> 96</rich_text><rich_text>         </rich_text><rich_text foreground="#008000">/* How the hell do we get out of this pickle? Give up */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 97</rich_text><rich_text>         printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;%s: driver_add_attrs(%s) failed/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080"> 98</rich_text><rich_text>             __func__, drv-&gt;name);
</rich_text><rich_text foreground="#008080"> 99</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">100</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!drv-&gt;suppress_bind_attrs) {
</rich_text><rich_text foreground="#008080">101</rich_text><rich_text>         error = add_bind_files(drv);
</rich_text><rich_text foreground="#008080">102</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error) {
</rich_text><rich_text foreground="#008080">103</rich_text><rich_text>             </rich_text><rich_text foreground="#008000">/* Ditto */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">104</rich_text><rich_text>             printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;%s: add_bind_files(%s) failed/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">105</rich_text><rich_text>                 __func__, drv-&gt;name);
</rich_text><rich_text foreground="#008080">106</rich_text><rich_text>         }
</rich_text><rich_text foreground="#008080">107</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">108</rich_text><rich_text>     kobject_uevent(&amp;priv-&gt;kobj, KOBJ_ADD);
</rich_text><rich_text foreground="#008080">109</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">110</rich_text><rich_text> out_unregister:
</rich_text><rich_text foreground="#008080">111</rich_text><rich_text>     kobject_put(&amp;priv-&gt;kobj);
</rich_text><rich_text foreground="#008080">112</rich_text><rich_text>     kfree(drv-&gt;p);
</rich_text><rich_text foreground="#008080">113</rich_text><rich_text>     drv-&gt;p = NULL;
</rich_text><rich_text foreground="#008080">114</rich_text><rich_text> out_put_bus:
</rich_text><rich_text foreground="#008080">115</rich_text><rich_text>     bus_put(bus);
</rich_text><rich_text foreground="#008080">116</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080">117</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">118</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/****************************************************************
</rich_text><rich_text foreground="#008080">119</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 接下来就剩下最终要的匹配函数driver_attach(drv)了，我们来看一下：
</rich_text><rich_text foreground="#008080">120</rich_text><rich_text> </rich_text><rich_text foreground="#008000">****************************************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">121</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> driver_attach(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv)                            </rich_text><rich_text foreground="#008000">//遍历bus的设备链表找到
</rich_text><rich_text foreground="#008080">122</rich_text><rich_text> {                                                                       </rich_text><rich_text foreground="#008000">//合适的设备就调用__driver_attach，
</rich_text><rich_text foreground="#008080">123</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);      </rich_text><rich_text foreground="#008000">//NULL表示从头开始遍历
</rich_text><rich_text foreground="#008080">124</rich_text><rich_text> }  
</rich_text><rich_text foreground="#008080">125</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//============
</rich_text><rich_text foreground="#008080">126</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> bus_for_each_dev(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *start,
</rich_text><rich_text foreground="#008080">127</rich_text><rich_text>              </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *data, </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*fn)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *, </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *))
</rich_text><rich_text foreground="#008080">128</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">129</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_iter i;
</rich_text><rich_text foreground="#008080">130</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev;
</rich_text><rich_text foreground="#008080">131</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">132</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!bus)
</rich_text><rich_text foreground="#008080">133</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -EINVAL;
</rich_text><rich_text foreground="#008080">134</rich_text><rich_text>     klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,              </rich_text><rich_text foreground="#008000">//进入bus的devices链表
</rich_text><rich_text foreground="#008080">135</rich_text><rich_text>                  (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));
</rich_text><rich_text foreground="#008080">136</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">while</rich_text><rich_text> ((dev = next_device(&amp;i)) &amp;&amp; !error)                     </rich_text><rich_text foreground="#008000">//设备存在则调用fn即__driver_attach
</rich_text><rich_text foreground="#008080">137</rich_text><rich_text>         error = fn(dev, data);                                    </rich_text><rich_text foreground="#008000">//进行匹配
</rich_text><rich_text foreground="#008080">138</rich_text><rich_text>     klist_iter_exit(&amp;i);
</rich_text><rich_text foreground="#008080">139</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080">140</rich_text><rich_text> } 
</rich_text><rich_text foreground="#008080">141</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/*********************************************
</rich_text><rich_text foreground="#008080">142</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 接着看一下__driver_attach这个函数
</rich_text><rich_text foreground="#008080">143</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*********************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">144</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> __driver_attach(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev, </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *data)
</rich_text><rich_text foreground="#008080">145</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">146</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv = data;
</rich_text><rich_text foreground="#008080">147</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!driver_match_device(drv, dev))                </rich_text><rich_text foreground="#008000">//进行匹配
</rich_text><rich_text foreground="#008080">148</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">149</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;parent)    </rich_text><rich_text foreground="#008000">/* Needed for USB */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">150</rich_text><rich_text>         device_lock(dev-&gt;parent);
</rich_text><rich_text foreground="#008080">151</rich_text><rich_text>     device_lock(dev);
</rich_text><rich_text foreground="#008080">152</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!dev-&gt;driver)                               </rich_text><rich_text foreground="#008000">//如果设备没有指定driver
</rich_text><rich_text foreground="#008080">153</rich_text><rich_text>         driver_probe_device(drv, dev);              </rich_text><rich_text foreground="#008000">//那么需要初始化匹配到的这个设备
</rich_text><rich_text foreground="#008080">154</rich_text><rich_text>     device_unlock(dev);
</rich_text><rich_text foreground="#008080">155</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;parent)
</rich_text><rich_text foreground="#008080">156</rich_text><rich_text>         device_unlock(dev-&gt;parent);
</rich_text><rich_text foreground="#008080">157</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">158</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">159</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/*********************************************
</rich_text><rich_text foreground="#008080">160</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 又遇到两个分支，囧，先看一下driver_match_device 
</rich_text><rich_text foreground="#008080">161</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*********************************************/</rich_text><rich_text> 
</rich_text><rich_text foreground="#008080">162</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> inline </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> driver_match_device(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv,      </rich_text><rich_text foreground="#008000">//bus的match存在就用bus的
</rich_text><rich_text foreground="#008080">163</rich_text><rich_text>                                       </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)             </rich_text><rich_text foreground="#008000">//，否则就直接匹配成功...
</rich_text><rich_text foreground="#008080">164</rich_text><rich_text> {                                                                     </rich_text><rich_text foreground="#008000">//match通常实现为首先扫描
</rich_text><rich_text foreground="#008080">165</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : </rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;           </rich_text><rich_text foreground="#008000">//driver支持的id设备表，如果
</rich_text><rich_text foreground="#008080">166</rich_text><rich_text> }                                                                     </rich_text><rich_text foreground="#008000">//为NULL就用名字进行匹配
</rich_text><rich_text foreground="#008080">167</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/************************************
</rich_text><rich_text foreground="#008080">168</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 再来看一下driver_probe_device这个函数 
</rich_text><rich_text foreground="#008080">169</rich_text><rich_text> </rich_text><rich_text foreground="#008000">************************************/</rich_text><rich_text> 
</rich_text><rich_text foreground="#008080">170</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> driver_probe_device(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">171</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">172</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> ret = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">173</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!device_is_registered(dev))                              </rich_text><rich_text foreground="#008000">//判断该设备是否已经注册
</rich_text><rich_text foreground="#008080">174</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -ENODEV;
</rich_text><rich_text foreground="#008080">175</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;bus: '%s': %s: matched device %s with driver %s/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">176</rich_text><rich_text>          drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);
</rich_text><rich_text foreground="#008080">177</rich_text><rich_text>     pm_runtime_get_noresume(dev);
</rich_text><rich_text foreground="#008080">178</rich_text><rich_text>     pm_runtime_barrier(dev);
</rich_text><rich_text foreground="#008080">179</rich_text><rich_text>     ret = really_probe(dev, drv);                               </rich_text><rich_text foreground="#008000">//调用really_probe
</rich_text><rich_text foreground="#008080">180</rich_text><rich_text>     pm_runtime_put_sync(dev);
</rich_text><rich_text foreground="#008080">181</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080">182</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">183</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/************************************
</rich_text><rich_text foreground="#008080">184</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 看一下device_is_registered
</rich_text><rich_text foreground="#008080">185</rich_text><rich_text> </rich_text><rich_text foreground="#008000">************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">186</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> inline </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> device_is_registered(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">187</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">188</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> dev-&gt;kobj.state_in_sysfs;                           </rich_text><rich_text foreground="#008000">//在sysfs中表示已经注册
</rich_text><rich_text foreground="#008080">189</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">190</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/************************************
</rich_text><rich_text foreground="#008080">191</rich_text><rich_text> </rich_text><rich_text foreground="#008000">× 再看really_probe
</rich_text><rich_text foreground="#008080">192</rich_text><rich_text> </rich_text><rich_text foreground="#008000">************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">193</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> really_probe(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv)
</rich_text><rich_text foreground="#008080">194</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">195</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> ret = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">196</rich_text><rich_text>     atomic_inc(&amp;probe_count);
</rich_text><rich_text foreground="#008080">197</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;bus: '%s': %s: probing driver %s with device %s/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">198</rich_text><rich_text>          drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));
</rich_text><rich_text foreground="#008080">199</rich_text><rich_text>     WARN_ON(!list_empty(&amp;dev-&gt;devres_head));
</rich_text><rich_text foreground="#008080">200</rich_text><rich_text>     dev-&gt;driver = drv;                                     </rich_text><rich_text foreground="#008000">//device的driver初始化成该driver
</rich_text><rich_text foreground="#008080">201</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (driver_sysfs_add(dev)) {                      
</rich_text><rich_text foreground="#008080">202</rich_text><rich_text>                  printk(KERN_ERR </rich_text><rich_text foreground="#800000">&quot;%s: driver_sysfs_add(%s) failed/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">203</rich_text><rich_text>             __func__, dev_name(dev));
</rich_text><rich_text foreground="#008080">204</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> probe_failed;
</rich_text><rich_text foreground="#008080">205</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">206</rich_text><rich_text>                                                          </rich_text><rich_text foreground="#008000">//利用probe初始化设备
</rich_text><rich_text foreground="#008080">207</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;bus-&gt;probe) {                               </rich_text><rich_text foreground="#008000">//如果bus的probe存在就用bus的，
</rich_text><rich_text foreground="#008080">208</rich_text><rich_text>         ret = dev-&gt;bus-&gt;probe(dev);                      </rich_text><rich_text foreground="#008000">//如果bus的不存在driver的存在
</rich_text><rich_text foreground="#008080">209</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (ret)                                         </rich_text><rich_text foreground="#008000">//再用driver的
</rich_text><rich_text foreground="#008080">210</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> probe_failed;
</rich_text><rich_text foreground="#008080">211</rich_text><rich_text>     } </rich_text><rich_text foreground="#0000ff">else</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (drv-&gt;probe) {
</rich_text><rich_text foreground="#008080">212</rich_text><rich_text>         ret = drv-&gt;probe(dev);
</rich_text><rich_text foreground="#008080">213</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (ret)
</rich_text><rich_text foreground="#008080">214</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> probe_failed;
</rich_text><rich_text foreground="#008080">215</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">216</rich_text><rich_text>     driver_bound(dev);                              </rich_text><rich_text foreground="#008000">//调用driver_bound进行绑定
</rich_text><rich_text foreground="#008080">217</rich_text><rich_text>     ret = </rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">218</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;bus: '%s': %s: bound device %s to driver %s/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">219</rich_text><rich_text>          drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);
</rich_text><rich_text foreground="#008080">220</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> done;
</rich_text><rich_text foreground="#008080">221</rich_text><rich_text> probe_failed:
</rich_text><rich_text foreground="#008080">222</rich_text><rich_text>     devres_release_all(dev);
</rich_text><rich_text foreground="#008080">223</rich_text><rich_text>     driver_sysfs_remove(dev);
</rich_text><rich_text foreground="#008080">224</rich_text><rich_text>     dev-&gt;driver = NULL;
</rich_text><rich_text foreground="#008080">225</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (ret != -ENODEV &amp;&amp; ret != -ENXIO) {
</rich_text><rich_text foreground="#008080">226</rich_text><rich_text>         </rich_text><rich_text foreground="#008000">/* driver matched but the probe failed */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">227</rich_text><rich_text>         printk(KERN_WARNING
</rich_text><rich_text foreground="#008080">228</rich_text><rich_text>                </rich_text><rich_text foreground="#800000">&quot;%s: probe of %s failed with error %d/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">229</rich_text><rich_text>                drv-&gt;name, dev_name(dev), ret);
</rich_text><rich_text foreground="#008080">230</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">231</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/*
</rich_text><rich_text foreground="#008080">232</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * Ignore errors returned by -&gt;probe so that the next driver can try
</rich_text><rich_text foreground="#008080">233</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * its luck.
</rich_text><rich_text foreground="#008080">234</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">235</rich_text><rich_text>     ret = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">236</rich_text><rich_text> done:
</rich_text><rich_text foreground="#008080">237</rich_text><rich_text>     atomic_dec(&amp;probe_count);
</rich_text><rich_text foreground="#008080">238</rich_text><rich_text>     wake_up(&amp;probe_waitqueue);
</rich_text><rich_text foreground="#008080">239</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080">240</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">241</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/**********************************
</rich_text><rich_text foreground="#008080">242</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 最后跟一下driver_bound(dev)这个函数
</rich_text><rich_text foreground="#008080">243</rich_text><rich_text> </rich_text><rich_text foreground="#008000">**********************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">244</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> driver_bound(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">245</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">246</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver)) {                   </rich_text><rich_text foreground="#008000">//判断是否已经绑定
</rich_text><rich_text foreground="#008080">247</rich_text><rich_text>         printk(KERN_WARNING </rich_text><rich_text foreground="#800000">&quot;%s: device %s already bound/n&quot;</rich_text><rich_text>,
</rich_text><rich_text foreground="#008080">248</rich_text><rich_text>             __func__, kobject_name(&amp;dev-&gt;kobj));
</rich_text><rich_text foreground="#008080">249</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">250</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">251</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;driver: '%s': %s: bound to device '%s'/n&quot;</rich_text><rich_text>, dev_name(dev),
</rich_text><rich_text foreground="#008080">252</rich_text><rich_text>          __func__, dev-&gt;driver-&gt;name);
</rich_text><rich_text foreground="#008080">253</rich_text><rich_text>     klist_add_tail(&amp;dev-&gt;p-&gt;knode_driver, &amp;dev-&gt;driver-&gt;p-&gt;klist_devices);  </rich_text><rich_text foreground="#008000">//将设备添加
</rich_text><rich_text foreground="#008080">254</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//到driver的链表
</rich_text><rich_text foreground="#008080">255</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;bus)
</rich_text><rich_text foreground="#008080">256</rich_text><rich_text>         blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
</rich_text><rich_text foreground="#008080">257</rich_text><rich_text>                          BUS_NOTIFY_BOUND_DRIVER, dev);
</rich_text><rich_text foreground="#008080">258</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">259</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//all end</rich_text><rich_text>
   总结一下，driver的注册，主要涉及将自身挂接到bus的driver链表，并将匹配到的设备加入自己的device链表，并且将匹配到的 device的driver成员初始化为该driver，私有属性的driver节点也挂到driver的设备链表下，其中匹配函数是利用利用bus的 match函数，该函数通常判断如果driver有id表，就查表匹配，如果没有就用driver和device名字匹配。当匹配成功后如果自动初始化标 志允许则调用初始化函数probe，bus的probe优先级始终高于driver的。另外注意一点driver是没有总的起始端点的，driver不是 可具体描述的事物。
</rich_text></node><node name="bus，device，driver分析(二)" prog_lang="custom-colors" readonly="False" tags="" unique_id="11"><rich_text>上篇分析了bus，driver的注册过程，这篇主要分析device的注册，并总结给出个流程图。
三、device的注册
   还是照例先看一下device的结构：
 </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device {
</rich_text><rich_text foreground="#008080"> 2</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device        *parent;
</rich_text><rich_text foreground="#008080"> 3</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_private    *p;                                              </rich_text><rich_text foreground="#008000">//私有属性结构，重点
</rich_text><rich_text foreground="#008080"> 4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> kobject kobj;
</rich_text><rich_text foreground="#008080"> 5</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">char</rich_text><rich_text>        *init_name; </rich_text><rich_text foreground="#008000">/* initial name of the device */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 6</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_type    *type;
</rich_text><rich_text foreground="#008080"> 7</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> mutex        mutex;    </rich_text><rich_text foreground="#008000">/* mutex to synchronize calls to
</rich_text><rich_text foreground="#008080"> 8</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                     * its driver.
</rich_text><rich_text foreground="#008080"> 9</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">10</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type    *bus;        </rich_text><rich_text foreground="#008000">/* type of bus device is on */</rich_text><rich_text>            </rich_text><rich_text foreground="#008000">//所在bus
</rich_text><rich_text foreground="#008080">11</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *driver;    </rich_text><rich_text foreground="#008000">/* which driver has allocated this    //匹配的driver
</rich_text><rich_text foreground="#008080">12</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                       device */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">13</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text>        *platform_data;    </rich_text><rich_text foreground="#008000">/* Platform specific data, device
</rich_text><rich_text foreground="#008080">14</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                       core doesn't touch it */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">15</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> dev_pm_info    power;
</rich_text><rich_text foreground="#008080">16</rich_text><rich_text> #ifdef CONFIG_NUMA
</rich_text><rich_text foreground="#008080">17</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text>        numa_node;    </rich_text><rich_text foreground="#008000">/* NUMA node this device is close to */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">18</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">#endif</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">19</rich_text><rich_text>     u64        *dma_mask;    </rich_text><rich_text foreground="#008000">/* dma mask (if dma'able device) */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">20</rich_text><rich_text>     u64        coherent_dma_mask;</rich_text><rich_text foreground="#008000">/* Like dma_mask, but for
</rich_text><rich_text foreground="#008080">21</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                         alloc_coherent mappings as
</rich_text><rich_text foreground="#008080">22</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                         not all hardware supports
</rich_text><rich_text foreground="#008080">23</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                         64 bit addresses for consistent
</rich_text><rich_text foreground="#008080">24</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                         allocations such descriptors. */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">25</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_dma_parameters *dma_parms;
</rich_text><rich_text foreground="#008080">26</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> list_head    dma_pools;    </rich_text><rich_text foreground="#008000">/* dma pools (if dma'ble) */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">27</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> dma_coherent_mem    *dma_mem; </rich_text><rich_text foreground="#008000">/* internal for coherent mem
</rich_text><rich_text foreground="#008080">28</rich_text><rich_text> </rich_text><rich_text foreground="#008000">                         override */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">29</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* arch specific additions */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">30</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> dev_archdata    archdata;
</rich_text><rich_text foreground="#008080">31</rich_text><rich_text> #ifdef CONFIG_OF
</rich_text><rich_text foreground="#008080">32</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_node    *of_node;
</rich_text><rich_text foreground="#008080">33</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">#endif</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">34</rich_text><rich_text>     dev_t            devt;    </rich_text><rich_text foreground="#008000">/* dev_t, creates the sysfs &quot;dev&quot; */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">35</rich_text><rich_text>     spinlock_t        devres_lock;
</rich_text><rich_text foreground="#008080">36</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> list_head    devres_head;
</rich_text><rich_text foreground="#008080">37</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_node    knode_class;
</rich_text><rich_text foreground="#008080">38</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>        *</rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">39</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">const</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> attribute_group **groups;    </rich_text><rich_text foreground="#008000">/* optional groups */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">40</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text>    (*release)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev);
</rich_text><rich_text foreground="#008080">41</rich_text><rich_text> };
</rich_text><rich_text foreground="#008080">42</rich_text><rich_text> </rich_text><rich_text foreground="#008000">//重点看一下私有属性结构
</rich_text><rich_text foreground="#008080">43</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_private {
</rich_text><rich_text foreground="#008080">44</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist klist_children;             </rich_text><rich_text foreground="#008000">//子集结构
</rich_text><rich_text foreground="#008080">45</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_node knode_parent;          </rich_text><rich_text foreground="#008000">//父级挂接点
</rich_text><rich_text foreground="#008080">46</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_node knode_driver;          </rich_text><rich_text foreground="#008000">//driver挂接点
</rich_text><rich_text foreground="#008080">47</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_node knode_bus;             </rich_text><rich_text foreground="#008000">//bus挂接点
</rich_text><rich_text foreground="#008080">48</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *driver_data;
</rich_text><rich_text foreground="#008080">49</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *device;                   </rich_text><rich_text foreground="#008000">//回指
</rich_text><rich_text foreground="#008080">50</rich_text><rich_text> };

接下来详细看一下device的注册device_register:
  </rich_text><rich_text foreground="#008080">1</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> device_register(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">  2</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">  3</rich_text><rich_text>     device_initialize(dev);                </rich_text><rich_text foreground="#008000">//初始化dev
</rich_text><rich_text foreground="#008080">  4</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> device_add(dev);                </rich_text><rich_text foreground="#008000">//添加dev
</rich_text><rich_text foreground="#008080">  5</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">  6</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/******************************
</rich_text><rich_text foreground="#008080">  7</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 先看一下device_initialize(dev)
</rich_text><rich_text foreground="#008080">  8</rich_text><rich_text> </rich_text><rich_text foreground="#008000">******************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">  9</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> device_initialize(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080"> 10</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 11</rich_text><rich_text>     dev-&gt;kobj.kset = devices_kset;                  </rich_text><rich_text foreground="#008000">//可见device和bus都有其起始的kset，而driver没有
</rich_text><rich_text foreground="#008080"> 12</rich_text><rich_text>     kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);        </rich_text><rich_text foreground="#008000">//初始化这个kobj并建立层次关系以及属性文件，此时
</rich_text><rich_text foreground="#008080"> 13</rich_text><rich_text>     INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);                </rich_text><rich_text foreground="#008000">//是放到了总的device文件目录下面
</rich_text><rich_text foreground="#008080"> 14</rich_text><rich_text>     mutex_init(&amp;dev-&gt;mutex);
</rich_text><rich_text foreground="#008080"> 15</rich_text><rich_text>     lockdep_set_novalidate_class(&amp;dev-&gt;mutex);
</rich_text><rich_text foreground="#008080"> 16</rich_text><rich_text>     spin_lock_init(&amp;dev-&gt;devres_lock);
</rich_text><rich_text foreground="#008080"> 17</rich_text><rich_text>     INIT_LIST_HEAD(&amp;dev-&gt;devres_head);
</rich_text><rich_text foreground="#008080"> 18</rich_text><rich_text>     device_pm_init(dev);
</rich_text><rich_text foreground="#008080"> 19</rich_text><rich_text>     set_dev_node(dev, -</rich_text><rich_text foreground="#800080">1</rich_text><rich_text>);
</rich_text><rich_text foreground="#008080"> 20</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080"> 21</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/******************************
</rich_text><rich_text foreground="#008080"> 22</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 再来看一下device_add(dev)
</rich_text><rich_text foreground="#008080"> 23</rich_text><rich_text> </rich_text><rich_text foreground="#008000">******************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 24</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> device_add(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080"> 25</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080"> 26</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *parent = NULL;
</rich_text><rich_text foreground="#008080"> 27</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> class_interface *class_intf;
</rich_text><rich_text foreground="#008080"> 28</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error = -EINVAL;
</rich_text><rich_text foreground="#008080"> 29</rich_text><rich_text>     dev = get_device(dev);
</rich_text><rich_text foreground="#008080"> 30</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!dev)
</rich_text><rich_text foreground="#008080"> 31</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> done;
</rich_text><rich_text foreground="#008080"> 32</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!dev-&gt;p) {
</rich_text><rich_text foreground="#008080"> 33</rich_text><rich_text>         error = device_private_init(dev);                        </rich_text><rich_text foreground="#008000">//初始化dev的私有成员，及其链表操作函数
</rich_text><rich_text foreground="#008080"> 34</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 35</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> done;
</rich_text><rich_text foreground="#008080"> 36</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 37</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/*
</rich_text><rich_text foreground="#008080"> 38</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * for statically allocated devices, which should all be converted
</rich_text><rich_text foreground="#008080"> 39</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * some day, we need to initialize the name. We prevent reading back
</rich_text><rich_text foreground="#008080"> 40</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * the name, and force the use of dev_name()
</rich_text><rich_text foreground="#008080"> 41</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 42</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;init_name) {
</rich_text><rich_text foreground="#008080"> 43</rich_text><rich_text>         dev_set_name(dev, </rich_text><rich_text foreground="#800000">&quot;%s&quot;</rich_text><rich_text>, dev-&gt;init_name);                 </rich_text><rich_text foreground="#008000">//设置名字，给kobj
</rich_text><rich_text foreground="#008080"> 44</rich_text><rich_text>         dev-&gt;init_name = NULL;
</rich_text><rich_text foreground="#008080"> 45</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 46</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!dev_name(dev)) {                                         </rich_text><rich_text foreground="#008000">//名字为空出错退出
</rich_text><rich_text foreground="#008080"> 47</rich_text><rich_text>         error = -EINVAL;
</rich_text><rich_text foreground="#008080"> 48</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> name_error;
</rich_text><rich_text foreground="#008080"> 49</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 50</rich_text><rich_text>     pr_debug(</rich_text><rich_text foreground="#800000">&quot;device: '%s': %s/n&quot;</rich_text><rich_text>, dev_name(dev), __func__);
</rich_text><rich_text foreground="#008080"> 51</rich_text><rich_text>     parent = get_device(dev-&gt;parent);                          </rich_text><rich_text foreground="#008000">//返回父节点，如果有返回，没有返回NULL
</rich_text><rich_text foreground="#008080"> 52</rich_text><rich_text>     setup_parent(dev, parent);                   
</rich_text><rich_text foreground="#008080"> 53</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* use parent numa_node */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 54</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (parent)
</rich_text><rich_text foreground="#008080"> 55</rich_text><rich_text>         set_dev_node(dev, dev_to_node(parent));
</rich_text><rich_text foreground="#008080"> 56</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* first, register with generic layer. */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 57</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* we require the name to be set before, and pass NULL */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 58</rich_text><rich_text>     error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);   </rich_text><rich_text foreground="#008000">//初始化kobj与其父节点的连接
</rich_text><rich_text foreground="#008080"> 59</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 60</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> Error;
</rich_text><rich_text foreground="#008080"> 61</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* notify platform of device entry */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 62</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (platform_notify)
</rich_text><rich_text foreground="#008080"> 63</rich_text><rich_text>         platform_notify(dev);
</rich_text><rich_text foreground="#008080"> 64</rich_text><rich_text>     error = device_create_file(dev, &amp;uevent_attr);             </rich_text><rich_text foreground="#008000">//产生属性文件
</rich_text><rich_text foreground="#008080"> 65</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 66</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> attrError;
</rich_text><rich_text foreground="#008080"> 67</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (MAJOR(dev-&gt;devt)) {
</rich_text><rich_text foreground="#008080"> 68</rich_text><rich_text>         error = device_create_file(dev, &amp;devt_attr);             </rich_text><rich_text foreground="#008000">//在sys下产生dev属性文件
</rich_text><rich_text foreground="#008080"> 69</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 70</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> ueventattrError;
</rich_text><rich_text foreground="#008080"> 71</rich_text><rich_text>         error = device_create_sys_dev_entry(dev);
</rich_text><rich_text foreground="#008080"> 72</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 73</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> devtattrError;
</rich_text><rich_text foreground="#008080"> 74</rich_text><rich_text>         devtmpfs_create_node(dev);                               
</rich_text><rich_text foreground="#008080"> 75</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080"> 76</rich_text><rich_text>     error = device_add_class_symlinks(dev);                    
</rich_text><rich_text foreground="#008080"> 77</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 78</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> SymlinkError;
</rich_text><rich_text foreground="#008080"> 79</rich_text><rich_text>     error = device_add_attrs(dev);                             </rich_text><rich_text foreground="#008000">//增加属性文件
</rich_text><rich_text foreground="#008080"> 80</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 81</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> AttrsError;
</rich_text><rich_text foreground="#008080"> 82</rich_text><rich_text>     error = bus_add_device(dev);                               </rich_text><rich_text foreground="#008000">//把device的bus节点挂到bus的设备节点上
</rich_text><rich_text foreground="#008080"> 83</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 84</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> BusError;
</rich_text><rich_text foreground="#008080"> 85</rich_text><rich_text>     error = dpm_sysfs_add(dev);
</rich_text><rich_text foreground="#008080"> 86</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (error)
</rich_text><rich_text foreground="#008080"> 87</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> DPMError;
</rich_text><rich_text foreground="#008080"> 88</rich_text><rich_text>     device_pm_add(dev);
</rich_text><rich_text foreground="#008080"> 89</rich_text><rich_text>     </rich_text><rich_text foreground="#008000">/* Notify clients of device addition.  This call must come
</rich_text><rich_text foreground="#008080"> 90</rich_text><rich_text> </rich_text><rich_text foreground="#008000">     * after dpm_sysf_add() and before kobject_uevent().
</rich_text><rich_text foreground="#008080"> 91</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080"> 92</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;bus)
</rich_text><rich_text foreground="#008080"> 93</rich_text><rich_text>         blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
</rich_text><rich_text foreground="#008080"> 94</rich_text><rich_text>                          BUS_NOTIFY_ADD_DEVICE, dev);
</rich_text><rich_text foreground="#008080"> 95</rich_text><rich_text>     kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);
</rich_text><rich_text foreground="#008080"> 96</rich_text><rich_text>     bus_probe_device(dev);                                    </rich_text><rich_text foreground="#008000">//匹配driver
</rich_text><rich_text foreground="#008080"> 97</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (parent)
</rich_text><rich_text foreground="#008080"> 98</rich_text><rich_text>         klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,                 </rich_text><rich_text foreground="#008000">//把该设备的节点挂到其父节点的链表
</rich_text><rich_text foreground="#008080"> 99</rich_text><rich_text>                    &amp;parent-&gt;p-&gt;klist_children);
</rich_text><rich_text foreground="#008080">100</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;</rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>) {
</rich_text><rich_text foreground="#008080">101</rich_text><rich_text>         mutex_lock(&amp;dev-&gt;</rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>-&gt;p-&gt;class_mutex);
</rich_text><rich_text foreground="#008080">102</rich_text><rich_text>         </rich_text><rich_text foreground="#008000">/* tie the class to the device */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">103</rich_text><rich_text>         klist_add_tail(&amp;dev-&gt;knode_class,
</rich_text><rich_text foreground="#008080">104</rich_text><rich_text>                    &amp;dev-&gt;</rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>-&gt;p-&gt;class_devices);
</rich_text><rich_text foreground="#008080">105</rich_text><rich_text>         </rich_text><rich_text foreground="#008000">/* notify any interfaces that the device is here */</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">106</rich_text><rich_text>         list_for_each_entry(class_intf,
</rich_text><rich_text foreground="#008080">107</rich_text><rich_text>                     &amp;dev-&gt;</rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>-&gt;p-&gt;class_interfaces, node)
</rich_text><rich_text foreground="#008080">108</rich_text><rich_text>             </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (class_intf-&gt;add_dev)
</rich_text><rich_text foreground="#008080">109</rich_text><rich_text>                 class_intf-&gt;add_dev(dev, class_intf);
</rich_text><rich_text foreground="#008080">110</rich_text><rich_text>         mutex_unlock(&amp;dev-&gt;</rich_text><rich_text foreground="#0000ff">class</rich_text><rich_text>-&gt;p-&gt;class_mutex);
</rich_text><rich_text foreground="#008080">111</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">112</rich_text><rich_text> done:
</rich_text><rich_text foreground="#008080">113</rich_text><rich_text>     put_device(dev);
</rich_text><rich_text foreground="#008080">114</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080">115</rich_text><rich_text>  DPMError:
</rich_text><rich_text foreground="#008080">116</rich_text><rich_text>     bus_remove_device(dev);
</rich_text><rich_text foreground="#008080">117</rich_text><rich_text>  BusError:
</rich_text><rich_text foreground="#008080">118</rich_text><rich_text>     device_remove_attrs(dev);
</rich_text><rich_text foreground="#008080">119</rich_text><rich_text>  AttrsError:
</rich_text><rich_text foreground="#008080">120</rich_text><rich_text>     device_remove_class_symlinks(dev);
</rich_text><rich_text foreground="#008080">121</rich_text><rich_text>  SymlinkError:
</rich_text><rich_text foreground="#008080">122</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (MAJOR(dev-&gt;devt))
</rich_text><rich_text foreground="#008080">123</rich_text><rich_text>         devtmpfs_delete_node(dev);
</rich_text><rich_text foreground="#008080">124</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (MAJOR(dev-&gt;devt))
</rich_text><rich_text foreground="#008080">125</rich_text><rich_text>         device_remove_sys_dev_entry(dev);
</rich_text><rich_text foreground="#008080">126</rich_text><rich_text>  devtattrError:
</rich_text><rich_text foreground="#008080">127</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (MAJOR(dev-&gt;devt))
</rich_text><rich_text foreground="#008080">128</rich_text><rich_text>         device_remove_file(dev, &amp;devt_attr);
</rich_text><rich_text foreground="#008080">129</rich_text><rich_text>  ueventattrError:
</rich_text><rich_text foreground="#008080">130</rich_text><rich_text>     device_remove_file(dev, &amp;uevent_attr);
</rich_text><rich_text foreground="#008080">131</rich_text><rich_text>  attrError:
</rich_text><rich_text foreground="#008080">132</rich_text><rich_text>     kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);
</rich_text><rich_text foreground="#008080">133</rich_text><rich_text>     kobject_del(&amp;dev-&gt;kobj);
</rich_text><rich_text foreground="#008080">134</rich_text><rich_text>  Error:
</rich_text><rich_text foreground="#008080">135</rich_text><rich_text>     cleanup_device_parent(dev);
</rich_text><rich_text foreground="#008080">136</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (parent)
</rich_text><rich_text foreground="#008080">137</rich_text><rich_text>         put_device(parent);
</rich_text><rich_text foreground="#008080">138</rich_text><rich_text> name_error:
</rich_text><rich_text foreground="#008080">139</rich_text><rich_text>     kfree(dev-&gt;p);
</rich_text><rich_text foreground="#008080">140</rich_text><rich_text>     dev-&gt;p = NULL;
</rich_text><rich_text foreground="#008080">141</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">goto</rich_text><rich_text> done;
</rich_text><rich_text foreground="#008080">142</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">143</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/***********************************************
</rich_text><rich_text foreground="#008080">144</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 重点看一下bus_probe_device匹配driver以及初始化过程
</rich_text><rich_text foreground="#008080">145</rich_text><rich_text> </rich_text><rich_text foreground="#008000">***********************************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">146</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> bus_probe_device(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">147</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">148</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus = dev-&gt;bus;
</rich_text><rich_text foreground="#008080">149</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080">150</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (bus &amp;&amp; bus-&gt;p-&gt;drivers_autoprobe) {         </rich_text><rich_text foreground="#008000">//设置了自动匹配初始化那么就开始匹配
</rich_text><rich_text foreground="#008080">151</rich_text><rich_text>         ret = device_attach(dev);
</rich_text><rich_text foreground="#008080">152</rich_text><rich_text>         WARN_ON(ret &lt; </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>);
</rich_text><rich_text foreground="#008080">153</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">154</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">155</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/******************
</rich_text><rich_text foreground="#008080">156</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 继续device_attach
</rich_text><rich_text foreground="#008080">157</rich_text><rich_text> </rich_text><rich_text foreground="#008000">******************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">158</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> device_attach(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">159</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">160</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> ret = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">161</rich_text><rich_text>     device_lock(dev);
</rich_text><rich_text foreground="#008080">162</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (dev-&gt;driver) {                            </rich_text><rich_text foreground="#008000">//默认指定了driver就直接绑定
</rich_text><rich_text foreground="#008080">163</rich_text><rich_text>         ret = device_bind_driver(dev);
</rich_text><rich_text foreground="#008080">164</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (ret == </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>)
</rich_text><rich_text foreground="#008080">165</rich_text><rich_text>             ret = </rich_text><rich_text foreground="#800080">1</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">166</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">else</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">167</rich_text><rich_text>             dev-&gt;driver = NULL;
</rich_text><rich_text foreground="#008080">168</rich_text><rich_text>             ret = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">169</rich_text><rich_text>         }
</rich_text><rich_text foreground="#008080">170</rich_text><rich_text>     } </rich_text><rich_text foreground="#0000ff">else</rich_text><rich_text> {                                      </rich_text><rich_text foreground="#008000">//没有指定就进行遍历匹配
</rich_text><rich_text foreground="#008080">171</rich_text><rich_text>         pm_runtime_get_noresume(dev);
</rich_text><rich_text foreground="#008080">172</rich_text><rich_text>         ret = bus_for_each_drv(dev-&gt;bus, NULL, dev, __device_attach);
</rich_text><rich_text foreground="#008080">173</rich_text><rich_text>         pm_runtime_put_sync(dev);
</rich_text><rich_text foreground="#008080">174</rich_text><rich_text>     }
</rich_text><rich_text foreground="#008080">175</rich_text><rich_text>     device_unlock(dev);
</rich_text><rich_text foreground="#008080">176</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080">177</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">178</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/**************************
</rich_text><rich_text foreground="#008080">179</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 再来看device_bind_driver分支
</rich_text><rich_text foreground="#008080">180</rich_text><rich_text> </rich_text><rich_text foreground="#008000">**************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">181</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> device_bind_driver(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev)
</rich_text><rich_text foreground="#008080">182</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">183</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> ret;
</rich_text><rich_text foreground="#008080">184</rich_text><rich_text>     ret = driver_sysfs_add(dev);
</rich_text><rich_text foreground="#008080">185</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!ret)
</rich_text><rich_text foreground="#008080">186</rich_text><rich_text>         driver_bound(dev);              </rich_text><rich_text foreground="#008000">//主要是完成了将私有成员的driver节点挂到
</rich_text><rich_text foreground="#008080">187</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> ret;                         </rich_text><rich_text foreground="#008000">//了driver的设备链表
</rich_text><rich_text foreground="#008080">188</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">189</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/**************************
</rich_text><rich_text foreground="#008080">190</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 先看bus_for_each_drv分支
</rich_text><rich_text foreground="#008080">191</rich_text><rich_text> </rich_text><rich_text foreground="#008000">**************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">192</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> bus_for_each_drv(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> bus_type *bus, </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *start,
</rich_text><rich_text foreground="#008080">193</rich_text><rich_text>              </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *data, </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> (*fn)(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *, </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *))
</rich_text><rich_text foreground="#008080">194</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">195</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> klist_iter i;
</rich_text><rich_text foreground="#008080">196</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv;
</rich_text><rich_text foreground="#008080">197</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> error = </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">198</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!bus)
</rich_text><rich_text foreground="#008080">199</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> -EINVAL;
</rich_text><rich_text foreground="#008080">200</rich_text><rich_text>     klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,           </rich_text><rich_text foreground="#008000">//和driver遍历device类似，从头开始遍历bus的driver链表
</rich_text><rich_text foreground="#008080">201</rich_text><rich_text>                  start ? &amp;start-&gt;p-&gt;knode_bus : NULL);         </rich_text><rich_text foreground="#008000">//发现一个driver就调用fn即__device_attach进行匹配
</rich_text><rich_text foreground="#008080">202</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">while</rich_text><rich_text> ((drv = next_driver(&amp;i)) &amp;&amp; !error)
</rich_text><rich_text foreground="#008080">203</rich_text><rich_text>         error = fn(drv, data);
</rich_text><rich_text foreground="#008080">204</rich_text><rich_text>     klist_iter_exit(&amp;i);
</rich_text><rich_text foreground="#008080">205</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> error;
</rich_text><rich_text foreground="#008080">206</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">207</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/*********************************
</rich_text><rich_text foreground="#008080">208</rich_text><rich_text> </rich_text><rich_text foreground="#008000">* 最后来看一下__device_attach这个函数
</rich_text><rich_text foreground="#008080">209</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*********************************/</rich_text><rich_text>
</rich_text><rich_text foreground="#008080">210</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">static</rich_text><rich_text> </rich_text><rich_text foreground="#0000ff">int</rich_text><rich_text> __device_attach(</rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device_driver *drv, </rich_text><rich_text foreground="#0000ff">void</rich_text><rich_text> *data)
</rich_text><rich_text foreground="#008080">211</rich_text><rich_text> {
</rich_text><rich_text foreground="#008080">212</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">struct</rich_text><rich_text> device *dev = data;
</rich_text><rich_text foreground="#008080">213</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">if</rich_text><rich_text> (!driver_match_device(drv, dev))    
</rich_text><rich_text foreground="#008080">214</rich_text><rich_text>         </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> </rich_text><rich_text foreground="#800080">0</rich_text><rich_text>;
</rich_text><rich_text foreground="#008080">215</rich_text><rich_text>     </rich_text><rich_text foreground="#0000ff">return</rich_text><rich_text> driver_probe_device(drv, dev);
</rich_text><rich_text foreground="#008080">216</rich_text><rich_text> }
</rich_text><rich_text foreground="#008080">217</rich_text><rich_text> </rich_text><rich_text foreground="#008000">/*
</rich_text><rich_text foreground="#008080">218</rich_text><rich_text> </rich_text><rich_text foreground="#008000">  对比driver的注册最后调用的__driver_attach可以发现其实质是一样的，都最后归宿到了
</rich_text><rich_text foreground="#008080">219</rich_text><rich_text> </rich_text><rich_text foreground="#008000">  这driver_match_device，driver_probe_device两个函数,本质参数的和谐做到了通用
</rich_text><rich_text foreground="#008080">220</rich_text><rich_text> </rich_text><rich_text foreground="#008000">  性在这里就不继续分析了，不是很清楚的可以看前一篇文章driver最后一部分的分析  ^_^
</rich_text><rich_text foreground="#008080">221</rich_text><rich_text> </rich_text><rich_text foreground="#008000">*/</rich_text><rich_text>  </rich_text></node><node name="platform" prog_lang="custom-colors" readonly="False" tags="" unique_id="10"><rich_text>    platform可以说是内核抽象出来的一条虚拟总线平台，内核开发者原意是想把硬件层次上的结构关系用软件抽象模拟出来，但是对一些硬件，这样做 往往不太合适，例如对于片上soc，外围设备的控制器都集成在处理器上，如果过度的剥离抽象，使得原本物理上紧密的结构而在软件上变成的偏于独立，因此 有了platform，对于联系紧密的soc这往往再合适不过，另外对于从soc上直接引出的引脚，难于独立出来，都可以利用platform来表述。
      
    有了前面关于bus，driver，device的理解，platform平台的理解就比较简单，都是以前面为原型进行的再次封装，好了下面就让我们以具体代码为例进行分析。
一、platform的初始化
     platform的初始化代码位于driver/base目录下的platform.c
 
</rich_text><rich_text foreground="#993366">int __init platform_bus_init(void) </rich_text><rich_text>
{
    int error;

    early_platform_cleanup();                               </rich_text><rich_text foreground="#99cc00">// 清除platform设备链表 </rich_text><rich_text>

    error = device_register(&amp;platform_bus);           </rich_text><rich_text foreground="#99cc00">//将平台bus作为一个设备注册，出现在device目录 </rich_text><rich_text>
    if (error)
        return error;
    error =  bus_register(&amp;platform_bus_type);      </rich_text><rich_text foreground="#99cc00">//注册平台类型的bus，将出现在bus目录下
    </rich_text><rich_text foreground="#993366">if (error)</rich_text><rich_text> 
        device_unregister(&amp;platform_bus);
    return error;
} 
</rich_text><rich_text foreground="#003300">先</rich_text><rich_text> 来看一下 </rich_text><rich_text foreground="#000000">early_platform_cleanup() </rich_text><rich_text foreground="#003300">这个函数：</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">void __init early_platform_cleanup(void)
{
         struct platform_device *pd, *pd2;

        /* clean up the devres list used to chain devices */</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">   </rich_text><rich_text foreground="#339966">     </rich_text><rich_text foreground="#99cc00">/*</rich_text><rich_text> </rich_text><rich_text foreground="#99cc00">      遍历early_platform_device_list，把连接到此的所有节点清0， </rich_text><rich_text>
</rich_text><rich_text foreground="#99cc00">            平台设备都会挂到该节点，现在是平台设备的初始化阶段，自然不 </rich_text><rich_text>
</rich_text><rich_text foreground="#99cc00">            能有连接到此的设备                                                                */</rich_text><rich_text> </rich_text><rich_text foreground="#993366">
       </rich_text><rich_text> </rich_text><rich_text foreground="#993366">list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,  
                 dev.devres_head) {                                                        
        list_del(&amp;pd-&gt;dev.devres_head);                                       
        memset(&amp;pd-&gt;dev.devres_head, 0, sizeof(pd-&gt;dev.devres_head));
       }</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">}</rich_text><rich_text> 
</rich_text><rich_text foreground="#000000">再来看一下另外两个结构体：</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">struct device platform_bus = {
    .init_name    = &quot;platform&quot;,
};</rich_text><rich_text> 
</rich_text><rich_text foreground="#000000">以及</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">struct bus_type platform_bus_type = {
    .name        = &quot;platform&quot;,
    .dev_attrs    = platform_dev_attrs,
    .match        = platform_match,
    .uevent        = platform_uevent,
    .pm        = &amp;platform_dev_pm_ops,
};</rich_text><rich_text> 

 
</rich_text><rich_text foreground="#003300" scale="h2" weight="heavy">二、platform_device的注册</rich_text><rich_text scale="h2" weight="heavy"> </rich_text><rich_text>
</rich_text><rich_text foreground="#003300">     platform_device无疑是device的封装，先给出该结构具体代码：</rich_text><rich_text> 
 
</rich_text><rich_text foreground="#003300">    </rich_text><rich_text foreground="#993366">struct platform_device {
               const char    * name;                              </rich_text><rich_text foreground="#99cc00">//名称</rich_text><rich_text> 
               int        id;                                             </rich_text><rich_text foreground="#99cc00">//id号</rich_text><rich_text> 
               struct device    dev;                                </rich_text><rich_text foreground="#99cc00">//内嵌的标准模型device</rich_text><rich_text> 
               u32        num_resources;                       </rich_text><rich_text foreground="#99cc00">//持有资源数</rich_text><rich_text> 
               struct resource    * resource;             </rich_text><rich_text foreground="#99cc00">    //指向具体资源</rich_text><rich_text> 

               const struct platform_device_id    *id_entry;           

               /* arch specific additions */
               struct pdev_archdata    archdata;
   };  </rich_text><rich_text foreground="#993366">  </rich_text><rich_text> 
</rich_text><rich_text foreground="#003300">    其中的资源结构体代码为：</rich_text><rich_text> 
</rich_text><rich_text foreground="#003300">    </rich_text><rich_text foreground="#993366">struct resource {
           resource_size_t start;                                       </rich_text><rich_text foreground="#00ff00">  </rich_text><rich_text foreground="#99cc00">//资源起始地址，可以是寄存器起始地址等等</rich_text><rich_text> 
           resource_size_t end;                                         </rich_text><rich_text foreground="#00ff00"> </rich_text><rich_text foreground="#99cc00">//结束地址</rich_text><rich_text> 
           const char *name;                                             </rich_text><rich_text foreground="#99cc00"> //名称</rich_text><rich_text> 
           unsigned long flags;                                            </rich_text><rich_text foreground="#99cc00">//标志</rich_text><rich_text> 
           struct resource *parent, *sibling, *child;             </rich_text><rich_text foreground="#00ff00">   </rich_text><rich_text foreground="#99cc00">//层次级联结构指针</rich_text><rich_text> 
    }; </rich_text><rich_text foreground="#993366">      </rich_text><rich_text>
</rich_text><rich_text foreground="#003300">   具体的注册函数为：</rich_text><rich_text> 
 
</rich_text><rich_text foreground="#003300">   </rich_text><rich_text foreground="#993366">  </rich_text><rich_text foreground="#ff00ff">  </rich_text><rich_text foreground="#993366">int platform_device_register(struct platform_device *pdev)
      {
                    device_initialize(&amp;pdev-&gt;dev);                         </rich_text><rich_text foreground="#99cc00"> //和标准设备注册时候初始化是一样，就不多说了，</rich_text><rich_text> </rich_text><rich_text foreground="#993366">
                    return platform_device_add(pdev);                  </rich_text><rich_text foreground="#99cc00">  //</rich_text><rich_text> </rich_text><rich_text foreground="#99cc00">不明白的可以看</rich_text><rich_text> </rich_text><rich_text foreground="#99cc00">前面一篇文章</rich_text><rich_text> </rich_text><rich_text foreground="#99cc00">具,体看一下这个</rich_text><rich_text> 
      } 
===================================================
   </rich_text><rich_text foreground="#993366">  int platform_device_add(struct platform_device *pdev)
    {
                   int i, ret = 0;
                   if (!pdev)
                               return -EINVAL;
                   if (!pdev-&gt;dev.parent)
                               pdev-&gt;dev.parent = &amp;platform_bus;             </rich_text><rich_text foreground="#99cc00">     //挂接到platform_bus下面</rich_text><rich_text> 
                   pdev-&gt;dev.bus = &amp;platform_bus_type;                        </rich_text><rich_text foreground="#99cc00">  //指定bus类型为platform_bus_type</rich_text><rich_text> 
                   if (pdev-&gt;id != -1)
                               dev_set_name(&amp;pdev-&gt;dev, &quot;%s.%d&quot;, 
</rich_text><rich_text foreground="#993366">                                                   pdev-&gt;name,  pdev-&gt;id);            </rich_text><rich_text foreground="#99cc00">  //设置名字，将platform下的名字传到内部device，最终会</rich_text><rich_text> 
                   else                                                                          </rich_text><rich_text foreground="#99cc00">//传到kobj</rich_text><rich_text> 
                               dev_set_name(&amp;pdev-&gt;dev, &quot;%s&quot;, pdev-&gt;name);
                    for (i = 0; i &lt; pdev-&gt;num_resources; i++) {                </rich_text><rich_text foreground="#99cc00">   //设置资源层次结构</rich_text><rich_text> 
                                struct resource *p, *r = &amp;pdev-&gt;resource[i];
                                if (r-&gt;name == NULL)                                     </rich_text><rich_text foreground="#99cc00">//资源名称为NULL则把设备名称设置给它</rich_text><rich_text> 
                                                   r-&gt;name = dev_name(&amp;pdev-&gt;dev);
                                p = r-&gt;parent;                                               </rich_text><rich_text foreground="#99cc00"> //取得资源的父节点，资源在内核中也是层次安排的，</rich_text><rich_text> 
                                if (!p) {                                                           </rich_text><rich_text foreground="#99cc00">//具有父节点，兄弟节点，子节点</rich_text><rich_text> 
                                                   if (resource_type(r) == IORESOURCE_MEM)      </rich_text><rich_text foreground="#99cc00"> //如果父节点为NULL，并且资源类型为</rich_text><rich_text> 
                                                                p = &amp;iomem_resource;                          </rich_text><rich_text foreground="#99cc00">//IORESOURCE_MEM，则把父节点设置</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">                                                                                                                           </rich_text><rich_text foreground="#99cc00">//为iomem_resource，否则如果类型为</rich_text><rich_text> 
                                                   else if (resource_type(r) == IORESOURCE_IO)     </rich_text><rich_text foreground="#99cc00">//IORESOURCE_IO，则把父节点设置为</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">                                                                p = &amp;ioport_resource;                            </rich_text><rich_text foreground="#99cc00">//IORESOURCE_IO，由此我们可以看出</rich_text><rich_text> 
                                }                                                                                          </rich_text><rich_text foreground="#99cc00">//内核数据之间的条理性之强</rich_text><rich_text> 
                               if (p &amp;&amp; insert_resource(p, r)) {                     </rich_text><rich_text foreground="#99cc00">  //将资源插入父节点，也就是出现在父节点目录层次下</rich_text><rich_text> 
                                                  printk(KERN_ERR&quot;%s: failed to claim resource %d/n&quot;,
                                                            dev_name(&amp;pdev-&gt;dev), i); 
 
</rich_text><rich_text foreground="#993366">                                                 ret = -EBUSY;
                                                 goto failed;
                               }
                      }
                      pr_debug(&quot;Registering platform device '%s'. Parent at %s/n&quot;,
                      dev_name(&amp;pdev-&gt;dev), dev_name(pdev-&gt;dev.parent));
                      ret = device_add(&amp;pdev-&gt;dev);                                </rich_text><rich_text foreground="#99cc00">//标准设备注册</rich_text><rich_text> 
                      if (ret == 0)
                               return ret;
    failed:
               while (--i &gt;= 0) {
                       struct resource *r = &amp;pdev-&gt;resource[i];
                       unsigned long type = resource_type(r);
                       if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
                                release_resource(r);
               }
                return ret;
   } </rich_text><rich_text foreground="#993366"> </rich_text><rich_text> 

</rich_text><rich_text foreground="#003300" scale="h2" weight="heavy">三、platform_driver的注册</rich_text><rich_text scale="h2" weight="heavy"> </rich_text><rich_text>
</rich_text><rich_text foreground="#003300">      driver部分比较简单，其结构为：</rich_text><rich_text> 
</rich_text><rich_text foreground="#003300">            </rich_text><rich_text foreground="#993366">struct platform_driver {
                      int (*probe)(struct platform_device *);
                      int (*remove)(struct platform_device *);
                      void (*shutdown)(struct platform_device *);
                      int (*suspend)(struct platform_device *, pm_message_t state);
                      int (*resume)(struct platform_device *);
                      struct device_driver driver;                                             </rich_text><rich_text foreground="#99cc00">//内嵌的标准driver结构 </rich_text><rich_text>           
                      const struct platform_device_id *id_table;                      </rich_text><rich_text foreground="#99cc00"> //支持的设备id表</rich_text><rich_text> 
             }; 

</rich_text><rich_text foreground="#003300">  注册函数分析：</rich_text><rich_text> 
</rich_text><rich_text foreground="#993366">  int platform_driver_register(struct platform_driver *drv)
  {
                      drv-&gt;driver.bus = &amp;platform_bus_type;                          </rich_text><rich_text foreground="#99cc00">//设置bus</rich_text><rich_text> 
                      if (drv-&gt;probe)                                                             </rich_text><rich_text foreground="#99cc00">//如果platform_driver下的probe为真，就把内嵌</rich_text><rich_text> 
                                drv-&gt;driver.probe = platform_drv_probe;               </rich_text><rich_text foreground="#99cc00">//的标准driver的probe设置成platform_drv_probe</rich_text><rich_text> 
                      if (drv-&gt;remove)                                                           </rich_text><rich_text foreground="#99cc00">//可见外层的probe比内层的优先级别高</rich_text><rich_text> 
                                drv-&gt;driver.remove = platform_drv_remove;
                      if (drv-&gt;shutdown)
                                 drv-&gt;driver.shutdown = platform_drv_shutdown;

                      return driver_register(&amp;drv-&gt;driver);                               </rich_text><rich_text foreground="#99cc00">//注册标准driver</rich_text><rich_text> 
  } 
</rich_text><rich_text weight="heavy">
</rich_text><rich_text foreground="#000000" scale="h2" weight="heavy">四、总结 </rich_text></node></node><node name="各种总线match匹配函数" prog_lang="custom-colors" readonly="False" tags="" unique_id="14"><rich_text>
</rich_text><rich_text scale="h1">一. 驱动和设备匹配过程常用数据结构</rich_text><rich_text>

</rich_text><rich_text scale="h2">1. of_device_id</rich_text><rich_text>

struct of_device_id
{
    charname[32];
    char type[32];
    char compatible[128];
#ifdef __KERNEL__
    void*data;
#else
    kernel_ulong_t data;
#endif
};

</rich_text><rich_text scale="h2">2. platform_device_id</rich_text><rich_text>
struct platform_device_id {
    char name[PLATFORM_NAME_SIZE];
    kernel_ulong_t driver_data   __attribute__((aligned(sizeof(kernel_ulong_t))));
};
 

</rich_text><rich_text scale="h1">二. 平台设备、驱动匹配platform_match</rich_text><rich_text>
向系统添加平台驱动或添加设备时会调用平台总线platform_bus_type中的platform_match函数来匹配平台驱动和平台设备。
static int platform_match(struct device *dev, struct device_driver *drv)
{
    struct platform_device *pdev = to_platform_device(dev);
    struct platform_driver *pdrv = to_platform_driver(drv);
    /*通过驱动里定义了of_device_id项，则通过这一项来比对；*
    if (of_driver_match_device(dev, drv))
        return 1;
        
    /*如果在平台驱动中定义了id_table项，则通过对比id_table来判断*/
    if (pdrv-&gt;id_table)
        return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;
        
    /*通过对比平台设备名字和平台驱动名字来判断*/
    return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);
}
 
由platform_match可以看出，驱动和设备是否匹配可以通过三种方式来进行判断，首先是通过of_device_id结构：
static inline int of_driver_match_device(struct device *dev, const struct device_driver *drv)
{
    return of_match_device(drv-&gt;of_match_table, dev) != NULL;
}
 
struct of_device_id *of_match_device(const struct of_device_id *matches, const struct device *dev)
{
    if ((!matches) || (!dev-&gt;of_node))
        return NULL;
    
    return of_match_node(matches, dev-&gt;of_node);
}
 
const struct of_device_id *of_match_node(const struct of_device_id *matches, const struct device_node *node)
{
    if (!matches)
        return NULL;

    while (matches-&gt;name[0] || matches-&gt;type[0] || matches-&gt;compatible[0])  {
        int match = 1;
        if (matches-&gt;name[0])
            match &amp;= node-&gt;name &amp;&amp; !strcmp(matches-&gt;name, node-&gt;name);
            
        if (matches-&gt;type[0])
            match &amp;= node-&gt;type &amp;&amp; !strcmp(matches-&gt;type, node-&gt;type);
            
        if (matches-&gt;compatible[0])
            match &amp;= of_device_is_compatible(node, matches-&gt;compatible);
            
        if (match)
            return matches;matches++;
    }
    
    return NULL;
}
 
如果driver中定义了of_device_id，则通过</rich_text><rich_text foreground="#666600">driver中的of_device_id和device中的device_node</rich_text><rich_text>内 容进行匹配判断，匹配工作由of_match_node来完成，该函数会遍历of_device_id列表，查找是否有成员与device_node相匹 配，
具体由matches的name,type和compatioble来进行对比，如果找到则返回相应的表项，否则返回null.如果没有定义 of_device_id,device_node或不能找到对应的匹配项，则通过第二种方式platform_device_id来进行对比匹配,
通过 platform_match_id来完成：
static const struct platform_device_id *platform_match_id( const struct platform_device_id *id, struct platform_device *pdev)
{
    while (id-&gt;name[0]) {
        if (strcmp(pdev-&gt;name, id-&gt;name) == 0) {
            pdev-&gt;id_entry = id;
            return id;
        }
        id++;
    }
    
    return NULL;
}

platform_match_id函数遍历platfrom_device_id列表，通过比对平台设备与id的name来确定是否有匹配项，如果找到 匹配的，则返回对应的id项，否则返回null。如果没有定义platform_device_id或没有找到匹配项，
则通过第三种方式进行匹配，第三种 方式通过比对平台设备和平台驱动的名字，如果相等，则匹配成功，否则失败。

</rich_text><rich_text scale="h1">三. i2c设备、驱动匹配i2c_device_match</rich_text><rich_text>
当向i2c总线添加驱动或设备时会调用i2c_device_match来进行匹配判断，i2c_device_match函数定义如下所示：
static int i2c_device_match(struct device *dev, struct device_driver *drv)
{
    struct i2c_client *client = i2c_verify_client(dev);
    struct i2c_driver *driver;
    
    if (!client)
        return 0;

    /* 通过of_device_id匹配 */
    if (of_driver_match_device(dev, drv))
        return 1;
        
    driver = to_i2c_driver(drv);
    /*如果I2C 驱动中定义了id_table，则通过id_table进行匹配；*/
    if (driver-&gt;id_table)
        return i2c_match_id(driver-&gt;id_table, client) != NULL;
    
    return 0;
}
 
如i2c_device_match所示，i2c通过两种方式进行匹配设备和驱动，一种是of_device_id，另一种是 i2c_device_id，i2c_device_id数据结构和platform_device_id一样。I2C里的两种匹配方式和之前的platform判断方式都是一样，
这里就不展开。

</rich_text><rich_text scale="h1">四. usb设备、驱动匹配usb_device_match</rich_text><rich_text>
当向usb总线上注册驱动或添加设备时，就会调用usb_match_device进行驱动和设备配对，函数如下：
static int usb_device_match(struct device *dev, struct device_driver *drv)
{
    if (is_usb_device(dev)) {
        if (!is_usb_device_driver(drv))
            return 0;
        return 1;
    } else if (is_usb_interface(dev)) {
        struct usb_interface *intf;
        struct usb_driver *usb_drv;
        const struct usb_device_id *id;
        
        if (is_usb_device_driver(drv))
            return 0;
            
        intf = to_usb_interface(dev);
        usb_drv = to_usb_driver(drv);
        id = usb_match_id(intf, usb_drv-&gt;id_table);
        if (id)
            return 1;
            
        id = usb_match_dynamic_id(intf, usb_drv);
        if (id)
            return 1;
    }
    
    return 0;
}
从函数可以看出，match分成两部分，一部分用于匹配usb设备，另一部分用于匹配usb接口，对于usb设备，在初始化时会设置成usb_device_type，而usb接口，则会设成usb_if_device_type。
而函数中的 is_usb_device和is_usb_interface就是通过这两个属性来判别的，如果为判定为设备，则进入到设备分支，否则进入到接口分支继续判断。
usb设备驱动通过usb_register_device_driver接口来注册到系统，而usb接口驱动则通过usb_register来注册到系 统，驱动工程师的工作基本上集中在接口驱动上，所以通常是通过usb_register来注册usb驱动的。 
不管是设备驱动usb_device_driver,还是接口驱动usb_driver数据结构中都包含了struct usbdrv_wrap项，其定义如下：
struct usbdrv_wrap {
    struct device_driver driver;
    int for_devices;
}

数据结构中的for_devices用来表示该驱动是设备驱动还是接口驱动，如果为设备驱动，则在用usb_register_device_driver注册时，会将该变量for_devices设置成1，而接口驱动则设为0.

usb_device_match中的is_usb_device_driver函数就是通过获取上而结构中的for_devices来进行判断是设备还是接口驱动的，函数定义如下：
static inline int is_usb_device_driver(struct device_driver *drv)
{ 
    return container_of(drv, struct usbdrv_wrap, driver)-&gt;for_devices;
}
当进入is_usb_device分支后，再通过is_usb_device_driver来判断是否为设备驱动，如果是则返回1，表示匹配成功，它接受所有usb设备。
当进入到接口分支后，也会先用is_usb_device_driver来进行判断，如果不是设备驱动则继续判断，否则退出；然后再通过 usb_match_id函数来判断设备和驱动中的usb_device_id是否匹配，usb_match_id定义如下：
const struct usb_device_id *usb_match_id(struct usb_interface *interface,  const struct usb_device_id *id)
 {
    if (id == NULL)
        return NULL;
    
    for (; id-&gt;idVendor || id-&gt;idProduct || id-&gt;bDeviceClass ||  id-&gt;bInterfaceClass || id-&gt;driver_info; id++) {
        if (usb_match_one_id(interface, id))
            return id;
    }
    
    return NULL;
}

遍历接口驱动中的usb_device_id列表项，只要usb_device_id结构中的 idVendor,idProduct,DeviceClass,binterfaceClass,driver_info项有效就调用 usb_match_one_id进行判断，如找到匹配项则函数返回1，否则返回0 。
int usb_match_one_id(struct usb_interface *interface,const struct usb_device_id *id)
{
    struct usb_host_interface *intf;
    struct usb_device *dev;
    
    if (id == NULL)
        return 0;
    
    intf = interface-&gt;cur_altsetting;
    dev = interface_to_usbdev(interface);
    if (!usb_match_device(dev, id))
        return 0;

    if (dev-&gt;descriptor.bDeviceClass == USB_CLASS_VENDOR_SPEC &amp;&amp; 
     !(id-&gt;match_flags &amp; USB_DEVICE_ID_MATCH_VENDOR) &amp;&amp;(id-&gt;match_flags &amp;  (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS  | USB_DEVICE_ID_MATCH_INT_PROTOCOL)))
        return 0;
    if ((id-&gt;match_flags &amp; USB_DEVICE_ID_MATCH_INT_CLASS) &amp;&amp; (id-&gt;bInterfaceClass != intf-&gt;desc.bInterfaceClass))
        return 0;
    if ((id-&gt;match_flags &amp; USB_DEVICE_ID_MATCH_INT_SUBCLASS) &amp;&amp; 
        (id-&gt;bInterfaceSubClass != intf-&gt;desc.bInterfaceSubClass))
        return 0;
    if ((id-&gt;match_flags &amp; USB_DEVICE_ID_MATCH_INT_PROTOCOL) &amp;&amp; 
        (id-&gt;bInterfaceProtocol != intf-&gt;desc.bInterfaceProtocol))
        return 0;
        
    return 1;
}
 
usb_match_one_id和函数中的usb_match_device都是围绕着usb_device_id进行匹配的，该结构定义如下：
struct usb_device_id {
    /* which fields to match against? */
    __u16  match_flags;
    /* Used for product specific matches; range is inclusive */
    __u16  idVendor;
    __u16  idProduct;
    __u16  bcdDevice_lo;
    __u16  bcdDevice_hi;
    /* Used for device class matches */
    __u8  bDeviceClass;
    __u8  bDeviceSubClass;
    __u8  bDeviceProtocol;
    /* Used for interface class matches */
    __u8  bInterfaceClass;
    __u8  bInterfaceSubClass;
    __u8  bInterfaceProtocol;
    /* not matched against */
    kernel_ulong_tdriver_info;
};
match_flags用来规定驱动匹配时的具体项，如match_flags包含USB_DEVICE_ID_MATCH_VENDOR，则是通过驱动中的usb_device_id和设备dev中的idVendor来判断。
</rich_text></node><node name="suspend" prog_lang="custom-colors" readonly="False" tags="" unique_id="16"><rich_text foreground="#ff0000" scale="h2">一、对于休眠(suspend)的简单介绍</rich_text><rich_text foreground="#ff0000">
 </rich_text><rich_text>   在Linux中,休眠主要分三个主要的步骤:
    1) 冻结用户态进程和内核态任务
    2) 调用注册的设备的suspend的回调函数, 顺序是按照注册顺序
    3) 休眠核心设备和使CPU进入休眠态, 冻结进程是内核把进程列表中所有的进程的状态都设置为停止,并且保存下所有进程的上下文. 当这些进程被解冻的时候,他们是不知道自己被冻结过的,只是简单的继续执行。
    如何让Linux进入休眠呢?用户可以通过读写sys文件/sys /power/state 是实现控制系统进入休眠. 比如
    # echo mem &gt; /sys/power/state
    命令系统进入休眠. 也可以使用
   # cat /sys/power/state
    来得到内核支持哪几种休眠方式.
    
</rich_text><rich_text foreground="#ff0000" scale="h2">二、Linux Suspend 的流程</rich_text><rich_text foreground="#ff0000">
 </rich_text><rich_text foreground="#000000">1. 相关代码</rich_text><rich_text>
     • kernel/kernel/power/main.c
     • kernel/arch/arm/mach-xxx/pm.c
     • kernel/driver/base/power/main.c
     接下来让我们详细的看一下Linux是怎么休眠/唤醒的:
      用户对于/sys/power/state 的读写会调用到  kernel/kernel/power/main.c中的state_store()， 用户可以写入 const char * const  pm_states[] 中定义的字符串， 比如&quot;mem&quot;, &quot;standby&quot;。
const char *const pm_states[PM_SUSPEND_MAX] = {
 #ifdef CONFIG_EARLYSUSPEND
  [PM_SUSPEND_ON]  = &quot;on&quot;,
 #endif
  [PM_SUSPEND_STANDBY] = &quot;standby&quot;,
  [PM_SUSPEND_MEM] = &quot;mem&quot;,
 };
       常见有standby(suspend to RAM)、mem(suspend to RAM)和disk(suspend to disk)，只是standby耗电更多，返回到正常工作状态的时间更短。     
     然后state_store()会调用enter_state()&lt;</rich_text><rich_text foreground="#3333ff">注：这是经典Linux调用流程， 在Android系统中，Kernel将调用request_suspend_state，而不是enter_state</rich_text><rich_text>&gt;，它首先会检查一些状态参数，然后同步文件系统。
  
1. /** 
2.  *  enter_state - Do common work of entering low-power state. 
3.  *  @state:     pm_state structure for state we're entering. 
4.  * 
5.  *  Make sure we're the only ones trying to enter a sleep state. Fail 
6.  *  if someone has beat us to it, since we don't want anything weird to 
7.  *  happen when we wake up. 
8.  *  Then, do the setup for suspend, enter the state, and cleaup (after 
9.  *  we've woken up). 
10.  */  
11. int enter_state(suspend_state_t state)  
12. {  
13.     int error;  
14.   
15.     if (!valid_state(state))  
16.         return -ENODEV;  
17.   
18.     if (!mutex_trylock(&amp;pm_mutex))  
19.         return -EBUSY;  
20.   
21. #ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE  
22.     suspend_sys_sync_queue();  
23. #else  
24.     printk(KERN_INFO &quot;PM: Syncing filesystems ... &quot;);  
25.     sys_sync();  
26.     printk(&quot;done.\n&quot;);  
27. #endif  
28.   
29.     pr_debug(&quot;PM: Preparing system for %s sleep\n&quot;, pm_states[state]);  
30.     error = suspend_prepare();  
31.     if (error)  
32.         goto Unlock;  
33.   
34.     if (suspend_test(TEST_FREEZER))  
35.         goto Finish;  
36.   
37.     pr_debug(&quot;PM: Entering %s sleep\n&quot;, pm_states[state]);  
38.     pm_restrict_gfp_mask();  
39.     error = suspend_devices_and_enter(state);  
40.     pm_restore_gfp_mask();  
41.   
42.  Finish:  
43.     pr_debug(&quot;PM: Finishing wakeup.\n&quot;);  
44.     suspend_finish();  
45.  Unlock:  
46.     mutex_unlock(&amp;pm_mutex);  
47.     return error;  
48. }  

 2. 准备, 冻结进程
        当进入到suspend_prepare()中以后， 它会给suspend分配一个虚拟终端来输出信息，  然后广播一个系统要进入suspend的Notify， 关闭掉用户态的helper进程，  然后一次调用suspend_freeze_processes()冻结所有的进程， 这里会保存所有进程当前的状态，  也许有一些进程会拒绝进入冻结状态， 当有这样的进程存在的时候， 会导致冻结失败,此函数就会放弃冻结进程，并且解冻刚才冻结的所有进程。
 
1. /** 
2.  *  suspend_prepare - Do prep work before entering low-power state. 
3.  * 
4.  *  This is common code that is called for each state that we're entering. 
5.  *  Run suspend notifiers, allocate a console and stop all processes. 
6.  */  
7. static int suspend_prepare(void)  
8. {  
9.     int error;  
10.   
11.     if (!suspend_ops || !suspend_ops-&gt;enter)  
12.         return -EPERM;  
13.   
14.     pm_prepare_console();  
15.   
16.     error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);  
17.     if (error)  
18.         goto Finish;  
19.   
20.     error = usermodehelper_disable();  
21.     if (error)  
22.         goto Finish;  
23.   
24.     error = suspend_freeze_processes();  
25.     if (!error)  
26.         return 0;  
27.   
28.     suspend_thaw_processes();  
29.     usermodehelper_enable();  
30.  Finish:  
31.     pm_notifier_call_chain(PM_POST_SUSPEND);  
32.     pm_restore_console();  
33.     return error;  
34. }  
3. 让外设进入休眠
         现在, 所有的进程(也包括workqueue/kthread)  都已经停止了，内核态人物有可能在停止的时候握有一些信号量，  所以如果这时候在外设里面去解锁这个信号量有可能会发生死锁，所以在外设的suspend()函数里面作lock/unlock锁要非常小心，这里建议设 计的时候就不要在suspend()里面等待锁。而且因为suspend的时候，有一些Log是无法输出的，所以一旦出现问题,非常难调试。
      然后kernel在这里会尝试释放一些内存。
      最后会调用suspend_devices_and_enter()来把所有的外设休眠， 在这个函数中， 如果平台注册了suspend_ops(通常是在板级定义中定义和注册，</rich_text><rich_text foreground="#3333ff">在kernel/arch/arm/mach-xx/pm.c中调用suspend_set_ops</rich_text><rich_text>)， 这里就会调用 suspend_ops-&gt;begin()； 然后调用</rich_text><rich_text foreground="#3333ff">dpm_suspend_start</rich_text><rich_text>，他们会依次调用驱动的suspend()  回调来休眠掉所有的设备。
     当所有的设备休眠以后，  suspend_ops-&gt;prepare()会被调用， 这个函数通常会作一些准备工作来让板机进入休眠。  接下来Linux，在多核的CPU中的非启动CPU会被关掉，通过注释看到是避免这些其他的CPU造成race  condition，接下来的以后只有一个CPU在运行了。
     suspend_ops 是板级的电源管理操作, 通常注册在文件 arch/arch/mach-xxx/pm.c 中.
     接下来， suspend_enter()会被调用，  这个函数会关闭arch irq， 调用 device_power_down()， 它会调用suspend_late()函数，  这个函数是系统真正进入休眠最后调用的函数，通常会在这个函数中作最后的检查。 如果检查没问题， 接下来休眠所有的系统设备和总线，并且调用  suspend_pos-&gt;enter() 来使CPU进入省电状态，这时就已经休眠了。代码的执行也就停在这里了。
 
1. /** 
2.  *  suspend_devices_and_enter - suspend devices and enter the desired system 
3.  *                  sleep state. 
4.  *  @state:       state to enter 
5.  */  
6. int suspend_devices_and_enter(suspend_state_t state)  
7. {  
8.     int error;  
9.   
10.     if (!suspend_ops)  
11.         return -ENOSYS;  
12.   
13.     trace_machine_suspend(state);  
14.   
15.          // 如果平台注册了suspend_ops(通常是在板级定义中定义和注册，  
16.            // 在kernel/arch/arm/mach-xx/pm.c中调用suspend_set_ops)，   
17.            // 这里就会调用 suspend_ops-&gt;begin()；  
18.     if (suspend_ops-&gt;begin) {  
19.         error = suspend_ops-&gt;begin(state);  
20.         if (error)  
21.             goto Close;  
22.     }  
23.     suspend_console();  
24.     suspend_test_start();  
25.   
26.          // 依次调用驱动的suspend() 回调来休眠掉所有的设备。  
27.     error = dpm_suspend_start(PMSG_SUSPEND);  
28.     if (error) {  
29.         printk(KERN_ERR &quot;PM: Some devices failed to suspend\n&quot;);  
30.         goto Recover_platform;  
31.     }  
32.     suspend_test_finish(&quot;suspend devices&quot;);  
33.     if (suspend_test(TEST_DEVICES))  
34.         goto Recover_platform;  
35.           
36.          // 这个函数会关闭arch irq， 调用 device_power_down()， 它会调用suspend_late()函数，   
37.           // 这个函数是系统真正进入休眠最后调用的函数，通常会在这个函数中作最后的检查。  
38.           // 如果检查没问题， 接下来休眠所有的系统设备和总线，并且调用 suspend_pos-&gt;enter()   
39.          // 来使CPU进入省电状态，这时就已经休眠了。代码的执行也就停在这里了。  
40.     error = suspend_enter(state);  
41.   
42.  Resume_devices:  
43.     suspend_test_start();  
44.     dpm_resume_end(PMSG_RESUME);  
45.     suspend_test_finish(&quot;resume devices&quot;);  
46.     resume_console();  
47.  Close:  
48.     if (suspend_ops-&gt;end)  
49.         suspend_ops-&gt;end();  
50.     trace_machine_suspend(PWR_EVENT_EXIT);  
51.     return error;  
52.   
53.  Recover_platform:  
54.     if (suspend_ops-&gt;recover)  
55.         suspend_ops-&gt;recover();  
56.     goto Resume_devices;  
57. }  
58. 

</rich_text><rich_text foreground="#ffff00000000" scale="h2">三、Linux Resume流程</rich_text><rich_text>
        如果在休眠中系统被中断或者其他事件唤醒，接下来的代码就会开始执行，这个唤醒的顺序是和休眠的循序相反的，所以系统设备和总线会首先唤醒，使能系统中 断，使能休眠时候停止掉的非启动CPU， 以及调用suspend_ops-&gt;finish()，  而且在suspend_devices_and_enter()函数中也会继续唤醒每个设备，使能虚拟终端， 最后调用  suspend_ops-&gt;end()。
      在返回到enter_state()函数中的，当  suspend_devices_and_enter() 返回以后，外设已经唤醒了，但是进程和任务都还是冻结状态，  这里会调用suspend_finish()来解冻这些进程和任务， 而且发出Notify来表示系统已经从suspend状态退出， 唤醒终端。
      到这里，所有的休眠和唤醒就已经完毕了，系统继续运行了。
      
      
###########################################################################################
###########################################################################################
</rich_text><rich_text foreground="#ffff00000000" scale="h2">一、简介</rich_text><rich_text>
      Android系统中定义了几种低功耗状态：earlysuspend、suspend、hibernation.
       1) earlysuspend: 是一种低功耗的状态,某些设备可以选择进入某种功耗较低的状态,比如 LCD可以降低亮度或灭掉;  
       2) suspend: 是指除电源管理以外的其他外围模块以及cpu均不工作,只有内存保持自刷新的状态;   
       3)  hibernation是指所有内存镜像都被写入磁盘中,然后系统关机,恢复后系统将能恢复到“关机”之前的状态。是最彻底的低功耗模式，它把所有内存镜 像都写入磁盘中，然后系统关机。该文件还在sysfs文件系统中创建了多个entry，分别是/sys/power/disk，/sys/power /resume和/sys/power/image_size，这样用户可以直接通过 sysfs  来控制系统进出hibernation状态。这块代码跟标准Linux内核没有什么区别。
       
       在打过android补丁的内核中，  state_store()函数会走另外一条路，会进入到request_suspend_state()中，  这个文件在earlysuspend.c中. 这些功能都是android系统加的，后面会对earlysuspend和late resume  进行介绍。
       
</rich_text><rich_text foreground="#ffff00000000" scale="h2">二、用户接口</rich_text><rich_text>
      电源管理内核层给应用层提供的接口就是sysfs 文件系统，所有的相关接口都通过sysfs实现。Android上层frameworks也是基于sysfs做了包装，最终提供给Android java应用程序的是java类的形式。 
 Android系统会在sysfs里面创建以entry：
      /sys/power/state 
      /sys/power/wake_lock 
      /sys/power/wake_unlock
     echo mem &gt; /sys/power/state或echo  standby &gt; /sys/power/state: 命令系统进入earlysuspend状态，那些注册了early suspend  handler的驱动将依次进入各自的earlysuspend 状态。
     echo on &gt; /sys/power/state: 将退出early suspend状态
     echo disk &gt; /sys/power/state: 命令系统进入hibernation状态
    echo lockname &gt; /sys/power/wake_lock: 加锁“lockname”
     echo lockname &gt; /sys/power/wake_unlock: 解锁“lockname”
     上述是分别加锁和解锁的命令，一旦系统中所有wakelock被解锁，系统就会进入suspend状态，可见Linux中原本使系统 suspend 的操作（echo mem &gt; /sys/power/state 等）在Android被替换成使系统进入early  suspend；而wake lock 机制成为用户命令系统进入suspend状态的唯一途径。
 
</rich_text><rich_text foreground="#ffff00000000" scale="h2">三、Android 休眠(suspend)</rich_text><rich_text>
</rich_text><rich_text scale="h3">1. 相关文件</rich_text><rich_text>
      • kernel/kernel/power/main.c
      • kernel/kernel/power/earlysuspend.c
      • kernel/kernel/power/wakelock.c
 
</rich_text><rich_text scale="h3">2. 特性介绍</rich_text><rich_text>
     1) Early Suspend
        Early suspend  是android 引进的一种机制，这种机制在上游备受争议，这里不做评论。  这个机制作用是在关闭显示的时候，一些和显示有关的设备，比如LCD背光、重力感应器、  触摸屏都会关掉，但是系统可能还是在运行状态(这时候还有wake lock)进行任务的处理，例如在扫描 SD卡上的文件等。  在嵌入式设备中，背光是一个很大的电源消耗，所以android会加入这样一种机制。

 </rich_text><rich_text foreground="#000099">     2) Late Resume
 </rich_text><rich_text>         Late Resume 是和suspend 配套的一种机制，是在内核唤醒完毕开始执行的。主要就是唤醒在Early Suspend时休眠的设备。

      </rich_text><rich_text foreground="#000099">3) Wake Lock
 </rich_text><rich_text>         wake_lock  在Android的电源管理系统中扮演一个核心的角色。wake_lock是一种锁的机制，只要有人拿着这个锁，系统就无法进入休眠，可以被用户态程序和 内核获得。这个锁可以是有超时的或者是没有超时的，超时的锁会在超时以后自动解锁。如果没有锁了或者超时了，内核就会启动休眠的那套机制来进入休眠。

</rich_text><rich_text scale="h3">3. Android Suspend</rich_text><rich_text>
        main.c文件是整个框架的入口。用户可以通过读写sys文件/sys/power/state实现控制系统进入低功耗状态。用户对于/sys /power/state的读写会调用到main.c中的state_store()，用户可以写入const char * const  pm_states[] 中定义的字符串， 比如“on”，“mem”，“standby”，“disk”。  
        state_store()首先判断用户写入的是否是“disk”字符串，如果是则调用hibernate()函数命令系统进入hibernation状 态。如果是其他字符串则调用request_suspend_state()（如果定义  CONFIG_EARLYSUSPEND）或者调用enter_state()（如果未定义CONFIG_EARLYSUSPEND）。   request_suspend_state()函数是android相对标准linux改动的地方，它实现在earlysuspend.c中。在标准 linux内核中，用户通过  sysfs 写入“mem”和“standby”时，会直接调用enter_state()进入suspend模式，但在android中则会调用</rich_text><rich_text foreground="#ff0000">request_suspend_state</rich_text><rich_text>()函数进入early suspend状态。request_suspend_state()函数代码如下：    
 
1. void request_suspend_state(suspend_state_t new_state)  
2. {  
3.     unsigned long irqflags;  
4.     int old_sleep;  
5.   
6. #ifdef CONFIG_PLAT_RK  
7.     if (system_state != SYSTEM_RUNNING)  
8.         return;  
9. #endif  
10.   
11.     spin_lock_irqsave(&amp;state_lock, irqflags);  
12.     old_sleep = state &amp; SUSPEND_REQUESTED;  
13.     if (debug_mask &amp; DEBUG_USER_STATE) {  
14.         struct timespec ts;  
15.         struct rtc_time tm;  
16.         getnstimeofday(&amp;ts);  
17.         rtc_time_to_tm(ts.tv_sec, &amp;tm);  
18.         pr_info(&quot;request_suspend_state: %s (%d-&gt;%d) at %lld &quot;  
19.             &quot;(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n&quot;,  
20.             new_state != PM_SUSPEND_ON ? &quot;sleep&quot; : &quot;wakeup&quot;,  
21.             requested_suspend_state, new_state,  
22.             ktime_to_ns(ktime_get()),  
23.             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,  
24.             tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);  
25.     }  
26.     if (!old_sleep &amp;&amp; new_state != PM_SUSPEND_ON) {  
27.         state |= SUSPEND_REQUESTED;  
28.                   //进入Early suspend处理，执行函数early_suspend  
29.         queue_work(suspend_work_queue, &amp;early_suspend_work);  
30.     } else if (old_sleep &amp;&amp; new_state == PM_SUSPEND_ON) {  
31.         state &amp;= ~SUSPEND_REQUESTED;  
32.         wake_lock(&amp;main_wake_lock);  
33.                   //进入Late resume处理,执行函数late_resume  
34.         queue_work(suspend_work_queue, &amp;late_resume_work);  
35.     }  
36.     requested_suspend_state = new_state;  
37.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
38. }  

</rich_text><rich_text scale="h3"> 4. Early Suspend</rich_text><rich_text>
        在early_suspend()函数中，首先会检查现在请求的状态还是否是suspend，  来防止suspend的请求会在这个时候取消掉(因为这个时候用户进程还在运行)，如果需要退出，就简单的退出了。如果没有，  这个函数就会把early_suspend_handlers中注册的一系列的回调(</rich_text><rich_text foreground="#000099">通过register_early_suspend注册</rich_text><rich_text>)都调用一次，然后同步文件系统， 然后放弃掉main_wake_lock，  这个wake lock是一个没有超时的锁，如果这个锁不释放，那么系统就无法进入休眠。
    注：fbearlysuspend.c和consoleearlysuspend.c这两个文件实现了针对lcd  framebuffer的earlysuspend支持和console的earlysuspend支持。实际上这两个文件就是利用上面 earlysuspend.c提供的接口注册了针对framebuffer和console的early suspend  handler，并提供相应的handler函数。
1. static void early_suspend(struct work_struct *work)  
2. {  
3.     struct early_suspend *pos;  
4.     unsigned long irqflags;  
5.     int abort = 0;  
6.   
7. #ifdef CONFIG_PLAT_RK  
8.     if (system_state != SYSTEM_RUNNING)  
9.         return;  
10. #endif  
11.   
12.     mutex_lock(&amp;early_suspend_lock);  
13.     spin_lock_irqsave(&amp;state_lock, irqflags);  
14.     if (state == SUSPEND_REQUESTED)  
15.         state |= SUSPENDED;  
16.     else  
17.         abort = 1;  
18.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
19.   
20.     if (abort) {  
21.         if (debug_mask &amp; DEBUG_SUSPEND)  
22.             pr_info(&quot;early_suspend: abort, state %d\n&quot;, state);  
23.         mutex_unlock(&amp;early_suspend_lock);  
24.         goto abort;  
25.     }  
26.   
27.     if (debug_mask &amp; DEBUG_SUSPEND)  
28.         pr_info(&quot;early_suspend: call handlers\n&quot;);  
29.     list_for_each_entry(pos, &amp;early_suspend_handlers, link) {  
30.         if (pos-&gt;suspend != NULL) {  
31.             if (debug_mask &amp; DEBUG_VERBOSE)  
32.                 pr_info(&quot;early_suspend: calling %pf\n&quot;, pos-&gt;suspend);  
33.             pos-&gt;suspend(pos);  
34.         }  
35.     }  
36.     mutex_unlock(&amp;early_suspend_lock);  
37.   
38. #ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE  
39.     suspend_sys_sync_queue();  
40. #else  
41.     if (debug_mask &amp; DEBUG_SUSPEND)  
42.         pr_info(&quot;early_suspend: sync\n&quot;);  
43.   
44.     sys_sync();  
45. #endif  
46. abort:  
47.     spin_lock_irqsave(&amp;state_lock, irqflags);  
48.     if (state == SUSPEND_REQUESTED_AND_SUSPENDED)  
49.         wake_unlock(&amp;main_wake_lock);  
50.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
51. }  

</rich_text><rich_text scale="h3">5. Late Resume</rich_text><rich_text>
      当所有的唤醒已经结束以后，用户进程都已经开始运行了，唤醒通常会是以下的几种原因:
     • 来电
         如果是来电，那么Modem会通过发送命令给rild来让rild通知WindowManager有来电响应，这样就会远程调用 PowerManagerService来写&quot;on&quot; 到 /sys/power/state 来执行late resume的设备，比如点亮屏幕等。
    • 用户按键
      用户按键事件会送到WindowManager中，WindowManager会处理这些按键事件，按键分为几种情况，如果按键不是唤醒键(能够唤醒系统的按键) 那么WindowManager会主动放弃wakeLock来使系统再次进入休眠，如果按键是唤醒键，那么WindowManger就会调用PowerManagerService中的接口来执行Late  Resume。
   Late Resume 会依次唤醒前面调用了Early Suspend的设备。
1. static void late_resume(struct work_struct *work)  
2. {  
3.     struct early_suspend *pos;  
4.     unsigned long irqflags;  
5.     int abort = 0;  
6.   
7. #ifdef CONFIG_PLAT_RK  
8.     if (system_state != SYSTEM_RUNNING)  
9.         return;  
10. #endif  
11.   
12.     mutex_lock(&amp;early_suspend_lock);  
13.     spin_lock_irqsave(&amp;state_lock, irqflags);  
14.     if (state == SUSPENDED)  
15.         state &amp;= ~SUSPENDED;  
16.     else  
17.         abort = 1;  
18.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
19.   
20.     if (abort) {  
21.         if (debug_mask &amp; DEBUG_SUSPEND)  
22.             pr_info(&quot;late_resume: abort, state %d\n&quot;, state);  
23.         goto abort;  
24.     }  
25.     if (debug_mask &amp; DEBUG_SUSPEND)  
26.         pr_info(&quot;late_resume: call handlers\n&quot;);  
27.     list_for_each_entry_reverse(pos, &amp;early_suspend_handlers, link) {  
28.         if (pos-&gt;resume != NULL) {  
29.             if (debug_mask &amp; DEBUG_VERBOSE)  
30.                 pr_info(&quot;late_resume: calling %pf\n&quot;, pos-&gt;resume);  
31.   
32.             pos-&gt;resume(pos);  
33.         }  
34.     }  
35.     if (debug_mask &amp; DEBUG_SUSPEND)  
36.         pr_info(&quot;late_resume: done\n&quot;);  
37. abort:  
38.     mutex_unlock(&amp;early_suspend_lock);  
39. }  

</rich_text><rich_text scale="h3">6. Wake Lock</rich_text><rich_text>
     </rich_text><rich_text foreground="#ff0000">wake_lock防止正在运行的系统进入suspend或其它低功耗状态。</rich_text><rich_text>
</rich_text><rich_text foreground="#ff0000">     Android改动较大的另一处是增加了</rich_text><rich_text foreground="#3333ff">wakelock</rich_text><rich_text>机制。实现在wakelock.c和userwakelock.c中。wakelock可以阻止处于正常运行（active）或者空闲（idle）状态的系统进入睡眠等低功耗状态。直到所持有的wakelock全部被释放，系统才能进入睡眠等低功耗的状态。
    我们接下来看一看wake lock的机制是怎么运行和起作用的，主要关注 wakelock.c(wake_lock)文件就可以了。
    1) wake lock 有加锁和解锁两种状态，加锁的方式有两种：
     • 第一种是永久的锁住，这样的锁除非显示的放开，是不会解锁的，所以这种锁的使用是非常小心的。
     • 第二种是超时锁，这种锁会锁定系统唤醒一段时间，如果这个时间过去了，这个锁会自动解除。
    2) 锁有两种类型：
     • WAKE_LOCK_SUSPEND：这种锁会防止系统进入睡眠(suspend)。
     • WAKE_LOCK_IDLE：这种锁不会影响系统的休眠，用于阻止系统在持有锁的过程中进入低功耗状态。即直到wake_lock被释放，系统才会从idle状态进入低功耗状态，此低功耗状态将使中断延迟或禁用一组中断。
    3) 在wake lock中， 会有3个地方让系统直接开始</rich_text><rich_text foreground="#ff0000">suspend</rich_text><rich_text>()， 分别是:
     • 在wake_unlock()中， 如果发现解锁以后没有任何其他的wake lock了，就开始休眠
     • 在定时器都到时间以后，定时器的回调函数会查看是否有其他的wake lock，如果没有，就在这里让系统进入睡眠。
     • 在wake_lock() 中，对一个wake lock加锁以后，会再次检查一下有没有锁， 我想这里的检查是没有必要的， 更好的方法是使加锁的这个操作原子化，而不是繁冗的检查，而且这样的检查也有可能漏掉。 

</rich_text><rich_text scale="h3">7. Suspend</rich_text><rich_text>
    当wake_lock 运行 suspend()以后，  在wakelock.c的suspend()函数会被调用，这个函数首先sync文件系统，然后调用 pm_suspend(request_suspend_state)，接下来pm_suspend()就会调用enter_state()来进入 Linux的休眠流程...

1. static void suspend(struct work_struct *work)  
2. {  
3.     int ret;  
4.     int entry_event_num;  
5.     struct timespec ts_entry, ts_exit;  
6.   
7.     if (has_wake_lock(WAKE_LOCK_SUSPEND)) {  
8.         if (debug_mask &amp; DEBUG_SUSPEND)  
9.             pr_info(&quot;suspend: abort suspend\n&quot;);  
10.         return;  
11.     }  
12.   
13.     entry_event_num = current_event_num;  
14. #ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE  
15.     suspend_sys_sync_queue();  
16. #else  
17.     sys_sync();  
18. #endif  
19.     if (debug_mask &amp; DEBUG_SUSPEND)  
20.         pr_info(&quot;suspend: enter suspend\n&quot;);  
21.     getnstimeofday(&amp;ts_entry);  
22.     ret = pm_suspend(requested_suspend_state);  
23.     getnstimeofday(&amp;ts_exit);  
24.   
25.     if (debug_mask &amp; DEBUG_EXIT_SUSPEND) {  
26.         struct rtc_time tm;  
27.         rtc_time_to_tm(ts_exit.tv_sec, &amp;tm);  
28.         pr_info(&quot;suspend: exit suspend, ret = %d &quot;  
29.             &quot;(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n&quot;, ret,  
30.             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,  
31.             tm.tm_hour, tm.tm_min, tm.tm_sec, ts_exit.tv_nsec);  
32.     }  
33.   
34.     if (ts_exit.tv_sec - ts_entry.tv_sec &lt;= 1) {  
35.         ++suspend_short_count;  
36.   
37.         if (suspend_short_count == SUSPEND_BACKOFF_THRESHOLD) {  
38.             suspend_backoff();  
39.             suspend_short_count = 0;  
40.         }  
41.     } else {  
42.         suspend_short_count = 0;  
43.     }  
44.   
45.     if (current_event_num == entry_event_num) {  
46.         if (debug_mask &amp; DEBUG_SUSPEND)  
47.             pr_info(&quot;suspend: pm_suspend returned with no event\n&quot;);  
48.         wake_lock_timeout(&amp;unknown_wakeup, HZ / 2);  
49.     }  
50. }  

</rich_text><rich_text scale="h3">8. Android于标准Linux休眠的区别</rich_text><rich_text>
      pm_suspend() 虽然用enter_state()来进入标准的Linux休眠流程，但是还是有一些区别：
      当进入冻结进程的时候，android首先会检查有没有wake lock，如果没有，才会停止这些进程，因为在开始suspend和冻结进程期间有可能有人申请了wake lock，如果是这样，冻结进程会被中断。
      在suspend_late()中，会最后检查一次有没有wake  lock，这有可能是某种快速申请wake lock，并且快速释放这个锁的进程导致的，如果有这种情况， 这里会返回错误，  整个suspend就会全部放弃。如果pm_suspend()成功了，LOG的输出可以通过在kernel cmd里面增加 &quot;</rich_text><rich_text foreground="#ff0000">no_console_suspend</rich_text><rich_text>&quot; 来看到suspend和resume过程中的log输出。
      
</rich_text><node name="early_suspend" prog_lang="custom-colors" readonly="False" tags="" unique_id="17"><rich_text scale="h2">（1）添加头文件：</rich_text><rich_text>
#include &lt;linux/earlysuspend.h&gt;

</rich_text><rich_text scale="h2">（2）在特定驱动结构体中添加early_suspend结构：</rich_text><rich_text>
#ifdef CONFIG_HAS_EARLYSUSPEND
 struct early_suspend early_suspend;
 #endif
 
</rich_text><rich_text scale="h2">（3）在驱动probe函数中注册相关early_suspend结构体：</rich_text><rich_text>
#ifdef CONFIG_HAS_EARLYSUSPEND
 ftk_ts-&gt;early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 ftk_ts-&gt;early_suspend.suspend = stm_ts_early_suspend;
 ftk_ts-&gt;early_suspend.resume =stm_ts_late_resume;
 register_early_suspend(&amp;ftk_ts-&gt;early_suspend);
 #endif
     所有注册到系统中的early_suspend结构都会按level值按顺序加入到全局链表early_suspend_handlers中。 
     希望执行early  suspend的设备，他的设备驱动程序需要向电源管理系统注册，该结构体用于向电源管理系统注册earlysuspend/lateresume，当电源管理系统启动suspend流程时，回调函数suspend会被调用，相反，resume的最后阶段，回调函数resume会被调用，level字段用 于调整该结构体在注册链表中的位置，suspend时，</rich_text><rich_text foreground="#ff0000">level的数值越小，回调函数的被调用的时间越早</rich_text><rich_text>，resume时则反过来。Android预先定义了3个level等级：
 
1. enum {  
2.     EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,  
3.     EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,  
4.     EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,  
5. };  
6. struct early_suspend {  
7. #ifdef CONFIG_HAS_EARLYSUSPEND  
8.     struct list_head link;  
9.     int level;  
10.     void (*suspend)(struct early_suspend *h);  
11.     void (*resume)(struct early_suspend *h);  
12. #endif  
13. };  
 
</rich_text><rich_text scale="h2">（4）在驱动remove函数取消early_suspend结构体的注册：</rich_text><rich_text>
#ifdef CONFIG_HAS_EARLYSUSPEND
 unregister_early_suspend(&amp;ts-&gt;early_suspend);
 #endif
 
</rich_text><rich_text scale="h2">（5）定义相关suspend和resume函数：</rich_text><rich_text>
#ifdef CONFIG_HAS_EARLYSUSPEND
 static void stm_ts_early_suspend(struct early_suspend *h)
 {
     struct ftk_ts *ts;
     ts = container_of(h, struct ftk_ts, early_suspend);
     stm_ts_suspend(ts-&gt;client, PMSG_SUSPEND);
 }
static void stm_ts_late_resume(struct early_suspend *h)
 {
     struct ftk_ts *ts;
     ts = container_of(h, struct ftk_ts, early_suspend);
     stm_ts_resume(ts-&gt;client);
 }
 #endif
 
</rich_text><rich_text scale="h2">（6）在系统驱动结构体中设置未使用earlysuspend的函数接口：</rich_text><rich_text>
#ifndef CONFIG_HAS_EARLYSUSPEND
 .suspend = stm_ts_suspend,
 .resume = stm_ts_resume,
 #endif
</rich_text></node><node name="wake lock" prog_lang="custom-colors" readonly="False" tags="" unique_id="18"><rich_text>    Android在标准的Linux休眠与唤醒机制上又加了一层，就是early_suspend /  late_resume。顾名思意，使用early_suspend（）进行休眠的设备，它休眠的时刻早于其他设备，使用late_resume（）唤醒 的设备，它被唤醒的时刻要晚于其他设备。这对函数通常成对出现，当内核打开了CONFIG_EARLY_SUSPEND(Android默认打开)后，就 可以使
用这组函数来代替驱动中标准的 suspend / resume接口。
        好了，讲到early_suspend和late_resume，似乎必须要扯到一种叫做wake_lock的锁定机制了。其实，单纯从某个设备的驱动程序上来讲，未必需要用到wake_lock机制，
比如我们的触摸屏驱动中使用了early_suspend，就没有使用wake_lock.
       目前，我了解到的，wake_lock的用途只有一个，那就是防止系统进入休眠（这里的休眠，指的是标准的Linux的休眠，不包含使用early_suspend（）进行休眠的设备，
使用early_suspend()的设备，在系统还有wake_lock锁的时候，也是要休眠的）。
       好吧，现在是时候分析下Android/Linux的休眠与唤醒了，虽然好多先人 都已经讲了这些，而且讲的还不错，这里我还是要提一下。
root@android:/ # ls /sys/power/                                                
 pm_async
 </rich_text><rich_text foreground="#ff0000">state</rich_text><rich_text>
 wait_for_fb_sleep
 wait_for_fb_wake
 wake_lock
 wake_unlock
 wakeup_count
       这里，我只关注state，当state 的值变化时，内核会调用

1. static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,  
2.                const char *buf, size_t n)  
3. {  
4. #ifdef CONFIG_SUSPEND  
5. #ifdef CONFIG_EARLYSUSPEND  
6.     suspend_state_t state = PM_SUSPEND_ON;  
7. #else  
8.     suspend_state_t state = PM_SUSPEND_STANDBY;  
9. #endif  
10.     const char * const *s;   
11. #endif  
12.     char *p;   
13.     int len;  
14.     int error = -EINVAL;  
15.   
16.     p = memchr(buf, '\n', n);   
17.     len = p ? p - buf : n;  
18.   
19.     /* First, check if we are requested to hibernate */  
20.     if (len == 4 &amp;&amp; !strncmp(buf, &quot;disk&quot;, len)) {  
21.         error = hibernate();  
22.   goto Exit;  
23.     }     
24.   
25. #ifdef CONFIG_SUSPEND  
26.     for (s = &amp;pm_states[state]; state &lt; PM_SUSPEND_MAX; s++, state++) {  
27.         if (*s &amp;&amp; len == strlen(*s) &amp;&amp; !strncmp(buf, *s, len))  
28.             break;  
29.     }     
30.     if (state &lt; PM_SUSPEND_MAX &amp;&amp; *s)   
31. #ifdef CONFIG_EARLYSUSPEND  
32.         if (state == PM_SUSPEND_ON || valid_state(state)) {  
33.             error = 0;  
34.             request_suspend_state(state);//这里，进入了Android的休眠与唤醒的处理函数  
35.         }  
36. #else  
37.         error = enter_state(state);  
38. #endif  
39. #endif  
40.   
41.  Exit:  
42.     return error ? error : n;  
43. }  
44.   
45. power_attr(state);  


 
看看1. request_suspend_state()都干了些什么事情  

1. void request_suspend_state(suspend_state_t new_state)  
2. {  
3.     unsigned long irqflags;  
4.     int old_sleep;  
5.   
6.     spin_lock_irqsave(&amp;state_lock, irqflags);  
7.     old_sleep = state &amp; SUSPEND_REQUESTED;  
8.     if (debug_mask &amp; DEBUG_USER_STATE) {  
9.         struct timespec ts;   
10.         struct rtc_time tm;   
11.         getnstimeofday(&amp;ts);  
12.         rtc_time_to_tm(ts.tv_sec, &amp;tm);  
13.         pr_info(&quot;request_suspend_state: %s (%d-&gt;%d) at %lld &quot;  
14.             &quot;(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n&quot;,  
15.             new_state != PM_SUSPEND_ON ? &quot;sleep&quot; : &quot;wakeup&quot;,  
16.             requested_suspend_state, new_state,  
17.             ktime_to_ns(ktime_get()),  
18.             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,  
19.             tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);  
20.     }     
21.     if (!old_sleep &amp;&amp; new_state != PM_SUSPEND_ON) {  
22.         state |= SUSPEND_REQUESTED;  
23.         queue_work(suspend_work_queue, &amp;early_suspend_work);//在休眠的时候，去遍历执行early_suspend_work这个队列  
24.     } else if (old_sleep &amp;&amp; new_state == PM_SUSPEND_ON) {  
25.         state &amp;= ~SUSPEND_REQUESTED;  
26.         wake_lock(&amp;main_wake_lock);  
27.         queue_work(suspend_work_queue, &amp;late_resume_work);//在唤醒的时候，去遍历执行late_resume_work这个队列  
28.     }     
29.     requested_suspend_state = new_state;  
30.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
31. }  

        怎么样，是不是很简单，根据用户/系统所请求的状态，去做相应的动作（休眠/唤醒）能用到的一些变量的声明在这里

1. static void early_suspend(struct work_struct *work);  
2. static void late_resume(struct work_struct *work);  
3. static DECLARE_WORK(early_suspend_work, early_suspend);  
4. static DECLARE_WORK(late_resume_work, late_resume);  
         看名字也知道了，early_suspend这个函数指针来处理early_suspend_work这条队列，late_resume 这个函数指针来处理late_resume_work这条队列。
         虽然函数early_suspend()和late_resume()的实现都非常易懂，这里还是要贴出来，因为还有些东西要分析一下。

1. static void early_suspend(struct work_struct *work)  
2. {  
3.     struct early_suspend *pos;  
4.     unsigned long irqflags;  
5.     int abort = 0;  
6.   
7.     mutex_lock(&amp;early_suspend_lock);  
8.     spin_lock_irqsave(&amp;state_lock, irqflags);  
9.     if (state == SUSPEND_REQUESTED)  
10.         state |= SUSPENDED;  
11.     else  
12.         abort = 1;  
13.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
14.   
15.     if (abort) {  
16.         if (debug_mask &amp; DEBUG_SUSPEND)  
17.             pr_info(&quot;early_suspend: abort, state %d\n&quot;, state);  
18.         mutex_unlock(&amp;early_suspend_lock);  
19.         goto abort;  
20.     }  
21.   
22.     if (debug_mask &amp; DEBUG_SUSPEND)  
23.         pr_info(&quot;early_suspend: call handlers\n&quot;);  
24.     list_for_each_entry(pos, &amp;early_suspend_handlers, link) {//这里就是关键了，遍历early_suspend_handler这条链表（在驱动中注册early_suspend的时候，都注册到这条链表上了）  
25.         if (pos-&gt;suspend != NULL) {  
26.             if (debug_mask &amp; DEBUG_VERBOSE)  
27.                 pr_info(&quot;early_suspend: calling %pf\n&quot;, pos-&gt;suspend);  
28.             pos-&gt;suspend(pos);//调用各个实现进行各设备的休眠  
29.         }  
30.     }  
31.     mutex_unlock(&amp;early_suspend_lock);  
32.   
33.     if (debug_mask &amp; DEBUG_SUSPEND)  
34.         pr_info(&quot;early_suspend: sync\n&quot;);  
35.   
36.     sys_sync();  
37. abort:  
38.     spin_lock_irqsave(&amp;state_lock, irqflags);  
39.     if (state == SUSPEND_REQUESTED_AND_SUSPENDED)  
40.         wake_unlock(&amp;main_wake_lock);// 这里很重要，别小看这个一个wake_unlock,起初我也以为这仅仅是一个释放main锁，其实里面有玄机呢。还记得wake_lock主要用来干嘛 么，用来防止系统休眠，也就是说，只要系统中其他地方还拥有wake_lock锁（类型WAKE_LOCK_SUSPEND），系统就没法进入休眠，如果 没有锁了，那就要接着走标准Linux的那一套休眠机制了  
41.     spin_unlock_irqrestore(&amp;state_lock, irqflags);  
42. }  
1.   
先跳过late_resume()。来看下wake_unlock()的实现吧

1. void wake_unlock(struct wake_lock *lock)  
2. {  
3.     int type;  
4.     unsigned long irqflags;  
5.     spin_lock_irqsave(&amp;list_lock, irqflags);  
6.     type = lock-&gt;flags &amp; WAKE_LOCK_TYPE_MASK;  
7. #ifdef CONFIG_WAKELOCK_STAT  
8.     wake_unlock_stat_locked(lock, 0);   
9. #endif  
10.     if (debug_mask &amp; DEBUG_WAKE_LOCK)  
11.         pr_info(&quot;wake_unlock: %s\n&quot;, lock-&gt;name);  
12.     lock-&gt;flags &amp;= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);  
13.     list_del(&amp;lock-&gt;link);  
14.     list_add(&amp;lock-&gt;link, &amp;inactive_locks);  
15.     if (type == WAKE_LOCK_SUSPEND) {//类型，驱动中一般只有这一种类型  
16.         long has_lock = has_wake_lock_locked(type);  
17.         if (has_lock &gt; 0) {  
18.             if (debug_mask &amp; DEBUG_EXPIRE)  
19.                 pr_info(&quot;wake_unlock: %s, start expire timer, &quot;  
20.                     &quot;%ld\n&quot;, lock-&gt;name, has_lock);  
21.             mod_timer(&amp;expire_timer, jiffies + has_lock);  
22.         } else {  
23.             if (del_timer(&amp;expire_timer))  
24.                 if (debug_mask &amp; DEBUG_EXPIRE)  
25.                     pr_info(&quot;wake_unlock: %s, stop expire &quot;  
26.                         &quot;timer\n&quot;, lock-&gt;name);  
27.             if (has_lock == 0)//如果没有锁了，要进入标准Linux的休眠机制了，咱们接着往下跟  
28.                 queue_work(suspend_work_queue, &amp;suspend_work);  
29.         }     
30.         if (lock == &amp;main_wake_lock) {  
31.             if (debug_mask &amp; DEBUG_SUSPEND)  
32.                 print_active_locks(WAKE_LOCK_SUSPEND);  
33. #ifdef CONFIG_WAKELOCK_STAT  
34.             update_sleep_wait_stats_locked(0);  
35. #endif  
36.         }     
37.     }     
38.     spin_unlock_irqrestore(&amp;list_lock, irqflags);  
39. }  
40. EXPORT_SYMBOL(wake_unlock);  


 
这里就是进入标准Linux的休眠的地方了
1. static void suspend(struct work_struct *work)  
2. {  
3.     int ret;  
4.     int entry_event_num;  
5.     struct timespec ts_entry, ts_exit;  
6.   
7.     if (has_wake_lock(WAKE_LOCK_SUSPEND)) {  
8.         if (debug_mask &amp; DEBUG_SUSPEND)  
9.             pr_info(&quot;suspend: abort suspend\n&quot;);  
10.         return;  
11.     }  
12.   
13.     entry_event_num = current_event_num;  
14.     sys_sync();  
15.     if (debug_mask &amp; DEBUG_SUSPEND)  
16.         pr_info(&quot;suspend: enter suspend\n&quot;);  
17.     getnstimeofday(&amp;ts_entry);  
18.     ret = pm_suspend(requested_suspend_state);//这里是关键点  
19.     getnstimeofday(&amp;ts_exit);  
20.   
21.     if (debug_mask &amp; DEBUG_EXIT_SUSPEND) {  
22.         struct rtc_time tm;  
23.         rtc_time_to_tm(ts_exit.tv_sec, &amp;tm);  
24.         pr_info(&quot;suspend: exit suspend, ret = %d &quot;  
25.             &quot;(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n&quot;, ret,  
26.             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,  
27.             tm.tm_hour, tm.tm_min, tm.tm_sec, ts_exit.tv_nsec);  
28.     }  
29.   
30.     if (ts_exit.tv_sec - ts_entry.tv_sec &lt;= 1) {  
31.         ++suspend_short_count;  
32.   
33.         if (suspend_short_count == SUSPEND_BACKOFF_THRESHOLD) {  
34.             suspend_backoff();  
35.             suspend_short_count = 0;  
36.         }  
37.     } else {  
38.         suspend_short_count = 0;  
39.     }  
40.   
41.     if (current_event_num == entry_event_num) {  
42.         if (debug_mask &amp; DEBUG_SUSPEND)  
43.             pr_info(&quot;suspend: pm_suspend returned with no event\n&quot;);  
44.         wake_lock_timeout(&amp;unknown_wakeup, HZ / 2);  
45.     }  
46. }  
47. static DECLARE_WORK(suspend_work, suspend);  

1. int pm_suspend(suspend_state_t state)  
2. {  
3.     if (state &gt; PM_SUSPEND_ON &amp;&amp; state &lt; PM_SUSPEND_MAX)  
4.         return enter_state(state);//正如你所料，开始走Linux那套休眠的流程了  
5.     return -EINVAL;  
6. }  
7. EXPORT_SYMBOL(pm_suspend);  

       唤醒相关的代码就不贴 了，跟休眠类似的。下面讲下驱动中如何使用wake_lock和early_suspend，总的来说，还是挺简单的
比如在设备probe的时候做如下操作
struct early_suspend    early_suspend;
 
early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1; //等级，等级大小和suspend顺序一致，和resume顺序相反
 early_suspend.suspend = xxx_early_suspend;//指定函数指针，需自己实现
 early_suspend.resume = xxx_late_resume;
register_early_suspend(&amp;early_suspend);//注册进核心，也就是加入刚才early_suspend_handlers那个链表

 struct wake_lock    chrg_lock;
 wake_lock_init(&amp;chrg_lock, WAKE_LOCK_SUSPEND, &quot;xxx_wake_lock&quot;);//初始化类型为WAKE_LOCK_SUSPEND的wake_lock锁
#ifdef CONFIG_HAS_EARLYSUSPEND
 static void xxx_early_suspend(struct early_suspend *h)
 {
        ....
         wake_lock(&amp;chrg_lock);
       ....
 }
 
 
 static void xxx_late_resume(struct early_suspend *h)
 {
      .....
         wake_unlock(&amp;chrg_lock);
      ....
 }
 #endif
 
</rich_text></node><node name="Linux 关机和重启机制" prog_lang="custom-colors" readonly="False" tags="" unique_id="19"><rich_text>Linux 关机和重启机制
一．sys_reboot
二．apm capi
 
Linux下的关机和重启可能由两种行为引发，一是通过用户编程，另外一种是系统自己产生的信息。用户和系统进行交互的方式有两种，一种是系统调用sys_reboot，另外一个则是apm或者acpi的设备文件，通过对其操作也可以是系统关机或者重启。

</rich_text><rich_text scale="h2">一．sys_reboot</rich_text><rich_text>
    linux下关机和重启命令主要有，shutdown，reboot，halt, poweroff, telinit,和init。对于
    poweroff和reboot是halt的符号链接，不过最终都调用reboot系统调用来完成关机和重启操作，该部分代码在kernel/sys.c中。
    在调用sys_reboot时，应该注意一点，
reboot doesn't sync: do that yourself before calling this.
所以在使用之前应该手动sync命令同步磁盘。
该函数流程如下，
    i)                    检查调用者是否有合法调用reboot的权限。
    ii)                  通过魔数magic1和magic2，判断reboot系统调用是不是被偶然调用的。
    iii)                对不同的调用使用情况区分，如
        LINUX_REBOOT_CMD_RESTART, //restarting system
        LINUX_REBOOT_CMD_HATL,  // system halted 
        LINUX_REBOOT_CMD_POWER_OFF //power down
        LINUX_REBOOT_CMD_RESTART2 //接收命令字符 说明系统该如何关闭
        LINUX_REBOOT_CMD_CAD_ON/OFF //用于决定是否允许Ctrl+alt+del组合键用于关闭并重启系统。
    如果想禁止这个功能，可以在/etc/inittab文件的下面一行注释掉
    Ca:12345:ctrlatldel:/sbin/shutdown –tl –a –r now
    当然对于arm体系来说，用到的可能性较少

</rich_text><rich_text scale="h3">1.    restart</rich_text><rich_text>
    a) shutdown       对于restart而言，首先需要通过blocking_notifier_call_chain这一通知机制，将挂在reboot_notifier_list上，对于reboot操作需要通知的设备进行消息通知。
       接着通知所有的驱动总线（包括i2c,usb,spi,platform等bus），如果总线本身有shutdown操作，则先调用总线的shutdown操作，否则逐一调用总线上对应设备驱动的shutdown方法，接着清空sys文件系统（根据驱动模型思考,device_shutdown）
       然后与上述描述类似的，进行shut down all system device,同样调用的是shutdown方法。
       
       最后调用machine_start，也就是arm_pm_restart,即arm_machine_start进行重启操作。
    b) arm_machine_start       实际上最终调用的是arch_reset，对于不同的cpu，调用的arch_reset不同。
    对于x86而言，开始部分有一段SMP相关的代码，主要完成多CPU时，一个CPU完成重启，而其他CPU处于等待的状态。之后根据变量reboot_thru_bios的内容判断重启方式，这个参数是reboot_setup指定的。在通过bios重启的情况下，系统同样先设定重启模式，然后切换到实模式，通过ljmp $0xffff,$0x0完成重启。
       对于arm mx25而言，相对简单，arch_reset最后调用mxc_wd_reset函数，该函数中，通过使能wacht dog时钟，使能Wdog,并且设置watch dog ctrl reg的SRS位，即software reset signal ，让WDOG 产生一个reset signal，从而实现reset操作。（而接下来的就是arm启动流程）

</rich_text><rich_text scale="h3">2.power_off</rich_text><rich_text>
    Power_off准备操作与resetart类似，shutdown结束后，最后调用的pm_board_off,
该方法可以在板级初始化的时候进行指定。
      a) arm在machine_power_off中，如果定义了pm_board_off 方法则会调用该函数关机，根据体系不同设置，操作一般为拉低口线之类的操作。
      
      b) apm x86而如果在apm已经加载的情况下（在arm中没有，x86中实现），实际指向的是apm_power_off，在该函数里系统通过apm_info结构里的值，使用切换到实模式关机，或者使用apm_bios_call_simple函数调用保护模式下的apm接口关机两种方法。
              
    apm使用其注册的设备的ioctl接口完成apm的操作，在apm.c的do_ioctl函数中可以看见处理的分支。这里只有suspend和standby的代码，所以我们不能通过ioctl这种方法使用apm关机。 
    当用户按下POWER开关的时候，如果有apm模块，那么关机流程是由apm来处理的。apm驱动在初始化的时候启动了一个apm内核线程：apm_mainloop，系统会在这里检测到POWEROFF按键消息并且将其命名为APM_SYS_SUSPEND，以区别apm -s设置的APM_USER_SUSPEND模式。紧接着进入了apm_event_handler函数，又从apm_event_handler函数进入了check_events函数，处理函数对应的case分支上。系统同样使用了suspend函数进行关机，不过由于其它参数的原因，suspend最后调用的是关机的流程。
</rich_text></node><node name="android对休眠唤醒的实现" prog_lang="custom-colors" readonly="False" tags="" unique_id="20"><rich_text>
</rich_text><node name="(一)" prog_lang="custom-colors" readonly="False" tags="" unique_id="21"><rich_text scale="h2" weight="heavy">一、新增特性介绍</rich_text><rich_text>
 
实际上，android仍然是利用了标准linux的休眠唤醒系统，只不过添加了一些使用上的新特性，early suspend、late resume、wake lock。
 
Early suspend - 这个机制定义了在suspend的早期，关闭显示屏的时候，一些和显示屏相关的设备，比如背光、重力感应器和触摸屏等设备都应该被关掉，但是此时系统可能还有持有wake lock的任务在运行，如音乐播放，电话，或者扫描sd卡上的文件等，这个时候整个系统还不能进入真正睡眠，直到所有的wake lock都没释放。在嵌入式设备中，悲观是一个很大的电源消耗，所有android加入了这种机制。
 
Late resume - 这个机制定义了在resume的后期，也就是唤醒源已经将处理器唤醒，标准linux的唤醒流程已经走完了，在android上层系统识别出这个物理上的唤醒源是上层定义的，那么上层将会发出late resume的命令给下层，这个时候将会调用相关设备注册的late resume回调函数。
 
Wake lock - wakelock在android的电源管理系统中扮演一个核心的角色，wakelock是一种锁的机制, 只要有task拿着这个锁, 系统就无法进入休眠, 可以被用户态进程和内核线程获得。这个锁可以是有超时的或者是没有超时的, 超时的锁会在时间过去以后自动解锁。如果没有锁了或者超时了, 内核就会启动标准linux的那套休眠机制机制来进入休眠。
 
</rich_text><rich_text scale="h2" weight="heavy">二、kernel层源码解析 - early suspend 和 late resume实现</rich_text><rich_text>
相关源码：
kernel/kernel/power/main.c
kernel/kernel/power/earlysuspend.c
kernel/kernel/power/wakelock.c
kernel/kernel/power/userwakelock.c
kernel/kernel/power/suspend.c
 
之前标准的linux的sysfs的接口只需要一个state就够了，现在至少需要3个接口文件：state、wake_lock、wake_unlock。现在为了配合android为休眠唤醒添加的几种新特性，可以填入文件state的模式又多了一种：on, 标准android系统中只支持state的on和mem模式，其余的暂不支持。wake_lock和wake_unlock接口对应的读写函数在文件userwakelock.c中，对wakelock.c中的create wakelock或者release wakelock进行了封装，供用户空间来使用。
 
如果上层用户执行:echo xxx(on or mem) &gt; sys/power/state的话，将会调用到如下函数：
static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
const char *buf, size_t n)
{
#ifdef CONFIG_SUSPEND // set
#ifdef CONFIG_EARLYSUSPEND    //set
       suspend_state_t state = PM_SUSPEND_ON;</rich_text><rich_text foreground="#969696">   </rich_text><rich_text>// for early suspend and late resume
#else
       suspend_state_t state = PM_SUSPEND_STANDBY;
#endif
       const char * const *s;
#endif
       char *p;
       int len;
       int error = -EINVAL;
 
       p = memchr(buf, '/n', n);
       len = p ? p - buf : n;
 
       /* First, check if we are requested to hibernate */
       if (len == 4 &amp;&amp; !strncmp(buf, &quot;disk&quot;, len)) {
              error = hibernate();  </rich_text><rich_text foreground="#969696">// </rich_text><rich_text>检查是否要求进入</rich_text><rich_text foreground="#969696">disk</rich_text><rich_text>省电模式，暂时不支持
  goto Exit;
       }
 
#ifdef CONFIG_SUSPEND        // def
       for (s = &amp;pm_states[state]; state &lt; PM_SUSPEND_MAX; s++, state++) {
              if (*s &amp;&amp; len == strlen(*s) &amp;&amp; !strncmp(buf, *s, len))
                     break;
       }
       if (state &lt; PM_SUSPEND_MAX &amp;&amp; *s)
#ifdef CONFIG_EARLYSUSPEND
              if (state == PM_SUSPEND_ON || valid_state(state)) {
</rich_text><rich_text foreground="#969696">// </rich_text><rich_text>需要经过平台</rich_text><rich_text foreground="#969696">pm.c</rich_text><rich_text>文件定义的模式支持检查函数，</rich_text><rich_text foreground="#969696">mtk</rich_text><rich_text>只支持</rich_text><rich_text foreground="#969696">mem</rich_text><rich_text>，同时如果是</rich_text><rich_text foreground="#969696">android</rich_text><rich_text>发送出来的</rich_text><rich_text foreground="#969696">late resume</rich_text><rich_text>命令</rich_text><rich_text foreground="#969696">(on)</rich_text><rich_text>，这里也会放行，往下执行
                     error = 0;
                     request_suspend_state(state);</rich_text><rich_text foreground="#969696">     </rich_text><rich_text>// android休眠唤醒的路线
              }
#else
              error = enter_state(state);</rich_text><rich_text foreground="#969696">// </rich_text><rich_text>标准</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>休眠唤醒的路线
#endif
#endif
 
 Exit:
       return error ? error : n;
}
 
@ kernel/kernel/power/earlysuspend.c
enum {
       DEBUG_USER_STATE = 1U &lt;&lt; 0,
       DEBUG_SUSPEND = 1U &lt;&lt; 2,
};
int Earlysuspend_debug_mask = DEBUG_USER_STATE;
module_param_named(Earlysuspend_debug_mask, Earlysuspend_debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
 
static DEFINE_MUTEX(early_suspend_lock);
static LIST_HEAD(early_suspend_handlers);
static void early_sys_sync(struct work_struct *work);
static void early_suspend(struct work_struct *work);
static void late_resume(struct work_struct *work);
static DECLARE_WORK(early_sys_sync_work, early_sys_sync);
static DECLARE_WORK(early_suspend_work, early_suspend);
static DECLARE_WORK(late_resume_work, late_resume);
static DEFINE_SPINLOCK(state_lock);
enum {
       SUSPEND_REQUESTED = 0x1,
       SUSPENDED = 0x2,
       SUSPEND_REQUESTED_AND_SUSPENDED = SUSPEND_REQUESTED | SUSPENDED,
};
static int state;             // 初始化为0
 
static DECLARE_COMPLETION(fb_drv_ready);
 
void request_suspend_state(suspend_state_t new_state)
{
       unsigned long irqflags;
       int old_sleep;
 
       spin_lock_irqsave(&amp;state_lock, irqflags);
       old_sleep = state &amp; SUSPEND_REQUESTED; </rich_text><rich_text foreground="#969696">// state = 1 or 3</rich_text><rich_text>
</rich_text><rich_text foreground="#969696">// state</rich_text><rich_text>的值会在</rich_text><rich_text foreground="#333399">0-&gt;1-&gt;3-&gt;2-&gt;0</rich_text><rich_text>循环变化，后面分析代码都可以看出这些值代表系统目前处于什么阶段，简单得说就是：正常</rich_text><rich_text foreground="#333399">-&gt;</rich_text><rich_text>准备进</rich_text><rich_text foreground="#969696">early suspend</rich_text><rich_text foreground="#333399">-&gt;</rich_text><rich_text>开始</rich_text><rich_text foreground="#969696">early suspend</rich_text><rich_text>并且对名为</rich_text><rich_text foreground="#969696">mian</rich_text><rich_text>的</rich_text><rich_text foreground="#969696">wakelock</rich_text><rich_text>解锁，如果此时没有其余</rich_text><rich_text foreground="#969696">wakelock</rich_text><rich_text>处于</rich_text><rich_text foreground="#969696">lock</rich_text><rich_text>状态，那么系统就走</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>的休眠唤醒路线让整个系统真正休眠，直到唤醒源发生，然后将处理器和</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>层唤醒。之后</rich_text><rich_text foreground="#969696">android</rich_text><rich_text>层判断本次底层醒来是由于我所定义的唤醒源引起的吗？如果不是，</rich_text><rich_text foreground="#969696">android</rich_text><rich_text>将不予理会，过段时间没有</rich_text><rich_text foreground="#969696">wakelock</rich_text><rich_text>锁，系统会再次走</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>的休眠路线进入休眠。如果是，那么</rich_text><rich_text foreground="#969696">android</rich_text><rich_text>上层就会写一个</rich_text><rich_text foreground="#969696">on</rich_text><rich_text>的指令到</rich_text><rich_text foreground="#969696">state</rich_text><rich_text>接口中，同样是会调用到函数</rich_text><rich_text foreground="#969696">request_suspend_state() </rich_text><rich_text foreground="#333399">-&gt;</rich_text><rich_text foreground="#969696"> </rich_text><rich_text>准备执行</rich_text><rich_text foreground="#969696">late resume </rich_text><rich_text foreground="#333399">-&gt; </rich_text><rich_text>开始执行</rich_text><rich_text foreground="#969696">late resume</rich_text><rich_text>，之后整个系统就这样被唤醒了。
       if (Earlysuspend_debug_mask &amp; DEBUG_USER_STATE) {
              struct timespec ts;        </rich_text><rich_text foreground="#969696">// </rich_text><rich_text>打印出</rich_text><rich_text foreground="#969696">debug</rich_text><rich_text>信息
              struct rtc_time tm;
              getnstimeofday(&amp;ts);
              rtc_time_to_tm(ts.tv_sec, &amp;tm);
              pr_info(&quot;[request_suspend_state]: %s (%d-&gt;%d) at %lld &quot;
                     &quot;(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)/n&quot;,
                     new_state != PM_SUSPEND_ON ? &quot;sleep&quot; : &quot;wakeup&quot;,
                     requested_suspend_state, new_state,
                     ktime_to_ns(ktime_get()),
                     tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
                     tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
       }
</rich_text><rich_text foreground="#969696">// eg: [request_suspend_state]: sleep (0-&gt;3) at 97985478409 (2010-01-03 09:52:59.637902305 UTC)</rich_text><rich_text>，</rich_text><rich_text foreground="#969696"> </rich_text><rich_text>这里对时间的获取和处理，在其他地方可以参考
       </rich_text><rich_text foreground="#969696">// ready to enter earlysuspend</rich_text><rich_text>
       if (!old_sleep &amp;&amp; new_state != PM_SUSPEND_ON) { </rich_text><rich_text foreground="#969696">// susepnd</rich_text><rich_text>会进入这里
              state |= SUSPEND_REQUESTED;    </rich_text><rich_text foreground="#969696">// state = 1</rich_text><rich_text>
              pr_info(&quot;[request_suspend_state]: 
sys_sync_work_queue early_sys_sync_work/n&quot;);
              queue_work(sys_sync_work_queue, &amp;early_sys_sync_work);
              pr_info(&quot;[request_suspend_state]: suspend_work_queue early_suspend_work/n&quot;);
              queue_work(suspend_work_queue, &amp;early_suspend_work);
</rich_text><rich_text foreground="#969696">// </rich_text><rich_text>在</rich_text><rich_text foreground="#969696">wakelocks_init()</rich_text><rich_text>函数</rich_text><rich_text foreground="#969696">(wakelock.c)</rich_text><rich_text>中会创建这两个工作队列和工作者线程来专门负责处理</rich_text><rich_text foreground="#969696">sys_sync</rich_text><rich_text>和</rich_text><rich_text foreground="#969696">early suspend</rich_text><rich_text>的工作。关于工作队列的详情参考我工作队列的文章
       }
       </rich_text><rich_text foreground="#969696">// ready to enter lateresume</rich_text><rich_text>
       else if (old_sleep &amp;&amp; new_state == PM_SUSPEND_ON) {
              state &amp;= ~SUSPEND_REQUESTED; // state = 2
              wake_lock(&amp;main_wake_lock);         // 对main wakelock上锁
              pr_info(&quot;[request_suspend_state]: suspend_work_queue late_resume_work/n&quot; );
              if (queue_work(suspend_work_queue, &amp;late_resume_work)) { 
// 提交late resume的工作项
            //
            //  In order to synchronize the backlight turn on timing,
            //  block the thread and wait for fb driver late_resume()
                  //  callback function is completed
                  //
            wait_for_completion(&amp;fb_drv_ready);      
</rich_text><rich_text foreground="#969696">// </rich_text><rich_text>等待完成量</rich_text><rich_text foreground="#969696">fb_drv_ready</rich_text><rich_text>，他会在</rich_text><rich_text foreground="#969696">late resume</rich_text><rich_text>结束之后完成
        }
       }
       requested_suspend_state = new_state;      
</rich_text><rich_text foreground="#969696">// </rich_text><rich_text>存储本次休眠或者是唤醒的状态，供下次休眠或者唤醒使用
       spin_unlock_irqrestore(&amp;state_lock, irqflags);
}
 
在系统suspend的时候提交的两个工作项会陆续被执行到，那么下面就来看一下执行early suspend的关键函数。
static void early_sys_sync(struct work_struct *work)
{
       wake_lock(&amp;sys_sync_wake_lock);
       printk(&quot;[sys_sync work] start/n&quot;);
       sys_sync();    </rich_text><rich_text foreground="#969696">// </rich_text><rich_text>同步文件系统
       printk(&quot;[sys_sync wrok] done/n&quot;);
       wake_unlock(&amp;sys_sync_wake_lock);
}
 
static void early_suspend(struct work_struct *work)
{
       struct early_suspend *pos;
       unsigned long irqflags;
       int abort = 0;
 
       mutex_lock(&amp;early_suspend_lock);
       spin_lock_irqsave(&amp;state_lock, irqflags);
       if (state == SUSPEND_REQUESTED)
              state |= SUSPENDED; </rich_text><rich_text foreground="#969696">// state = 3</rich_text><rich_text>
       else
              abort = 1;
       spin_unlock_irqrestore(&amp;state_lock, irqflags);
 
       if (abort) {     </rich_text><rich_text foreground="#969696">// suspend </rich_text><rich_text>中止退出
              if (Earlysuspend_debug_mask &amp; DEBUG_SUSPEND)
                     pr_info(&quot;[early_suspend]: abort, state %d/n&quot;, state);
              mutex_unlock(&amp;early_suspend_lock);
              goto abort;
       }
 
       if (Earlysuspend_debug_mask &amp; DEBUG_SUSPEND)
              pr_info(&quot;[early_suspend]: call handlers/n&quot;);
       list_for_each_entry(pos, &amp;early_suspend_handlers, link) {
              if (pos-&gt;suspend != NULL)
                     pos-&gt;suspend(pos);
       }
// 函数register_early_suspend()会将每一个early suspend项以优先级大小注册到链表early_suspend_handlers中，这里就是一次取出，然后执行对应的early suspend回调函数
       mutex_unlock(&amp;early_suspend_lock);
 
       // Remove sys_sync from early_suspend, 
       // and use work queue to complete sys_sync
 
abort:
       spin_lock_irqsave(&amp;state_lock, irqflags);
       if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
       {
              pr_info(&quot;[early_suspend]: wake_unlock(main)/n&quot;);
              wake_unlock(&amp;main_wake_lock);
</rich_text><rich_text foreground="#969696">// main wakelock </rich_text><rich_text>解锁。看到这里，好像系统执行了</rich_text><rich_text foreground="#969696">early suspend</rich_text><rich_text>之后就没有往下执行标准</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>的</rich_text><rich_text foreground="#969696">suspend</rich_text><rich_text>流程了，其实不是，</rich_text><rich_text foreground="#969696">android</rich_text><rich_text>的做法是，不是你执行完了</rich_text><rich_text foreground="#969696">early suspend  </rich_text><rich_text>的回调就可以马上走标准</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>的</rich_text><rich_text foreground="#969696">suspend</rich_text><rich_text>流程，而是会检查还有没有</rich_text><rich_text foreground="#969696">wakelock</rich_text><rich_text>被持有，如果所有</rich_text><rich_text foreground="#969696">wakelock</rich_text><rich_text>全是解锁状态，那么就会执行标准</rich_text><rich_text foreground="#969696">linux</rich_text><rich_text>的</rich_text><rich_text foreground="#969696">suspend</rich_text><rich_text>步骤。
}
       spin_unlock_irqrestore(&amp;state_lock, irqflags);
}
 
static void late_resume(struct work_struct *work)
{
       struct early_suspend *pos;
       unsigned long irqflags;
       int abort = 0;
    int completed = 0;
 
       mutex_lock(&amp;early_suspend_lock);
       spin_lock_irqsave(&amp;state_lock, irqflags);
 
    // return back from suspend
       if (state == SUSPENDED)
              state &amp;= ~SUSPENDED;    </rich_text><rich_text foreground="#969696">// state = 0</rich_text><rich_text>
       else
              abort = 1;
       spin_unlock_irqrestore(&amp;state_lock, irqflags);
 
       if (abort) {
              if (Earlysuspend_debug_mask &amp; DEBUG_SUSPEND)
                     pr_info(&quot;[late_resume]: abort, state %d/n&quot;, state);
              goto abort;
       }
       if (Earlysuspend_debug_mask &amp; DEBUG_SUSPEND)
              pr_info(&quot;[late_resume]: call handlers/n&quot;);
       list_for_each_entry_reverse(pos, &amp;early_suspend_handlers, link)
    {
        if (!completed &amp;&amp; pos-&gt;level &lt; EARLY_SUSPEND_LEVEL_DISABLE_FB) {
            complete(&amp;fb_drv_ready);
            completed = 1;
        }
              if (pos-&gt;resume != NULL)
                     pos-&gt;resume(pos);
    }
// 以和early suspend的逆序执行链表early_suspend_handlers上的late resume回调函数
if (Earlysuspend_debug_mask &amp; DEBUG_SUSPEND)
              pr_info(&quot;[late_resume]: done/n&quot;);
abort:
    if (!completed)
        complete(&amp;fb_drv_ready);   // 设置完成量ok
     mutex_unlock(&amp;early_suspend_lock);
}
 
</rich_text></node><node name="(二)" prog_lang="custom-colors" readonly="False" tags="" unique_id="22"><rich_text scale="h2" weight="heavy">三、kernel层源码解析 - wakelock的重要地位</rich_text><rich_text>
wakelock在android的休眠唤醒机制中扮演着及其重要的角色，主要源码位于文件:kernel/kernel/power/wakelock.c，kernel/include/linux/wakelock.h中。
 
wakelocks_init()函数所做的工作是整个wakelock可以工作起来的基础，所有这里先说说这个函数。
static int __init wakelocks_init(void)
{
       int ret;
       int i;
 
       for (i = 0; i &lt; ARRAY_SIZE(active_wake_locks); i++)
              INIT_LIST_HEAD(&amp;active_wake_locks[i]);
       // 初始化active_wake_locks数组中的两个类型锁链表: WAKE_LOCK_SUSPEND,WAKE_LOCK_IDLE
 
#ifdef CONFIG_WAKELOCK_STAT        // defined
       wake_lock_init(&amp;deleted_wake_locks, WAKE_LOCK_SUSPEND,
                     &quot;deleted_wake_locks&quot;);
       // 初始化wakelock deleted_wake_locks，同时将其加入到非活动锁链表中
#endif
       wake_lock_init(&amp;main_wake_lock, WAKE_LOCK_SUSPEND, &quot;main&quot;);
       wake_lock_init(&amp;sys_sync_wake_lock, WAKE_LOCK_SUSPEND, &quot;sys_sync&quot;);
       wake_lock(&amp;main_wake_lock);
       wake_lock_init(&amp;unknown_wakeup, WAKE_LOCK_SUSPEND, &quot;unknown_wakeups&quot;);
       // 初始化wakelock: main, sys_sync, unknown_wakeups, 同时将其加入到非活动锁链表中
       // 给 main_wake_lock 加锁
       
       ret = platform_device_register(&amp;power_device);
       if (ret) {
              pr_err(&quot;[wakelocks_init]: platform_device_register failed/n&quot;);
              goto err_platform_device_register;
       }
       ret = platform_driver_register(&amp;power_driver);
       if (ret) {
              pr_err(&quot;[wakelocks_init]: platform_driver_register failed/n&quot;);
              goto err_platform_driver_register;
       }
 
       // 新建工作队列和工作者内核线程: sys_sync_work_queue, fs_sync
       //                                                      suspend_work_queue, suspend
       sys_sync_work_queue = create_singlethread_workqueue(&quot;fs_sync&quot;);
       if (sys_sync_work_queue == NULL) {
              pr_err(&quot;[wakelocks_init] fs_sync workqueue create failed/n&quot;);
       }
 
       suspend_work_queue = create_singlethread_workqueue(&quot;suspend&quot;);
       if (suspend_work_queue == NULL) {
              ret = -ENOMEM;
              goto err_suspend_work_queue;
       }
 
#ifdef CONFIG_WAKELOCK_STAT
       proc_create(&quot;wakelocks&quot;, S_IRUGO, NULL, &amp;wakelock_stats_fops);
       // 创建proc接口
#endif
 
       return 0;
 
err_suspend_work_queue:
       platform_driver_unregister(&amp;power_driver);
err_platform_driver_register:
       platform_device_unregister(&amp;power_device);
err_platform_device_register:
       wake_lock_destroy(&amp;unknown_wakeup);
       wake_lock_destroy(&amp;main_wake_lock);
#ifdef CONFIG_WAKELOCK_STAT
       wake_lock_destroy(&amp;deleted_wake_locks);
#endif
       return ret;
}
 
可以看到该初始化函数中新建了几个wakelock: deleted_wake_locks、main_wake_lock、sys_sync_wake_lock、unknown_wakeup，他们全部都是WAKE_LOCK_SUSPEND类型的wakelock，说到这里不得不提到wakelock的两种类型了：
</rich_text><rich_text scale="h3" weight="heavy">1.WAKE_LOCK_SUSPEND – 这种锁如果被某个task持有，那么系统将无法进入休眠。
2.WAKE_LOCK_IDLE – 这种锁不会影响到系统进入休眠，但是如果这种锁被持有，那么系统将无法进入idle空闲模式。</rich_text><rich_text>
 
不过常用的所类型还是WAKE_LOCK_SUSPEND，包括userwakelock.c提供给用户空间的新建wakelock的接口，都是建立的第一种锁。另外系统为了分开管理这两种不同类型的锁，建立了两个链表来统一链接不同类型的锁：active_wake_locks[],这个是具有两个链表头的数组，元素0是挂接WAKE_LOCK_SUSPEND类型的锁，而元素1就是挂接WAKE_LOCK_IDLE类型的wakelock了。
 
       接着上面说，这个初始化函数新建这些锁之后，直接将主锁(main_wake_lock)给上锁了,其余都是非锁状态。新建wakelock使用函数wake_lock_init()，该函数设置锁的名字，类型，最后将新建的锁挂接到一个专门链接这些非锁状态的链表inactive_locks上(新建的wakelock初期都是出于非锁状态的，除非显示调用函数wake_lock来上锁)。接着如果使用函数wake_lock()来给特定的wakelock上锁的话，会将该锁从链表inactive_locks上移动到对应类型的专用链表上active_wake_locks[type]上。
       
       wakelock有两种形式的锁：超时锁和非超时锁，这两种形式的锁都是使用函数wake_lock_init()来初始化，只是在上锁的时候会有一点点差别，超时锁使用函数wake_lock_timeout(),而非超时锁使用函数wake_lock(), 这个两个函数会最终调用到同一个函数wake_lock_internal(),该函数依靠传入的不同参数来选择不同的路径来工作。值得注意的是，非超时锁必须手工解锁，否则系统永远不能进入睡眠。下面是wake_lock_internal()函数的片段：
       if (!(lock-&gt;flags &amp; WAKE_LOCK_ACTIVE)) 
              lock-&gt;flags |= WAKE_LOCK_ACTIVE;// wakelock状态为inactive，则更改为active
       …
       if (has_timeout) { // wake_lock_timeout()会传入1
              if (wakelock_debug_mask &amp; DEBUG_WAKE_LOCK)
                     pr_info(&quot;[wake_lock_internal]: %s, type %d, timeout %ld.%03lu/n&quot;,
                            lock-&gt;name, type, timeout / HZ,
                            (timeout % HZ) * MSEC_PER_SEC / HZ);
              lock-&gt;expires = jiffies + timeout;       // 设置超时时间
              lock-&gt;flags |= WAKE_LOCK_AUTO_EXPIRE;       // 超时锁标志
              list_add_tail(&amp;lock-&gt;link, &amp;active_wake_locks[type]);
       } 
    // acquire a non-timeout wakelock 添加一个非超时锁
       else {      // wake_lock ()会传入0
              if (wakelock_debug_mask &amp; DEBUG_WAKE_LOCK)
                     pr_info(&quot;[wake_lock_internal]: %s, type %d/n&quot;, lock-&gt;name, type);
              lock-&gt;expires = LONG_MAX;    // 设置成超时时间最大值
              lock-&gt;flags &amp;= ~WAKE_LOCK_AUTO_EXPIRE; // 非超时锁标志
              list_add(&amp;lock-&gt;link, &amp;active_wake_locks[type]);
              // 将刚刚设置的非超时锁加到对应类型的活动锁链表中
       }
       
       解锁的时候，这两种形式的锁所使用函数都是一样了：wake_unlock()，该函数中会首先作如下操作：
       lock-&gt;flags &amp;= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
       // 清除锁活动标志和自动超时标志
       list_del(&amp;lock-&gt;link);   // 从锁对应的活动链表上摘除
       list_add(&amp;lock-&gt;link, &amp;inactive_locks);    
// 将unlock的锁挂接到非活动链表inactive_locks上
 
前面已经说了只有类型为WAKE_LOCK_SUSPEND的wakelock被上锁才会阻止系统进入suspend，那么也就是说只要链表active_wake_locks[WAKE_LOCK_SUSPEND]为NULL，那么系统就可以执行suspend的流程了。Android对linux的改造，让其可以在三种情况下进入linux的标准suspend的流程：

</rich_text><rich_text scale="h3" weight="heavy">1. wake_unlock()，</rich_text><rich_text>
    这个应该是最容易想到的，只要系统有对WAKE_LOCK_SUSPEND类型的wakelock解锁的动作，都有可能会进入suspend流程开始休眠，为什么是有可能呢？因为可能还有超时锁没有被超时解锁。下面看一下代码片段：
void wake_unlock(struct wake_lock *lock)
{
       …
       if (type == WAKE_LOCK_SUSPEND) // 貌似只在处理这个类型的wakelock
    {
              long has_lock = has_wake_lock_locked(type);
              // 这个函数蛮重要，它来检查type类型的链表上是否还有锁被上锁了。
        // 其返回值如果是0，说明没有该类型的锁被持有了；返回非0表明就是这个类型的活动链表上还存在超时锁但是没有非超时锁了，这个返回值就是当前时间距离最后超时的锁超时时间的jiffies值；如果返回-1，那表明还有该类型的非超时锁被持有。
        if (wakelock_debug_mask &amp; DEBUG_WAKE_LOCK)
            pr_info(&quot;[wake_unlock]: has_lock = 0x%x/n&quot; , has_lock);        
              if (has_lock &gt; 0) {
                     if (wakelock_debug_mask &amp; DEBUG_EXPIRE)
                            pr_info(&quot;[wake_unlock]: %s, start expire timer, &quot;
                                   &quot;%ld/n&quot;, lock-&gt;name, has_lock);
                     mod_timer(&amp;expire_timer, jiffies + has_lock);
// 修改定时器的超时值并add该定时器
              } 
              else // 已经没有超时锁了
              {
                     if (del_timer(&amp;expire_timer))            // 删除定时器
                            if (wakelock_debug_mask &amp; DEBUG_EXPIRE)
                                   pr_info(&quot;[wake_unlock]: %s, stop expire &quot;
                                          &quot;timer/n&quot;, lock-&gt;name);
                     if (has_lock == 0) 
// !=0,表明还有该类型的非超时锁被持有，现在还不能进入suspend
                     {
                      pr_info(&quot;[wake_unlock]: (%s) suspend_work_queue suspend_work/n&quot; , lock-&gt;name);
                            queue_work(suspend_work_queue, &amp;suspend_work);
                            // 提交suspend的工作项，开始执行标准linux的suspend流程
                     }     
              }
              …
       }
       spin_unlock_irqrestore(&amp;list_lock, irqflags);
}
 
</rich_text><rich_text scale="h3" weight="heavy">2.  超时锁超时之后，定时器的回调函数会执行会查看是否有其他的wakelock, 如果没有, 就在这里让系统进入睡眠。</rich_text><rich_text>
static void expire_wake_locks(unsigned long data)
{
       long has_lock;
       unsigned long irqflags;
       if (debug_mask &amp; DEBUG_EXPIRE)
              pr_info(&quot;expire_wake_locks: start/n&quot;);
       spin_lock_irqsave(&amp;list_lock, irqflags);
       if (debug_mask &amp; DEBUG_SUSPEND)
              print_active_locks(WAKE_LOCK_SUSPEND);
       has_lock = has_wake_lock_locked(WAKE_LOCK_SUSPEND);
       if (debug_mask &amp; DEBUG_EXPIRE)
              pr_info(&quot;expire_wake_locks: done, has_lock %ld/n&quot;, has_lock);
       if (has_lock == 0)
// 如果没有SUSPEND类型的wakelock处于active，那么将调用suspend
              queue_work(suspend_work_queue, &amp;suspend_work);
       spin_unlock_irqrestore(&amp;list_lock, irqflags);
}
       
static DEFINE_TIMER(expire_timer, expire_wake_locks, 0, 0);
列出以下一个重要的函数源码：
static long has_wake_lock_locked(int type)
{
       struct wake_lock *lock, *n;
       long max_timeout = 0;
 
       BUG_ON(type &gt;= WAKE_LOCK_TYPE_COUNT);
       list_for_each_entry_safe(lock, n, &amp;active_wake_locks[type], link) {
              if (lock-&gt;flags &amp; WAKE_LOCK_AUTO_EXPIRE) {
                     long timeout = lock-&gt;expires - jiffies;
                     if (timeout &lt;= 0)
                            expire_wake_lock(lock);
                     else if (timeout &gt; max_timeout)
                            max_timeout = timeout;
              } else
                     return -1;
       }
       return max_timeout;
}
 
</rich_text><rich_text scale="h3" weight="heavy">3. 这个可能有人觉得匪夷所思，就是在wake_lock{_ _timeout}()函数中，调用了内部函数wake_lock_internal()。</rich_text><rich_text>
    这里只有在对超时锁上锁的时候才有可能进入休眠，如果对一个费超时锁上锁的话，那么就没有必要去检查活动链表了。
static void wake_lock_internal(
       struct wake_lock *lock, long timeout, int has_timeout)
{
…
if (type == WAKE_LOCK_SUSPEND) {
              current_event_num++;
#ifdef CONFIG_WAKELOCK_STAT
              if (lock == &amp;main_wake_lock)
                     update_sleep_wait_stats_locked(1);
              else if (!wake_lock_active(&amp;main_wake_lock))
                     update_sleep_wait_stats_locked(0);
#endif
              if (has_timeout)   // 超时锁的时候传进来的是1
                     expire_in = has_wake_lock_locked(type);
                     // 检查当前锁类型链表上是否还有锁处于active的状态，无返回0
              else
                     expire_in = -1; 
// 如果是非超时锁的话，这里直接赋值-1，省去了活动链表检查步骤了
              if (expire_in &gt; 0) {
                     if (debug_mask &amp; DEBUG_EXPIRE)
                            pr_info(&quot;wake_lock: %s, start expire timer, &quot;
                                   &quot;%ld/n&quot;, lock-&gt;name, expire_in);
                     // modify the time wakelock is expired
                     mod_timer(&amp;expire_timer, jiffies + expire_in);
              } else {
                     if (del_timer(&amp;expire_timer))
                            if (debug_mask &amp; DEBUG_EXPIRE)
                                   pr_info(&quot;wake_lock: %s, stop expire timer/n&quot;,
                                          lock-&gt;name);
                     if (expire_in == 0) // 没有锁处于active状态后，准备调用suspend了
                     {
                      pr_info(&quot;[wake_lock]: suspend_work_queue suspend_work/n &quot;);
                            queue_work(suspend_work_queue, &amp;suspend_work);
                     }
              }
       }
       spin_unlock_irqrestore(&amp;list_lock, irqflags);
}
 
下面是suspend的工作项，经过上面三种情况的检查，ok之后将会提交该工作项给工作队列suspend_work_queue，如下：
static void suspend(struct work_struct *work)
{
       int ret;
       int entry_event_num;
 
    // there are still some wakelock
       if (has_wake_lock(WAKE_LOCK_SUSPEND)) {
              if (wakelock_debug_mask &amp; DEBUG_SUSPEND)
                     pr_info(&quot;[suspend]: abort suspend/n&quot;);
              return;
       }
 
       entry_event_num = current_event_num;
       sys_sync();
       if (debug_mask &amp; DEBUG_SUSPEND)
              pr_info(&quot;suspend: enter suspend/n&quot;);
       ret = pm_suspend(requested_suspend_state);
       // requested_suspend_state这个全局变量在函数request_suspend_state()中被设置，也就是执行了eraly suspend或者late resume之后，主要是为suspend保留请求的省电状态。
       if (debug_mask &amp; DEBUG_EXIT_SUSPEND) {
              struct timespec ts;
              struct rtc_time tm;
              getnstimeofday(&amp;ts);
              rtc_time_to_tm(ts.tv_sec, &amp;tm);
              pr_info(&quot;suspend: exit suspend, ret = %d &quot;
                     &quot;(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)/n&quot;, ret,
                     tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
                     tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
       }
       if (current_event_num == entry_event_num) {
              if (debug_mask &amp; DEBUG_SUSPEND)
                     pr_info(&quot;suspend: pm_suspend returned with no event/n&quot;);
              wake_lock_timeout(&amp;unknown_wakeup, HZ / 2);
       }
}
static DECLARE_WORK(suspend_work, suspend);
 
@kernel/kernel/power/suspend.c
int pm_suspend(suspend_state_t state)
{
       if (state &gt; PM_SUSPEND_ON &amp;&amp; state &lt;= PM_SUSPEND_MAX)
              return enter_state(state);
              // 标准linux的suspend流程函数
return -EINVAL;
}
EXPORT_SYMBOL(pm_suspend);
 
Wakelock的机制被文件userwakelock.c中的code封装成了sys的接口sys/power/wake_lock和sys/power/wake_unlock文件，那么上层如果需要新建wakelock或者注销wakelock，或者是解锁wakelock，都是操作这两个sys接口文件。
</rich_text></node><node name="(三)" prog_lang="custom-colors" readonly="False" tags="" unique_id="23"><rich_text scale="h2" weight="heavy">四、android层源码解析</rich_text><rich_text>
    在linux之上经过android的软件堆层层封装,最终在上层的java应用程序中使用。休眠唤醒也是从最上层发出的命令，然后一层一层地将参数解析，往最底层传，最后走上标准linux的休眠唤醒之路。
    这一部分将会初略分析休眠唤醒机制上linux之上所走的路线。
       
    在linux之上，存在一个hal层，专门做和linux内核设备打交道的事情，这里也不例外。休眠唤醒机制的hal层源码位于：

@hardware/libhardware_legacy/power/power.c
该文件源码比较简单，下面列举重点片段：
enum {
    ACQUIRE_PARTIAL_WAKE_LOCK = 0,
    RELEASE_WAKE_LOCK,
    REQUEST_STATE,
    OUR_FD_COUNT
};
const char * const NEW_PATHS[] = {
    &quot;/sys/power/wake_lock&quot;,
    &quot;/sys/power/wake_unlock&quot;,
    &quot;/sys/power/state&quot;
};
static int g_initialized = 0;
static int g_fds[OUR_FD_COUNT];
static const char *off_state = &quot;mem&quot;;
static const char *on_state = &quot;on&quot;;
 
static int  open_file_descriptors(const char * const paths[])
{
    int i;
    for (i=0; i&lt;OUR_FD_COUNT; i++) {
        int fd = open(paths[i], O_RDWR);
        if (fd &lt; 0) {
            fprintf(stderr, &quot;fatal error opening /&quot;%s/&quot;/n&quot;, paths[i]);
            g_error = errno;
            return -1;
        }
        g_fds[i] = fd;
    }
 
    g_error = 0;
    return 0;
}
 
static inline void  initialize_fds(void)
{
    if (g_initialized == 0) {
        if(open_file_descriptors(NEW_PATHS) &lt; 0) {
            open_file_descriptors(OLD_PATHS);
            on_state = &quot;wake&quot;;
            off_state = &quot;standby&quot;;
        }
        g_initialized = 1;
    }
}
 
int  acquire_wake_lock(int lock, const char* id)
{
    initialize_fds();
    if (g_error) return g_error;
    int fd;
 
    if (lock == PARTIAL_WAKE_LOCK) {   // 上层传下来的lock type
        fd = g_fds[ACQUIRE_PARTIAL_WAKE_LOCK];
    }
    else {
        return EINVAL;
    }
 
    return write(fd, id, strlen(id));
}
 
int  release_wake_lock(const char* id)
{
    initialize_fds();
 
//    LOGI(&quot;release_wake_lock id='%s'/n&quot;, id);
 
    if (g_error) return g_error;
 
    ssize_t len = write(g_fds[RELEASE_WAKE_LOCK], id, strlen(id));
    return len &gt;= 0;
}
 
int set_screen_state(int on)
{
    QEMU_FALLBACK(set_screen_state(on));
    LOGI(&quot;*** set_screen_state %d&quot;, on);
 
    initialize_fds();
    if (g_error) return g_error;
 
    char buf[32];
    int len;
    if(on)
        len = sprintf(buf, on_state);
    else
        len = sprintf(buf, off_state);
    len = write(g_fds[REQUEST_STATE], buf, len);
    if(len &lt; 0) {
        LOGE(&quot;Failed setting last user activity: g_error=%d/n&quot;, g_error);
    }
    return 0;
}
 
Hal层的代码在jni层中被使用，源码位于：frameworks/base/core/jni/android_os_Power.cpp，代码片段如下：
static void  acquireWakeLock(JNIEnv *env, jobject clazz, jint lock, jstring idObj)
{
    if (idObj == NULL) {
        throw_NullPointerException(env, &quot;id is null&quot;);
        return ;
    }
 
    const char *id = env-&gt;GetStringUTFChars(idObj, NULL);
 
    acquire_wake_lock(lock, id);
 
    env-&gt;ReleaseStringUTFChars(idObj, id);
}// 对wakelock加锁函数
static void releaseWakeLock(JNIEnv *env, jobject clazz, jstring idObj)
{
    if (idObj == NULL) {
        throw_NullPointerException(env, &quot;id is null&quot;);
        return ;
    }
 
    const char *id = env-&gt;GetStringUTFChars(idObj, NULL);
 
    release_wake_lock(id);
 
    env-&gt;ReleaseStringUTFChars(idObj, id);
 
}// 对wakelock解锁函数
static int setScreenState(JNIEnv *env, jobject clazz, jboolean on)
{
    return set_screen_state(on);
}// 休眠唤醒的函数
 
Jni的方法需要注册到上层才可以使用，同时也需要在上层的对应java类中声明了native才可以使用。那么这里的方法在java中对应的声明在哪里呢？frameworks/base/core/java/android/os/Power.java，该文件定义一个java类，如下：
public class Power
{
    // can't instantiate this class
    private Power()
    {
    }
       
    /**
     * Wake lock that ensures that the CPU is running.  The screen might
     * not be on.
     */
    public static final int PARTIAL_WAKE_LOCK = 1;
       
    /**
     * Wake lock that ensures that the screen is on.
     */
    public static final int FULL_WAKE_LOCK = 2;
       
    public static native void acquireWakeLock(int lock, String id);
    public static native void releaseWakeLock(String id);
       … 
     /**
     * Turn the screen on or off
     *
     * @param on Whether you want the screen on or off
     */
    public static native int setScreenState(boolean on);
       
    …
}
              
       声明的jni接口应该是被java server在使用，这里就是专门的电源管理服务：PowerManagerService使用，具体源码位置在：frameworks/base/services/java/com/android/server/PowerManagerService.java。android在最上层还提供了现场的android.os.PowerManager类
(frameworks/base/core/java/android/os/PowerManager.java)来供app使用，PowerManager类会调用java服务PowerManagerService的方法来完成与wakelock相关的工作。
       
@ frameworks/base/core/java/android/os/PowerManager.java
类PowerManager中内嵌了一个WakeLock类，另外还定义了wakelock的类型，下面是代码片段：
public class PowerManager
{
           private static final String TAG = &quot;PowerManager&quot;;
       …
        /**
     * Wake lock that ensures that the CPU is running.  The screen might
     * not be on.
     */
    public static final int PARTIAL_WAKE_LOCK = WAKE_BIT_CPU_STRONG;
 
    /**
     * Wake lock that ensures that the screen and keyboard are on at
     * full brightness.
     */
    public static final int FULL_WAKE_LOCK = WAKE_BIT_CPU_WEAK | WAKE_BIT_SCREEN_BRIGHT | WAKE_BIT_KEYBOARD_BRIGHT;
       
    /**
     * Wake lock that ensures that the screen is on at full brightness;
     * the keyboard backlight will be allowed to go off.
     */
    public static final int SCREEN_BRIGHT_WAKE_LOCK = WAKE_BIT_CPU_WEAK | WAKE_BIT_SCREEN_BRIGHT;
 
    /**
     * Wake lock that ensures that the screen is on (but may be dimmed);
     * the keyboard backlight will be allowed to go off.
     */
    public static final int SCREEN_DIM_WAKE_LOCK = WAKE_BIT_CPU_WEAK | WAKE_BIT_SCREEN_DIM;
 
    /**
     * Wake lock that turns the screen off when the proximity sensor activates.
     * Since not all devices have proximity sensors, use
     * {@link #getSupportedWakeLockFlags() getSupportedWakeLockFlags()} to determine if
     * this wake lock mode is supported.
     *
     * {@hide}
     */
    public static final int PROXIMITY_SCREEN_OFF_WAKE_LOCK 
        = WAKE_BIT_PROXIMITY_SCREEN_OFF;
       …
    public class WakeLock
    {
       …
        WakeLock(int flags, String tag)
        {
            switch (flags &amp; LOCK_MASK) {
            case PARTIAL_WAKE_LOCK:
            case SCREEN_DIM_WAKE_LOCK:
            case SCREEN_BRIGHT_WAKE_LOCK:
            case FULL_WAKE_LOCK:
            case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
                break;
            default:
                throw new IllegalArgumentException();
            }
 
            mFlags = flags;
            mTag = tag;
            mToken = new Binder();
        }
       public void acquire()
        {
            synchronized (mToken) {
                if (!mRefCounted || mCount++ == 0) {
                    try {
                        mService.acquireWakeLock(mFlags, mToken, mTag);
                    } catch (RemoteException e) {
                    }
                    mHeld = true;
                }
            }
        }
        public void release(int flags)
        {
            synchronized (mToken) {
                if (!mRefCounted || --mCount == 0) {
                    try {
                        mService.releaseWakeLock(mToken, flags);
                    } catch (RemoteException e) {
                    }
                    mHeld = false;
                }
                if (mCount &lt; 0) {
                    throw new RuntimeException(&quot;WakeLock under-locked &quot; + mTag);
                }
            }
        }
    …
    }
    …
    public WakeLock newWakeLock(int flags, String tag)
    {
        if (tag == null) {
            throw new NullPointerException(&quot;tag is 
                null in PowerManager.newWakeLock&quot;);
        }
        return new WakeLock(flags, tag);
    }
    public void goToSleep(long time) 
    {
        try {
            mService.goToSleep(time);
        } catch (RemoteException e) {
        }
    }
    …
    public PowerManager(IPowerManager service, Handler handler)
    {
        mService = service;
        mHandler = handler;
    }
 
    IPowerManager mService;
    Handler mHandler;
}

应用实例：
PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);
PowerManager.WakeLock wl = 
pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;Tag&quot;);
wl.acquire();  //申请锁这个里面会调用PowerManagerService里面acquireWakeLock()
…
wl.release(); //释放锁，显示的释放，如果申请的锁不在此释放系统就不会进入休眠。
 
接下来就会调用到java服务PowerManagerService中：
public void acquireWakeLock(int flags, IBinder lock, String tag) {
        int uid = Binder.getCallingUid();
        if (uid != Process.myUid()) {
          mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WAKE_LOCK, null);
        }
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (mLocks) {
                acquireWakeLockLocked(flags, lock, uid, tag);       // 内部方法
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
}
 
acquireWakeLockLocked(flags, lock, uid, tag)会调用函数power类的方法：
Power.acquireWakeLock(Power.PARTIAL_WAKE_LOCK,PARTIAL_NAME)。
 
public void releaseWakeLock(IBinder lock, int flags) {
        int uid = Binder.getCallingUid();
        if (uid != Process.myUid()) {
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WAKE_LOCK, null);
        }
 
        synchronized (mLocks) {
            releaseWakeLockLocked(lock, flags, false);
        }
}
releaseWakeLockLocked(lock, flags, false)函数会调用power类的方法：
       Power.releaseWakeLock(PARTIAL_NAME);
 
上层休眠唤醒都是调用PowerManagerService类的方法：
goToSleep()
       à goToSleepWithReason()
              à goToSleepLocked()
                     à setPowerState()
                            à setScreenStateLocked()
                                   à Power.setScreenState()
                                          à jni方法
Android层的代码分析得不是很详细，这里只关注框架和流程。下图是网上的一个框架,可以参考一下:
</rich_text><rich_text justification="left"></rich_text><rich_text>
</rich_text><encoded_png char_offset="9735">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N27cCL9JamtrtVptR0cHh8PBSwFzP3z4iFqtwqldWeMui2sEbJwZi68xOjoaExNz7715YInhcDhCoVAsFt9+++0EQQwMUHK5bN26dZAMUSwW33HHHQsWLEAIxcXFQaJupVJJkmRPT8/o6KhWq/3Vr9ZAGp+4uDgul6tUKlNSUlas0HO5XGIC0JRSqbRarRJJSmbmbeAyWxcAACAASURBVGlpaTExMXq9/sKF/qioWVlZWXfddddtt92WlJT0z3/+MzY2Vsjn3EzEyWSyxYsXp6amEgT30qUvSJLUarUpKSk8Hk8iSYmPT4iL4y1cmKFSqdRqNZ/PpyhKr9crFIpLly7x+XwczoIQWrZsGZ/Pb2+3p6WlrVy5cvny5eBjTUpKwhEwt99++9y5SVARjxxNRMzQNH3rrbempaXBr3bw12RnZ4vF4vHx8fnz599yyy0ZGRmXLl1CCN1xxx3Z2dmxsbFz584Vi8VcLlcgECQnJ8+aNUupVIpEoiVLliCEkpKS9Ho90KN58+bdeeedt912G5fLTUtLW7Jkybx58+bPnx8bGyuXy7Ozs2+++WahUCgSiXJycu644w6SJG+6CaWlpRUWFnK5XKFQ+Mtf/jIuLm7FihWZmZmJiYkqlSohIWH+/PlarVar1SQkJNx+++233nqrUqmE4LD58+cnJycvWrQoMTHR5XJlZWXl5eUBx12xYoVOp7t06ZJIJMKBO7/5zW9mzZpF03RSUlJOTo5SqYyOjr506RJJkkwPMosfCpPjov72t7/V19c///zzSUlJ77333h133GGxWOrr69esWbNv376XXnopOzv7L3/5C5fLPXPmTEVFRVpa2vDw8ODg4JIlS2pra6VSaU1NTXl5eSgUOnjw4LJly9ra2j7++GOKot58802n06nX6x955JEzZ85YLJaenh65XP78889XVVU5nc6enp6lS5eKxWKCILq6ut54443Zs2e73e6qqqpZs25+9tntarVaLBbfd999YrH48897q6qOLl26dPbs2QRBfPnll++99x6EQubn5y9dutTn833wwQcURWVlZf3xj3/0+T7/+9//7nK5oqOjf/e7361ataqzs7OkpCQjI2Pfvn1nz561WCxDQyM6XTb8U7/44gu33Xbb3r17uVzuPffck5SUlJaW9oc//OHzzz/Pzc195513jEbjHXfc8Yc//OEvf/nz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3++/devWokWLgsFgd3d3UlIS/pqfn+9ytXZ1dX1/gaipqcnv90ejXo4DpUwEKVI82dbW1oKCgkGnnyLlOA77I5FItFqtsP8sy9rt9oyMDLxQdrtdJBLhNjzP+3y+goICjuNwG9THttvtANDc3IyXjuM4r9fr9/tDoRBeQ4ZheJ7HszMajdgyBcUocZuZDffaFX4hDbk83L6TEjJ8x8lghF5RjBtKpdLlcul0S2a6IxQzD5Zl+/r6RCIRfbjmIpB8eDyerq6un//851VVVQUFBZji84c//OH69euLFy92Op1r165ta2urqanp6+vTarUymUylUr311luvvPIKy7LvvPPO5cuXAUCn0xUVFZWVlVVXV0cikaeeeoplWZvN5na7t27dipYnlmWVSqXdbn/11VfFYvHixYsbGxtxL6VSWVdXV1tb++qrr+r1+oaGhvr6erfbfeXKleLiYoPBEAgE7Ha71WotLCxcuXKlRpP7ySd/AQCZTMbzPCosvvbaa3K5vIRhHFarbvPmL764Ulu7b/fu3RpNEnZVLGaRS0FsArLb7TU1NRieYTAYysvLbTbb4cOHDx48qNfrOY6rqalZv349dvuxxx574YWdTzzxeCgUeumll8rLyzUaDcuyx47VhcPco48+arVaT5061dbWxjDMl19++dRTTx0/fvzo0aN43WQy2caNGwFg165dZrNZp9OR0wfBJEVnK4oRcJuZ3XGUjKDePjKlGxIjcDvhE3XHQUw15Skophp+v18qpSJScxhKpfJnP/tZTk7OpUvWgoICp9P50ksvrV27dteuXT6f76233tJqtRUVFWvWrHn11VfXrl376KOPBoNBv9+v1Wr37t3rcDheeeWVSCRy/vyF6urqwsJCh8Nx/Pjx0tJStC319PQMedzdu3cXFBTs3bu3qamprKzM4/HU19czDHP69OmKiooVK1aYTKbjx49brdb9+/cDAM/zwWBw9+7d69ate+KJJ5qamv74x/84fPjwwoULMeq/paXF6/X+6U9/YhgGfvrTo3V127f/7y+/XHz06NE333zTarWeOHHid7/7HU4ZHMehie7kyZNtbW379+9XKpW7d++uq6szGo1yuRxrr7Es63A40NzV2dkJAC5XB8dxBQUF/f39Bw8e1Gg0+fn5cjkbDnM8zx86dEin0/3+978HgLfeegszpe699979+/ejpVChUFy8eFEkEr3yyisMwxw5cqS+vr6wsFCv10/bHaeY07hzBsAIQZHCNR6PZ/RHFX43xJnWhPbzxF9H0zINvZwU6HQ6nU47072gmBXQ6XQaTe5M94JiPCBGo+zs7O3btzc2nuM4zmazyWSyxx9/nGGYgoKCl19+OT8/HwAkEonP5zMajQzDZGRkyGQyp9PpcDiWLVum1Wr1ev0TTzxuMplOnjyp0Wh+8YtfHDp0CAC0Wm0gEMDQLvLqjkQiMpkMAFpbWx0OR0lJCQC0tLTodLrS0tJoNMpxnFKp1Gq10WiU7KhUKkUikd1uV6vVDMOoVKpAIOD3+5uamtrb29EneO+99/79u2ZMSVkaiQDAzp07/X7/3r17P/744127dqFRkJy+0+m8dOnS5s2bcffnn39+x44dHMd9/vnndTGQjIFPP/30wIEDkUgEfbtqtXrdunWHDh3ied7tdgOAzWbjeX7Pnj0AwPP8r371q/z8fJ/PBwA+n8/r9UokEqVSybJsVlZWJBJRKpW4cXNzs9DEQO0IFCNgwGZ2R3ckfnwQZ3nixmPyowtHJ3KpMRl4R6BrI3g2qfV4TNiyZQst5k2B2LRpEx0McxrV1dVSqTQnJwcAXC5XU1MTmqAw3ovYciKRiEKhcDicFosF11y9elWn0xmNRtKURpPrcFwRiURGo7Gnp2f37t2rVq2SSqXCKQBf7H6//9ixYwDg9/tbWlqMRmNjY2NmZqZGo6mtrTUajRaLRfghje/nSCQilUpZlvV4PBh8dujQIZlMdv369RdeeIHjuG+++ebFfe92d3d7vd4nzeZUfw+bfd/LL7/8zDPPrFu3zmKxoJ0MYp7cUCjU3d2NFYEZhiHxcGq1+saNG2jt6+7uBgC73X7u3LmdO3e2tbU5nU6MnysvL6+urj5+/JTP59NocpuamtCpynFcXV3d5cuXS0rWZGZmfv755+i9ZRhm27ZtHMcZjUaRSETZGMU4MMDMhPQLIxzJSozlJEOKBE4m8h7hn0KmNSTDI3GpQnKGTyMJESU/xTULADzPxzEt0mAciaQYE8hVpYZ3CgIST00xh0CeZbvd3tfX9+2339bU1Fy5cuXo0aNPPvnkm2++SeLf6+rqNBqN2WxGXx4ay+12O8/zSKcaGxtNJhMA8DwfDnNqtRqtRJWVlVVVVbW1tYSsQOwtjY1v2rSpoKCgoaHhww8/LC4uvnDhQmpqKpKhxsZGi8WCG8tkMjJZ4DcAWtR8Pp9er9+5c6dCoQgGg3q9PhQKpaWlvf7665Jg58vlLzTy/BP6Bzwej16vz8nJ2bRpE3ZSyMwAoLe3l+M4/NNutzc3NwNAX19faWlpbm6uz+dra2uTSCTnz19QKBRvvPHG9evXu7u7jUajTCYLhULl5eW//e1veZ5XKBRFRUX19fV4msXFxdeuXfvkk7+sXbu2uLj49ddf12q1OGPabLYvvviCXA2/3485VTTOjGI0GJSbOeRAiaM4IxRpSdxdyPDitsFvNSERJM3iIWAUSQnCbYakZcI/6WMwGpCrhO5pSnApIOHzjGIOgeO45ubm69evI2/YsmXLvn372tvbDQbDBx98sHbt/2Pv7YPaus7E/yfB0QUJLkhCBqkCy8IEFmgSrG1sK2tjT6i9prC7DM2ScZYmbhwyiZuZerytnf7cZJ1k6rit28w2TrZO0zRh7CmTuEy/kLChpJikxnayMt4GEwhGyKCVjCUhuBIvV62b3x9PdXrQC+ZFb5jzGY9H3Jdzzj2vz3nOc56zbXJysqWlpbKy0mAwpKam4uEfAJCZmclxnMfjQVmku7s7Ly+vu7u7tbX19ddf37t3b0lJCc/z27dvb2hoyM7OpiuJIAgul2tmZmZgYGBgYABXHk+cOGEwGJ588kncB9DS0mK1WrVaLQpqZLAQRXFiYgLt0kZHR10u1+jo6OjoKACMjIwIgqBUKrVaQfHA6wAAIABJREFUrSiq5OXln3zyybT5IvelYvjzxNTU1OTkJAmE4ziHw8HzfGFhYW1tbUNDA8/zWVlZTU1NPp9PrVanpKRkZWWpVCqU2Nra2iwWy09+8hPUERw+fLi1tfXatWupqamoBtu/f//atWsrKipaWlqOHDlSW1vr9XrXrFmTkpKSlJT00UcfDQ4Oos1ZcXGxIAjT09Pd3d2Dg4NdXV3FxcVZWVlxqwSM5UZSVlZWe3v7H/7wh56enttvvz01NXVoaOi11177wx/+8O67737yySdSqVQQhN/85jdtbW1m8/CNG39KTU3FbcNvv/12S0uLx+ORyWRkv/H/+3/vtba+azYP83yqXC4/cuTIZ5999vHHH7/33nufffaZUqlE4wMA4DhOJpNxHGc2m//4xz/+5S9/yc7OlslkDofj97///RtvvDE8PKxWq51O53/9139hIO3t7T09PdeuXfN6vXfccYdMJvu///u/t99+++23356eni4oKBAEobe31+VyaTQa3Mns8/mSkpICT/NghAcnl7///e8FQdDpdPFOTtwQRfE3v/nNP/7jP5Iau2L5/e9/73a7SWUg6odbHrfbffbs2X/4h39YjnWA6I0+//zzjRs33nXXXYIgZGdn2+32tLS0bdu2mUymvr4+7JYfeOABURRTU1PdbndFRQUKNwMDA1u3br3rrrusVuvAwMD//M//2O32Xbt2FRUVud3ugoICjUaj0Whuv/12pVK5ZcsWUis4jpNIJOfOnfv8888///zz8fHxffv2/elPf6qtrVWr1QBQUFDQ09OTl5eXmZn5l7/8xeFw3H333ehpQhTFmZmZ6urqzMxMmUx29erVTz75xGq1OhyOwcHBgoKC1NTUgoICj2c4KSm1o6Mjt9hw1113we3JTqdz06ZNq/zgKsqqVasEQTDeW3zFbO3p6RkaGgKAxx9/fPXq1T6f795770UrN6lUum7duqSkpPvvvx+lOo/Hc8cdd0il0nvvvVelUmHl//u///u77rpLo9F88MEHQ0NDn332mc/nq62tTU5Onpyc/PTTTx0Oxx//+Mc1a9YolcrJyclPPvlkYmLixo0bdXV1crmc+OmA4AOmGAyK2/7u7/4OW8uNGzc6Ojp+8pOfNDQ0nDt3rqamdmpKSEpKMhgMuEMY9dUWi+WFF17weDxHjx5Fu+DPPvsUAL71rW/5fL6jR4/K5XK9Xu9yuXA7T3NzMwD8+Mc/3rx587ZtX92wwYA7kIFSfb/55sk9ex45f/68wWAAgFdfffX69eurV68eHx+3WCy7du2yWKw223BDQ0Ntbe3q1au1Wm1LS8uBAwcAAJOhVCpNJpNcLv/Wt7516NChsbGxV155Bbdznzp16uc//zlRlbN5/9yQLHr88ceNxi0PP/xQvFMUNwRB+Ld/+zfcVx/vtMSZw4cPSyQSNGReUZjN5qNHjx44cGC514Fwtrm0Hy8Iv0yBiw8AELDEQS9QWK1Wr9eLGiZ8GJf25tC7h7RUAVyOTJpB37Aoq9Fp43ke/jwhTN3W/t9vvP9B7+HD35bL9fTzqLFTKpUcxzmdTgDIzMykM2EOc+Rw3x7SgAcTRi/XkCyi/wS2YsNYIKukUumjjz6KC4gXLlxALzVFRUX0kNzW1rZhw4YnnnjC4XDs3btXpVK98847uD9FEIT77y9raGhACUyn0+3ZswfNyA4dOtTd3f3EE0+YzeaOjo6amhri0IWEjBtnLJYr3/zmN00mU25ubm9v74ULF1544QVsP2++eTIvLw9NHCwWS21tbWFhYV9fn0ajkUgkDQ0NOp1u7969AFBfX3///fcPDg5mZ2ePjIw0NDTgQOJ2uyHUuiojJLP7x8k4poSRmLDpzXKEttmliw+9ed1UZAlnGkUUP+gztre3d3x8PCMjQyrldTotmguTACGoBw5XkTiOA5ilW/qbfOM/vBzlHgOAVPol+nmU5BobGyUSSUZGBgBotdrS0lKtVhtycn7T+szPPh6AvBJwPSBw1kYYS2EVCjFKpbKrq4vjuD179rz3XltHx+9effVVAEhKSkKbyqtXr7755sl33/0tmmp2dHSgPIQVVKPJtdmG+/v7yc5klUp1zz33oK2ARCJBc1FEFEXaWn9wcHBoaOg///M/v/Od72zZsgUAyPYZAHj44YeIugs3LRN8Pl93d/fevXtx34AgCN/4xje7urrS09PLy8vJtufi4uKY5eatAelfcN2BwaBhQ84yJVjCmPt6sCw1h1yl1Wo5jsvLyyNXaLFsicxa+Fs1y6+eWS4POCITVVb79u3DP4niakGiYQABls3hXg8wmF6QZo7BoFmVk5OjVCpdLtfIyMi3v/1tlUo1NSV8/vnn6H5GrVZj60pJSdm8eZNOpz116lRnZ2dxcXFvby/ueeZ5XqHgLRbf1NQUHbRUyl+/fj24zaPtP6msXV1dADAwMGC32/F/oKqyw+HweDxo9JCcnEy27kskEp/PJ5VK0awSW6PNNmyxWHQ6ndFoTE1N/dnPfmY0Gqenp/GVOXxtMGjCHQbMWLHgGQDxTgVjqYTr/cJt3loQc8thS+x4A8YR8UaySg7k3EyyGRP8Z2pGr7efT5iLk/8YDMLt6enpW7Zsefrpp7/xjW+2tLQIgjA+Pv7II4/U19fX19fj+iMASCQSvV5fVlZmMBjOnj27fv36S5cu4c4XAGhoaJBIJF/72j/jHhwAEAShq+vD1atX8zzv8/lo8Qjfwhf7+vrOnTtXU1Njs9l27tx59uzZgoICnU6HxgEAcOzYMdzh7PF4AADd20xOTvp8vsnJyYKCAvSXg6ui/f39lZWV+KLBYCgoKGhvb8ety8AmLvOG9HEBSkrGigVNAhiMeBHQdYui6HD7/jRtBr8oFvw86+0Zy5dVdrs9NTUVAO6/v6yr68Pjx48DwEsvvWS326enp1NSUtavX+/z+Ww2G57RIYriwYMHJRJJT0/PsWPHAMDtdhcXF+/ZswcAjh07dvDgQbfbjceHff3rXxcEYWRkhPjaCNCcf/jhh2q1Gr3aCILwne98B+8ePXoULclg9nLk6OhoYWGh1+uVSCRyuby6uvqnP/3pkSNHAKC7u/trX/vn4uLiixcvWizWsjLYs2fPoUOHyKYq1lDnCWaUTqdjq5kMABAE4Z577pFKWfNhhCUx571/06WhddoqdsIYY3mQ9N///d/oBYPn+eLi4vT09K1btxqNRp1Ol5WVpVar8/Pz165dy3GyNWty7rzzzvLy8rvuuksul69du/aOO+644447DAZDeXk5z/MKheLuu+/OyMhYs2ZNbm5uXV2dQqEQRVGtVufk5BQVFaG6G1XNgiDIZDKv11tRUYF+k7EJ5efnV1dXY2jXr19/+OGHcVeUXC5PTk4uLS2VyWSrVq3Kzs7Oycn50pe+tHHjxqtXr8rlqu3byw2G0jVr1qSlpX35y8U8z8tkMp7ny8vLJRIJhu9wOGQyWZyzfJnwpS99CW1m452QuMG8ZqB3DDyoR6/XrcB8WNZeM2JJDHxAzFqyTJq58cUq85VL/2f3Ggz6O+7gV61aFfzK3y7engy3J0c7hQxGpLhtYmICLeghjKFA8Lbn+U+PAt61Wq0ffNA5NSVIpTzu+ysvL0fBC10OhgwkwOEFedJqtc6tsiZPMgszxiJgXjNCtvTE1I5EiVvGa8YtwKyK5/ea8fFF+7e//bBcrmfuwRi3Eqv42Q708SrtpQYN9gNem9sneMidPgDAcdzmzZuIzYpMJiNmxWQzZvD2lgCHF+TJYEmOxMs2MC+dlXOKyHyOmpjjsVuYgC1pK+fzAz4WzVtXVA4kICTzRVHkuHQA4Y4UfUrKuN9rBoNx63Dz05nmuB6OcEOaSqUicl5I1zJz7NBeRDpZN7oUOjs78Si9Wz4bw6mFHA6HQqEgk4dbPh/mAB3Q4CnXKyEfyDdi6SuVSlgZH7680NjtF+OdBgYjGoRYm4844QSmqApSrBtdImfPntXr9Xgqw4pCEITu7u4zZ87gNpeXX345PT29pKSkqqpqZWpNBEFA1zalpaUr4fOxlDs7O8+cOTM9Pf3RRx8dO3YsJSUF3VzHO3WMv2FTq6fN5ningsGIPLGQzBjLEbfbzXErcbcEunP78Y9/LJVKx8bG/vd//xcAnnvuuaqqqpUglwTD8/zExER6evrK+XxBEPr7+3/84x8DwMzMzPHjx2dmZnS6deRkOUYc4ZJmiMd/hN4cwGDcAtwe7wQwEg5irqdQrMRBSKVSFRUVbdu2bWxsDK/k5+ej42XGCoHn+erq6pycnJmZGYVCMTMzk5+fv2GDgVhexjuBKxph6rZ4J4HBiC5MMmMEwrQCKpVq586dCoUiOTkZAO699140sWLc8hCpS6VSbd68mVyvq6tjS5kJQoB6jJ1Zwrj1YJIZIyxjYytUNyAIglarTU1NnZmZAYCCggJyPa7pihspKSnxTkLsIIoxo3FLcnIyqk5LSkoAAL0LsakLg8GIKkwyY4RGo9GstNVM2uvKxo0bs7KykpOTc3Nza2tryfX4pS5uCIIgkUhwf+ItD70/6eGHH1q9ejUA3H333Suz6BMcMnXkkmbimxIGI7LETjJDv/+wghUPESE2uScIQm1tbXFxcQyiQz1EIkCPviqVaseOHQBQXFyMXkYTtt4GJCzi6eR5fvv27eXl5ZENdlnwwAMPJCcnGwwGXM6e+9Du+BLZdkRqUUJVe/xGjuMCjjDHY5fYsibjliHqkhkeYQ7siNkIEZs85Hleo9Ho9fqIRyf4IVcSdrTbunWrVCrdtGkT/pmwtRddA9IKv4hHkZ+fv3Kc4GNOYq913333SaXSysrKeCdqLoi8Eo3AA1x/xxfSV+ARf1NTs5KUUNszEyG7GMuXqHvNoMcJq9Xq8/nS0tJYrb0p4eZ/oiiijLtMfWvRaXY4HKIoarVaPGgrLumZY55dVFS0YcOG7du3W61WjuNUKlV804kDT0CCMQNjlqrI1jqSn+SjQn4jTaRG3+AoSMhOp5PneY/Ho1Kp8vPzy8rK8vPzw2mkoi0NzNEP4JGmPM/jM5HtE9DTMmqn6OuR6rrn1m8F5yp+Gl1P8Hd6erogCHTrCNCoxRg6auzfINRxNQzG3Nz2xRdfxCCazs7O1tZWPJdJo9Hgxenp6YDHUlJSgi+uTMJlRXp6utFojMFWwc7Ozry8vCj1KYIgnDx58vr169PT0+np6Xj6TVzqw9y27ZcvXy4uLiZ/xr1yhkytWq2uqKiIau/f2dmZmpoaWbfDgiAcP358YmICP2p6eno++wwiVQQBVYuOmtRJfMDtdsvlcpLIgFfiWD8x6vT0dIvFYjAYqqur5zgxb6EQR7skGZH90nDfFbITAH/1wLspKSl4NkN3d/fMzIzBYCDXSS2KZVMN+BY6MVh57rvvvqqqqpilh3ELECNPs729vWazua6uDm02RXGS42R4qDlNyIsrE/TySnKD5Ex7e7tSqYyBZHbmzBncohiNwHmev3Dhwtq1a++77z673a5Wq8fGhLjUh7m96a5fvx4AxsYEhYK32+2JUz9Jsi2WK+3t7RUVFRDNgx27uroyMjIiK5mJotje3l5eXq7R5IK/qmMOz1Eokcp/EgWJl/xJ0oD/63Ta/v7+gPYIQS00SoTLCoWCJ/bvFovFbDZDRBeyBUGw2Ww6nU6pVKrVagAYGxOmpoSkpKSIhL84L9Z0uSgUvEaTK4qTarXabrfDPCoPCWQxKV4ImDxMlclkunjxIpPMGAsiRpLZ+Pi4Xq/H820ggU12EoqQCwcmk4ncjWo2Dg0NYY8c2bhIUGNjYzU1NVVVVVarNWG1/eQATfq813ilJPgiz/Mmk2loaCjaqZqYmIh4mCqVanp6urq6Gv2EkYqBP8KtmkXjSwPiwthFUcRCF0WxrKwslumZD3RtVCj4s2fP4vJrpMJHS9Pq6uooHXsQMj9DLkSSP0VRRFsOsnxJlsLJei79WMTTPB/orhJ/v/rqqxcuXIhLYhjLl9idzoQqX6fTmZaWBom0Iy8xCbDwIH/qdDr/ZD3qG5HI7DOC3RwJKjk5GX9zHBfHyhDOHoUMzPgnDgYQv3obbICFRtAymWxqagpNo6IXe5T8mdHBiqKIuU1+hCSC+R+u6LGsMRmiKHo8nmBzq2ikJyRz1E9sOPiA2+3GBb5IgUUgkUhEUUR7qchaboUMDTM52JKSvkg+mRQQ+LtHIqJBeHu4qHabRHAUBAEtNHiel0r57Ozs6EXKuCWJ9bmZaWlpKpXKbDZnZmbilQDjXwYSsnsCgImJCaUS11+ilV041eM4Dv2ZRVw5hwFKpVLct0tPlAMkjwhGulBwQNJqtfRIEEddb7gRZXR0VC6X4+/oJW96eloikQSotZYYZoBfhoA6EK70I7gDIKS0QSzrVSoVFj3u/Ih2ehYBMfnneZ7UgQhis9nA/4H4f7x2HdElRYti5AGcpYQrU5qIl1fw/BnTgF2HIAg22/CKctTMiAiRl8xmdax/nhCmbiONGausIAhELIMlN5WAEWvRoc3RTS8oJaTLmM8wM3c4wcnAMQxVWdHrIknIaCcRvfBhdr+fOGIZJgDrKgSVSHD50m9FLz3BF3meT01NFUUxsvqScNBeWCMV2uQksaTkyJoUydU5qsRCc/6mLTHgAUEQli6OhKw5IRMcTvIO2SmBXxYhSU1JSYl43SNbtcDfBd00H4Kn2SF7M5hf90jnSYBwhs2TluaJAj5cGsjdkL3NohUEwc/jFTKjy8jIuHr16oLCZDCi7zVD+re9n9HQJMdmCF+00BB3CWPRaDSaaIuAiUzwpBx/hKzD4YbPkLeWI+np6YlzBkBImWwRGR5szxTZDmr+whbcTKS46euJwDyLYD7pX1BBBMQbUgoMXicNWdwJm7eMlUbkJbNZlXtVesTDDyDiSos5prkhHwjm1mjeW7duzcrKincqEoJFqDxvMYxGY2pqasyiIxl+05yf/5PhXqSb8yJa7oLEr7mjCKd9WYGEVEjflDmWOOgAyWPkYsSt6BiMJRJrO7NoI852ORjuLuOmxMAxRyxZRH2Y//Mhl0hChrDswLU8UhkSwb9xBHOVXjaNXr8h+t2fLjoESHgtbMjkLcKWgyaccjHgN5238ympaOtKGYylEzvJTCKR0FrlSPUvcxuOBHcTiwv/pquZc6vWmES47Ag2Op4DWnOzxNGIMTdz2y1FKorg8OfWjQX3DwHPz6fzCbmaGRzasqhg81/ZRJXVTZ+cO6IAlRgJPMCaLaTl2aKjZjCiR0x1ZgGTG3JxKWEuQuO9lOjmH85yb+2dnZ1ZWVnoa+oWIOQIOrfgHixPB3T09MVwES33aoAaMnIGQNwVZkhw0Sx0VZHcjaqgE2ytGK5iBMtey5Rwk9iADw9ZgnPkCTfnzip6TwBQAl9AAhakBQ/+BAYjZkRLMgvZ38Xe4jLcMtMc3DTNcwcVEOPybdhnzpzR6dbdMpJZOG5amuH+nHsB5RZbIunq6lIqlZE9A2BuwunGwv25iPCD9SUhFzfnmdTgkOf51vLtIubPQuXOhRZuuOYWsmhCVqTFWbYxGFEiwpJZsD6Z3PL5fNHojMIFlSBtLEGSsQhsNhueAbAU0yLa32OCqFvmSbB6g56OBzwcUk8Q3xGX5HxEsj0aZwAEM38joYjM8RZk7bCgfmZBrX4+D9/CcsMS5zDztC3hwmzPhKAxi8FIBG5fysuiH/yNHoBoDbNIufOWSCS0Y7OA1+nrISGepdC/Ijo9J3+SWxiC0+kkE2L0yMz5wdA4jlOpVB6PB2arxOnzPQRBwNNO8AH8jf+TQZr8qVKpyGPko0ik9MWArJtjjAnI3vmWSuRYutcMfBf/t1qtEOoknDlej+BXk/N26GLCWyTD6dKkS9/vRo7j/A4t8Teeh0MKl4QZslgjkn4I1Wo4jvP5fMEZS7zCkhAWHTW6ylx0COHAs5/J56B/Y6AWp0jr5nne5XLRbRxzHmY3Scwl4ocdHw4oPrxIxDL6Cvgrg8fjIRfp8IHqgsiMBVNCuheVH1EUnU6nSqVyuVx43el0kgDJ85zfyZY4W6NDludIG5lb+oy7bMFRkLZAN3D628kV/GqSS5i39DFTpGWRDMH+nHwvHvEJAFgK5Do5ropUG1JAeIu0ZRI+HS+pMOD3sUfXgehkIYPxV1aJCzdOD36F7lP+2mH9eQJ4FelW8KiKm/bsc6SEyEx0h3v+/PmLFy8+++yzANDc3Pzaa6/t37+/tLRUr9efOHGioKCgtLQU25vZbJZIJFqt1mq1fvBB5+bNm5xOZ2ZmJs/zKDFgCElJSRUVFcRpodlsfu655/DTxsbGioqKHnnkkdTUVNJHWK1Wkhg8/xtPayGDCsmT4C8VQ6nWEwfiVXyJ2/GIcEZcltN36fNVlpDY+SbDarU+//zzbrdbKpVi5h88eJAUKJHg8ShPcj4BppzIClhntFqtIAj4g6Ncxot+n5zoOD5S3xUwkIO/LXi9Xpg97aHP+qRd9i+6EHmexzMAIq71DPCNTs9nyHRLq9W++ebJd9/9LQC4XK4tW7Y8+eSTHMcdPnxYp1tXXV2FbZA8bLVa8fAGPGGit7c3Ly8P/Jmg1Wo7Ozu7urqefvppLC+O4/D0IXwFqKwGALoaYFY4HA6Hw9Hc3HzhwoWpqSkAkEqlALB27Vq1Wn3jxo0dO3akpaVhtcGEFRYWYmKww8GiwUjJ9JJUGyK+WK3WhoaG2tpaLsrGcBGBpG1gYODEiRPYYQLApk2bamtr8cPJmR/YVfb19Q0MDFRVVfX19XV2dm7cuBEA+vr6CgsLzWZzWloaqfAQZGeGodlstqampu7ubrlcbrfbKysr6+vrSb+q1+uxe6ELEVt3ZmYm6a6PHz+ekZHxxBNPYHPGUsNunBQijhGkB0vkgmDcGty+iErGUZqnv5I0g53a+GfnRFEEk0m8kQx/noA5F3ro/28K3SxpmcZkMmErunjx4pUrV1pbW7H9t7e3d3V18Tzv8Xj6+vrcbjf2vF6v9/Tpxo8+OofHd1qtVq/Xq9VqtVptR0eH2WymV10BYGxs7J577jl48OCzzz7rdrtffPFFHIlRLUcOR3M6nRg+6uEAAI/moKeP4bJxPllNiNlBH263WxQnF/061gcUWINvYc6QoSuCJzHPkR48zM5ut5eWlu7evbu+vn7Dhg3f/OY3fT4fJsBms2HP6/P5yIE8RLFK5uuCIIyOjprNZqw2OMQKgjA8PMxRe82i/V2YPPQ5hzozrHIkS61Wq9lsBr9UiiLFQmPB4nO73fSfEUQmk4VsCNjKRFHs6+t7993ffu1r//yTn/zkmWeekUgkhw4d4nneZrNNTf21sDDDh4eHyedbrVZRFHt7e48dOzY4OIgy2cDAAGaIxWLBWJxOJ1HFYTmiWgszE7/X5XLxPI8qFpPJhJLT17/+9d27dx84cMBsNtfU1DzzzDO1tbUul+vChQuYV2RE7+vrczgcTqcTAERRNJvNLpcLBQWiicG7WGT4v8lkGh0d7e7uBkqnGNCNBPwZX3EBE8nzvNfrtdvtRqPxhz/84WOPPdbe3v7++++j0DMwMICZiUnt6OhoaGjo6+v78MMPX3vtteHhYQAoLCwkk1vwf6PVasVyIUMGilADAwOnT5/eu3fv97///crKypaWFpPJRPRknZ2dAEAEbqDmwyhjWa1Wj8djNBp37NhB5HubzUZaDXbdnZ2dHMdptVoU8ugGzmBEiaXamf1VYEoCAOAHBkwnfgUGwzAAmgqL+fnYliQSCQoxAcy/NyHabPKnSqUqLi5WKBTnz5+vqqoaGhqqq6vr7+/nOK63txcAjEajIAgNDQ3T09Nut9to3HL//WVNTU1Xrlz57LNPKyq2d3d3d3V1WSwWuVy+f/9+uVx+7dq1hoYGm812zz33PPTQQz6fb3JycseOHXq9HgB27dr1xBNPNDc3FxcXu91uVKcZDIaKiorMzEyTyXTixAmdTufz+dRqdXV1tVarBYAlngccoFfDBaDYgHZmi9OU4Fs/+MEPent7H3vssfz8fKVSiZ0mrf4kAlwk0x0KFKG8Xu/k5GRJSQk66JLJZA0NDRKJpK+vr6Ojo6OjQ6/XP/LII4WFhUeOHKmrq/P5fI2NjRpN7sMPP9TZ2SkIwsaNG0+ePDk+Pj4xMaHX6x988MHh4eGWlpbp6en09PTc3FxauRXZ7wpZi0ZHR4koQC5ardbu7u6WlhYA+P73v4/1cHFiIgar0+kyMjIgElZrtN6UVGZaEUi00QCAKi6XyyWKkzzPl5aWAkBJSQlm7IULF65fvz40NLRt21crKrbbbDaTyfTggw+qVCpUmQuC0N3d3dvbW1pa2t3dfebMGYlEgmIZtsr3338fT87ZuXNnTk5OY2Pjnj17RFFsaGgwGo2lpaVNTc0KBT86Onrq1CmdTjcxMZGSklJXV6fX64uKigBAr9fn5+dnZmaKopiRkfH555+3tbX19/dv2LChqqoK64/NZtNoNI8++mh3d/fZs2fXrFkDADt27MjMzHznnXeuX79++fLl0tJS1C2ZTKa33347PT3d5/Oh3pqe0C6XBbWCgoLCwkKlUolHR2i1WpPJ9PHHH1+9evXatWu7d+8uLS29evWqyWS6cMFkt9svX7788ccf5+bm9vX17d27d926ddgDi6J46NAhANBoNBKJBFsuKaCenh6NRlNUVCSKYn19vVqtlslkWOhnzpyx2WwWi/Xhhx9C1Vp/fz8AbNiwISkpqb6+XqvVNjc3A4DVasXHmpubz54963a7DQbDgw8+iDpLn89ns9l27dqFdY8o4WLQZTFWMrcDAPx5gq5nImUc9tf2/+cJ/Ed6TwIAcEkzwtRtU1P/Z0JOnDCdMJlOnDCZTPyvf8319OBjEolkKbMNnKyQxS8AEAQhLS0tOzvbbrfjLKekpITjuOHhYYvFOjMzU1RU1NTUPDQ0tH///srKyp86JMLDAAAgAElEQVT//Pjg4GB1dTUArFmzZnh4+LnnnlMqlfX19W632+PxiKL48ccfr1+/3mAw/OxnP+vu7k5NTc3JyRkZGXE4HGazuaysbPPmzdh66+rqjEbjvn37GhsbGxoaeJ4/evSoTqczGo1DQ0MtLS0ul0sQBLPZjC15cV9NIL1zeno6HjQebXbt2pWfn78U4yQAcLvdra2te/bs+epXv7p3794TJ0709fXhA7gShBPoGHRzONKnpqYqlcqenp433zx55MiRxsbGO++8U6vV/vSnP7106dKBAwfS09O/+93vms3m/v5+1Fg0Nzd3dPwOAM6cOdPT09Pb23vhwgWj0bhz506TydTZ2Wmz2d566y23263R5IK/pMiqTaTSH7wwiq0pNTVVLpfjQbR9fX1vvnny8ccf/5d/+Zddu3b98pe/vHLlCql7IfWX80EQBKPReO+99y4l/SRqIpbh6h45NxOhpRCtVms2m/Py8srLy0+cOPGDH/zg+PHjAFBVVeV0OnU63dTU1NatW7dt++pbb/3S4/HY7fb29nY0OTKbzRaLVaPR5OTkJCUl2Wy248ePq9Vqo9FoMpl0Op1KpXr55Zc7OjoeeOCB9PT0Y8eOjYyM9Pf3i6I4ODj4yiuvdHV1AUBX14c8z3d1dZlMppKSkvvuu29oaKi9vR3Ld3h42Gq1Tk5Oon5lfHx8dHRUo8mtqal55513BgcHJRLJ+++/L4qiWq0eHBxsaGh44IEHtFrtpUuXLl++LAjC1atXdbp1v/jFL7q7u9vb2wVBOHr0KADU1taioBmbE1EjSGpqqs1mO3bs2OOPP37o0CGr1Yoi7Ntvvz0+Pv6tb30rOzu7tbWV5/n09HS5XK7TaSUSiVwu12q1w8PD3/3ud5955pmf//znly5dOn78uNfr/eijj+Ry+fr16wEAe1qXy3Xu3DkAqK6unpycfPTRRxsaGt5886RGoyksLOzu7j5+/Pj69evr6+s7On534sQJADh9+vTatWt3795dVFSE+Ww2m0+fPs3z/IULF2y2YbPZ3NLSotfrKysrsV03Nzf39/dv3bq1vr7+1KlTnZ2dxBxtEbpnBmNBrHI4HMPDwzabbWzsr13nPAd+fF6h4P80bV4zngIAYDL5b5paTpgAwGQwgMGgrqy0WCwajYZe6wkeZuapVSJabnxFr9fjlKugoKC4uPjixYttbW0TExM1NbUqlWrDBoNCwb/zzjvj4+N33nknAAwMDKxbt66oqKitre0rX/lKdXU1x3EHDhxwu90cx9XV1aG5A8pVPp8PrSU4v7GwKIrp6ekff/zxP/3TP1VXV6tUqmeeeQbbLQDU1tbq9fr+/n6TyaRUKslqBa2fXyL9/f0Wi8VqtY6Pjy89tJBkZGRcv35dp1uHg5PP51u9evXiovv0008BYGpqampqqrW1tampKTc3d/Pmzdu2fRXXNfCxGMxBcXXJbDb39PSgoQkAFBUVPfXUUyaTyW6319TUGgwGuVxusVja29uNRuPZs2fz8/N9Ph/HcSaTaWhoqKampqura2pqqre3NykpyW63nz179r777jMYDPX19QaDgbbTD7eKvThIAwkwD8DFo5MnT166dOmjjz4aGRmZmZkhD/T09Lz66qvXr18HgCWO8RkZGW1tbUsJwefzYRoyMjLGx8czMjKuXLkik8nIAwHqYZx6cRz39NNPG43G3t7eq1evPvfcc9/4xjerq6ssFktpaWlZWVlqqukrX/nKyMjIjRs3wP+Z6enpU1NCbm6uVqs1GAwXLphcLldFRYVWq3300UfHx8cdDscnn3zyzDPPGAyGrKwsi8WCK+zvvfceAKSlpfl8vu7ublEUi4qKent7DQbDxo0bRVE8e/Ysx8lwRSwrKwsrEtbejIyMzZs3V1RsV6lUZ8+etVisOTk5KSkpTz31lMFgOHz4sNVqbWtry8jIsNvtDQ0NGo1m586dgiAcP34c7d8BYGZmZufOnZmZmbt27RJFMeRSQ8KC5iISiUStVut0OgDANeWysrJHHnlkYGDggw86r127NjU1JQhCRkZGenp6aWmpxWLFH++99x6uY/T29trtdlEUBwYGpFJpfX096ibb29tx9dNgMBQVFalUqtdee+3999+/fv36W2/9UqlUvvjiiyh1Xbx40W63T01NmUymLVu2AMDWrVtRdQoAnZ2dOCfMysrCZtXe3g4A5eXlGJFSqTx06NDY2Fh/f7/L5Wpvb5fL5VVVVczCjBEbVvE8j52jQsET4Ww+EAHujhQ9jNsBwLBaA2ACMACY+mGtF4bwARIsmfeHNJiYWzhD4YYYkuNFnucLCgoaGxtxRUOv169fv/706dMcx6GNVEdHx6VLlwwGg1KpHBkZAYDi4uLk5GQ8BNDtdot+e1tU6ZFkoEHSxo0bbTZbaWkpiXFsbKykpKSnpyclJQVNTwRBcLvdFotVLpfjuhIuAhL7FWIbHvC9i27k0V7IQCFsakoIuLIIcNyiZYXh4eGPP/547dq1uJJF7KCXlOJ5QGSmdevWVVZWYmetVCpRs6VQKLA+o+223W6vq6s7ePBgY2NjTU2Nz+c7ceIEx3HFxcVnz56dmZlBwWLTpk0lJSUA4HK50BKfWBYuWkE1B6TcSc1B4UChUIyPj9vtdiKWJScnk7eSkpJWr14NSyhEBF8n0tXSgwK/7TyEd+6lUqmam5utVusTTzxRVlbmcDjee6/t5z8//vDDD5FniGwnlfJSqTQtLQ1zPikpCa9nZWWZTKacnByv14t235cuXVKpVNPT01lZWVhkAGC1Wuvr648ePVpaWnrgwP9nsVw5derU2rVrOY7DoDCRqLTG6ZbX68WsRpMy8l0OhyM9PR0AJBKJUqnERUmbzUb0l6TmvPHGG7h1ICcnBwC6u7uTk5Pz8vJEUVxep9bSBZeSkrJr166ysjLcbtXR8buioqIzZ85MT0+vWbOmoKDAYrGE7MRcLtemTZsAICkpyWAwrF69Oj8/v6SkxO12C4KgVCq3bNnS2Ng4PT193333cRz36quv3nvvvWi8/+STT6LyDADS09NxN0Z5eTnK65jbPM8XFRXV1dW1tLTodDqjcQsAyOVypVJpt9tJMiQSCQ4KycnJeP3f//3f7733XuxDAuxqGIxosIrjuLVr12o0GmL9E9KwlEuawePJaSHjr7b/U7eJoqgaHkalmd10otJgKDAoDDsfhhw1GAxCfr7NNgz+9ZRF722h14mIOXZeXl5OTk5PT8/u3bsBQKPR9PT0lJSUVFdXOxyOCxcucBxXXl7udrtxVuR2u61Wa09PX0lJSXt7u9frxf16lZWV2dnZFosF9Tcmk2n//v0ejyc9Pb2zs7O4uNjn873++us2m62srGxsTHj33d82NzdXVVX19PTI5fLNmzedPt1os9lkMllPTw+mhOzkCvk5izM+W7t2rU63jh6ZooTJZMrKylrKOqzD4ZiYmGhtbQWA7OzsrKysmpoao9GYl5en1WpxNQeFGGJ+Gz3I/gz004bb5fAWz/NjY2M9PT2lpaWjo6NjY2O7d+/W6/VSqfStt946f/58U1PTK6+88vzzz6elpen1+mvXrj399NNWq/X111/HZBN7KVSwEeO5CH5UyKqCexGys7Pr6ur27t1rs9k6Ojreeeednp4e1PWuXr0aNbsAgFsCFxe7yWSSy+W42W2JH0Ub6be2tgbLeWRnHHkYqxBqLGy24S9/+csOh0Mul6Pp2+joKG6L0em0IyMjoigODw+fO3eupqYW7dUGBwfVavXY2NjAwIBGo8GFLYfDceedd3Z0dDz00EOoodm3b19qauq5c+ekUumePXsOHfrwo48+evXVV3nKYQcATExM2O121Jnh7hAUyrGlTE1NofWCxWIpKSnxer0zMzOXL1/W6/VG45a33vplbW1tWloallFPT8/IyMgLL7zA87zJZHK5XNXV1adPn37vvfcqKio6OjrGxsaWy2qm6HdlAgB2ux2bgNfr/eyzTwEgKyurubn52WefLSsrO378OBliZDKZzWYTxUmlUtnd3a3R5Pb39xuNxrKysiNHjuCmjZGRERS+OY7bunXr/v378SwKnucvXbrU0dFx4MABuVzu8/kUCoVarS4oKLh8+TJOvZqamjSa3NHRUVyqLisrww3Ln3766aeffvrLX/5SqVR+8skn6enplZWVhw8fHhkZwX39a9as0el0aB04Ojra1tbW09OXn59Php545TNjhbAKZpuwBP/wM3s/pl9QA+B46YTI8UJ+/l+kPjAZ1AYDGOrRW7gjN5fneZ7jwO84g6f8yvwt6HnvUqTVWuStgoKCqampnJwch8Mhk8mqqqpw0iMIAs7PGhsbUSkNAAaD4c477zx9uvGVV17ZsmXLr371K1R0FRcX9/T0pKen46hQWVmJLVkmk7300ks5OTkY3bFjx3ie37x5k8VypaWlpaWlxW63P/vss3q9/rHHHnvttdcUCsXIyMi6deuI1iSgMQfMt0J+O20QjVfID4lEEhs7s7a2tpKSkqVIZhzHpaen33333bjYl5ubS0sGqC8R/A6oIFRWRHxi6vP5SkpKMDp0m+J0OrHsWlpaXn75ZbfbvWnTpqKiIkEQNmzYgPJNQUFBXl6eWq3mOK6iosJkMj3++OMajQYFspycHK1Wi9UPdYREJ7qUnR8BhAwKP+TatWvgVycXFhZWVVV5vd6mpqbTp08bDAa64i1aOGtra0OLzKXLmvQS9uTkpNvtzszMJHYOot9bFXkyJydn06ZNDQ0NDQ0NX/7ylwFg165dAIB29IIgZGVlSSSS1NTUrKysnJyc559/Xi6XO53OkpJCALjzzjvfeOONgwcPVlZWNjQ0tLS0fP755xs2bFCpVLt37z516hRO3mpqatFWvaKiQi6XcxxXWVl55coVVGUplcqCggIAEEVRr9er1WrU3LvdbrlcnpOTgy0d1WOYeJyYpaamqtXq/Px8h8NRXV1lsVx57rnnsrOze3t70ddPd3d3Q0PDxMQEBsVxXE1NTUNDg8vl6u/vVygUZDcJ0dbAYid10YYk6d57733ppZdOnz49NjamVqt3794tkUjKy8sbGhouXrxos9nGxsY8Hs+OHTsaGho6Ojp27NiBfem+fftstuFTp061traazebt27dnZWXhNgL8ZDRZAwDcwfP973//5ZdfxsaIeYXLka2trb/61a9w2RQDWbduHe4IEQShqKhoy5Ytbrcb94GiDGcwGAwGA0btdrt37txZVFR06NAhnI1rNBqdTgt+xxlxymDGCuK2L774IiIB4QAwNDQEAGvXrgX/fBeb65EjR3w+3759+2Bp3UrIVQ80bkAtCNoS4UQTt+P19vYKglBaWko3Kq/Xi16scBcnNniPx4NOm4jiEDfnj46O4srC5ORkfn4+mdPju6gBcjgc58+fLy4u1uv1R44csVgsL7zwAu3MMNx6zdwfG7D4K4ri66+/Hhud2eOPP44S1eJeF/xetcJtgHjkkUdqampwp1VshhlM0sDAABai2WzGLXV41+VyjY6Ogr9AiWsPdIYHAHq9nuhySKVCB1qkOgXPpyMomYUMrbu7+4033njhhReCMxmTTb5xKS48Dh48mJ6e/vTTTy86hJDcf//9P/zhD/Pz80MqIfAifheqvgRBKC4uxkaKbZn2IIjl1dvbi7Kaz+crLCwknqhEUSQebQBAr9dbrVYscQDIysri/T5sPR4PlrXL5dJoNNgbjI6Ooh2hzWZLTU0lD+MzGIjT6cRI8V2UJ7xeLwkEAEZHR3t6+jZv3oQmdE6n8/Lly9hvEAd4AwMDXq83Ly+PnsfSFYBuMjzPNzc3X7x48cknn4yglxYMs66ujkw2blqTBb8D2NHRUblcLpFIBgcH0RSEdMUoaXGUSzMAQAdmIyMjuMsSAAYHB3NycjBPSPjYG7/44ou7d+/GzME6gBVDo9FgAeFcC4/9Bb/FAkpXJBz0joRXnE4n2jDgRmCLxYqWguhTDTv5rKwsfJg2V5g7N0iOnTx58urVqy+++OLiCoKxMlma1wz0WHYjGfxO+cgxi3Msxkd2GCbyn8PhwJ4XhyJ0C8TzPJo7AOXHGft69EdVVFSECxPBCg/sZQoLC7FNko6AqHmw08F3OY7r6elpaWlBVYrBYCDOJDnKlfmCCFatxUaLHpFlOKIGw9FC8LvSXnryFgcRtbH7FgSBiCw4EqtUKolEkpaWRmqOz+dDEQ1FAeJVWKVSkfEGe2riypKOMRriZoD5PwCgRIhXAgoOXb1AJJySuN1uNJyKKiFVy8RAEC2+ia0PcdLGUX59VSpVXl4ekacdDgfZ+UFaNwrTmCf5+fnByUhLS8MeAyd7Ho8nMzMTy1oURWKlgEHR6m3iSBYoYwZSSfB5nufJujD4ywj/xL2oKpXKYDBg7xRsCJGY2jLw967g322NhUKSih+CgpdIudJFKdbhcOj1ehRVMaNwdkQ8p6D72ebmZrQhRotD8PfJ+KfodykgkUhQMUY6dgDAPlz0e0cjPsY5jiMOaTGo0lIBjQjJJiGgPIeTOhn7HGasKJZwOtOf/3qUHpc0wyXN0GZqpImGfC+y4gUdC7Y3/E2cOGPnCH6/CcRLOOl/seOm1wvoiSm2edG/v1L0H0KAsaAvD+xojEaj0bhFIpHs3LmzoqICADweD4ZGz/wSH1JAuJVhKZCMwgFyiaEtBdJN46waqLEEbcZxJyD4aw74x0syFpL0E08o6M40Eco3QIUccHcpmY+h0QdCLC6ccNB7M2lECqBsTMnoSG6Bv2kTkRpVMkQwJaMsUG7caT00Ea0wZDRFIoM6SvDCbH894NfS4W9y6pfgPwSMCAqYNrozQVUQxmu1WrGakdkC9k7opD5Ya56wEPNf/BONR4luDHtXlUqFv0kTI675iWNn8EvPeAt/kPWQDRs2HDhwgEQq+l0E45NEjYqVhJSO6D+IhfNDbFsxMQJ1rgyZwJPhgHwOUJv0Y5axjJXJEnRmqwLn0POfzy165hfcTwWIU3T7wSaKR9eRdQHSsxONNM7YiM4jWNsXPJXH7gBVdKTZ4x5+fAxbOypgFt2M6VyKy1x5QXt1AwipJFuKEXpEoI/SQ4UK+E3ORerUVNRekPGb81uM0UI5+T1H0USw1OiaALNFsYC5UGQl4IDQoideh8srbG5AHR0hUouztBvngH0D9CkO5C0ibxFpm1RUsphIHhBF0ePx4FIXSQxJKpEJsI3TGhoiGZBY6EjpmkMnQKQOiOSpE8ACxLKEVZsF5BLCU0cbEb0mmSQT1RdmBf0k/QOLvqysDDtYogEl8ZJRgFQSoES0AE0B0bzSmQ/+EidqTiwOesNZ8NDAYESJpZ4B8Df+PMElAdkogMyxLiYGrcvMH1o+C2gqtJKGTHnJ5IkOgT4bkZ5aQagZKkd5YgP/GIC9A5kXknmVz+dD7QtQzj4W9IEhwdinp6eXcmjSfMAxj5hlLI6QnxxHsQzLiCg/OGoRinS+ZFaNwjoZSMAvatMLTCQQ0X/uIT1kcjHZwMX7Xd4Ee72KrBCcnp6OGyEjToCnWQjl6dBqtWKbonVdASt9OIgGaAdxDEbRivPv5iYDM/hVXAE9APmTPkkTZkseIuWOm0gDtC6NpIRWEfHUtlMy3gNVW+hFOpi9ER5iVakWR8g5M/gF6wD9Ey1JE3GHNDfSDDEcko34CjH+A3+hk6NW6LdE/xEjRKwnlYc8SeQ/fIVu/iTwOT6WwYgeS1jNDGBVerAWbZ4SCS30LA5shLRoFaB8xiMOYbZwQCZM2F/jRbp5B/8OGHoFyu+D6LcjyczMJF5Ggzus5cL69etxd9uioaXhYOE4LmBhkaMwgepkafsYWlyzWq2kLpFBhR5WSSUPGDij2n0TwSLcA8H1fCkYjUayLS5KBIsdZDjXarVk/yb9sOg3JADqnFYcTZ1OZ4Cmin4MoV0Bo3hNVFwcx3k8HqIAI2/RKaQv0vWBaOjprwBKRMN4UXRDJS5+CC6JEm0uLvzR+bOU7I02tEqJlJpKpcKCAL/vZaAWfIMDIY4ASe/KUxa6eB0N+Dwej8fjwSu4/ktWkOmc9/l8pF1jpPQcm7R38GvK6ceIzpV+noQc7fxkrHAiJ5kBwOyTnWID6ePI3jTSQdDiEemyyTSUNDPsB0NqrWl1SEDg+CeZH5PJlkgdB0lYXK8a8Bb+mZKSwnGhTXMiS1lZmcFggCWM67RcHnc7M2JfiMM8BKlAAtbCgFoT5/1nhJO6EVBJIFYDZ/CQgDqnkF6vSMEtJecxELKQBJGQ84KhxzyiywRqZkXalEqlos+Yh9lbmMl6boBhGS0uEMtREjttWkSGZGKmhn1LcMMnBFQJInkQFRq9bZZ0Ptgjobk6fiMuoBOhJO7GiwuC7jzxCn5CZmYm2S0h+A+dxK6SzkDRb1uGs2jwi0p0+ECZ8KNnQXotkuwFAaqXRhNS0b9MjG2chE86bfDLzSKlQCUGMISAxDAY0SNyq5kAELS2GO6ZcIOZuBATCvIk6dpokYubreEIji7gYvCPgEBC3g0ZWriQF4RIrbiRKxCrE81xqRci7S6Vhs6WgFWeaERHr2sERxQcaUDtCqgJN60S0ZhVB7canue9Xi/HcSHP8IlIwcVYniYdSECJ0EtOxIoAZtdPIk/TRRwgZ9N9gkBttQuYRdBPBvymkxoQL109hNkmifRHBWheyXW0uyAXaV1scKQwu7ecnp6OeJXDrmZBwYYsNfwieoEiZFdMvp1+kgQSPDemczhcu6PLOrg4At6do4gXBF0u8Z2OMpYvEZbMFgSttCB/LrR/Cdd4lovC+aZ9ChmPFyS2LhHcqZ6amrr0s9jnhvfvl8Q/QwrrUU1AOJaY1YsW0bib2RLRd0m+RdtTfF9fn0QiQTVSZAcbtJOjx138sVza9ULrSZT6t5SUlMh2DljK5JwiskoY7e8NxzzjjfjU6Kbxhuy3CdhC8YwKBmP+RF0yE/3HUNJ/QuQmKOFYdgrnkAkOHrFiRlNT0xLPAJgbURRx7+fcQueyK8cAFpH++bwSSzEdADo6OqRSnizwRRCUKefWX9KstPowTzE94jozQRDcbjeeNAqh9LXzJF7lFbN4AyIKWOVY7tWVES+iLplh1cT+l5/tcDV4qW7F1uPgzw/WmUFs5bP+/n48ryZKC5ocx+ExU1grwmlMl0uVCFc0i14QuenrdL8fcjUzgly9ejVKnmbdbjduZA5Yvo9sft56BKy2RwP04x8wl04EneXcaYhsDVlKXJzf7o3BWCixW830+Xz0AEzMKVa4TIYE2zoE9Ajkz1gqxtHTbLQ7l+ANdMuRaGt8Q4bP83xqamoE4w1H9M4AkMlkAZU/xgv3Cc5NJaHoZVRKSgrOqBdnZxJZAmatNxXcY7OaGc76gt4OMj4+brPZIpIYxsoh6pJZsMYFZbKQrX0Rvcxyn1uHNLaDMOmPZecY1Qykd8JDUFdL/45XOS4uq5ee2jlaBG1xiFdiYGeG7ZecARAl6N6AjGpRjTFSRMpubHHPR1UrgzsAAmpgtL83HOHiDagqMRYf56njj3bzYdx6RF0yIx0HMSiht+csvd0ulx48HMHpD9hCSC7ildjszUSWcgbA3AQ7BJ6/pVFsSCj7mIDRl96z5vV6o5oejCV6mlo8HTx4SS4R6sB8SJCZQ5R2AOAqOSkgstCROCRCeujmGbyxFG1CGIwFEaPVTJ/PZ7PZnE6n2+2OTYy3EjKZzGazTU5Oer1et9sd7TMAhL+dHjMJUbMzc7vdPT09xcXFrEosDplMJpFILBZrjDMwsvWhu7t7dHQUALxeL1mZpX8zwoG5JJfLrVarzWaLuLro2rVrly9fzs/PdzqdIyMjAJCVlRV8ZgMjGLlcjq1SJpPZ7fZYTqcZtwYxkszWr19vMpn+9V//Fa1VZDIZa+GLQyaTLf2g8flgMBjQ02xkxTIc1x0OR2lpaXt7++nTp6NkwBQRLBYLx3Hr1q2bnJycmJjQaDSJVm+np6d37NhBX4mGJK3TrcPtGhCJ+kB8u3/lK1956aWXlpy6lYhMJnM6nSkpKTjqV1VVRbbQs7KyAODw4cNY56enpzMzMzHGCMYyf/B7ASAzMxPTo9VqTSaTz+fbtGkTeuUluYHPxCWd09PTmIyUlBRMs1ar3bZtW1wSw1i+3PbFF1/EJiYh1GnQjIgQjfy0Wq3RdtwvzD7VLnoRLQ5BEL7zne/U19ejhAoJnM4Y7NKIoEkTSXDcT7hf1kS7+QQ4Z06omo9p6+zs7Orq2rt3LwQtKSZIahMw6xjLggifzjQHwV62GYsm2AotUiGTswLJqUThjvVdCgEdVmLWB57nTSYTWu8mcg8bg1ThWZCwNB8N9GlR5KiliCRvZRLcfCLoQSPgcIVEq/mYnv7+fjwZMyB5iZPaBMw6xrIgdpIZI1JEdUbI+U+GoU/yjngs0RhLooFGownpii9xiE2qzGYzVoalVLyQJyAtPW0rmejN0EgBJUgZBezmRm7cuEHvSk6EpIZMJ4OxUGIhmbE6GlmiOgkjgb/33nvd3d0Rjy6gr0/kCaXD4UhOTiZOXBMzqbFJ1fvvv4+VYeksl9JfFgTvCox4+AkyiQqpX9dqtegmM/hWvEjwdQDGciEWklmiTb9uDaKXmRiyyWRCNUlkWS7qfXTsMjMzQ+98TMAKHO0kYfiXLl3q6emJbHQJmJnLmojPoKIa/hKJ2YmxS4SNeozFEXXJjJ7QJFTbXu5ELzNJyElJSVGKIvHB6pqcnJzgdmYhXZ1FPHziKnMpOZCwecgIJsGLCZM3NiZkZGQkclLZqMdYHFGXzILrJZtDJD6CIGg0Go6TreTCcjgcMzMz+DvBu9eABZ3IlpogCJH1lcBEtMgSpUaa+G1fFCevX7+e+OlkMBZKHHYAsB45wcEdBjabTRQnF1pYUe0l5wg8+Nbi1hEC3qK9Ii0otJDpWeiL849xoXvTFvQtPN6MAkkAACAASURBVM9HxFUmM8GJElHKz+VSTMslnQzG/GF7MxmzmOfGT5RgHA4HvRdpQZtG5y85kSdJ4FarNWAPVHC8wesI84mRfkulUq1bt27uF8NdDzbNnqcldTgPUgG+S+YjiYaMiOmrGAwGI8GJ0RkAjOUCGbPvueeegoICABAEwWazSSQSNLb1+XwSiQQlGEEQRFFEp1941+l0+nw+jUaDdwVB8Hq9k5OT+ADuc0xLS0P/WA6Ho6+vD6Mjp/GQs/lEUfR4POA38kUP4GlpaejyFP164AE1+CQmTK/XY6rwCnnd5/PhEY0A4HA4XC4XRkofBMRxnEqlIt/r8/muXLly+fLl4uJi/GSz2Yye0N1ut1wuT0tLE0UR9wqQA2ExBzBMr9eL4YiiiL67rFbr6OhoVlYW3sJ4MXDwbzsgB3vTH8VxHCabFIQgCPiBmZmZPM/j8yh4YeBut1smk5GvxoRJJBJ8ET9Br9djhpC4SDFJJBKtVot309PTNZrcKFU5BoPBYNAwyYwRmh07duCw3dnZ2dLSggO5KIojIyPr1q3btWtXWVkZz/OdnZ2nTp0SRZGIUxzH4V1RFAcHB7u6uiwWC4aJMkdNTU1VVRUA9Pb2njlzxmaz4V2MorKyEu+aTKa2trb+/n4M2W63Jycnb9u2raqqSqvVms3mxsbG7u5uNE632+1qtdpgMDz44IM8z/f19XV0dFy6dInEOzU1he/yPO/xePAuphbvlpaWVldXq1QqURQvXDB1dPwuOzv7448/Pn369OnTp7Ozs+vr6zFDmpqaOzp+BwAcx7ndbqlUmp2d/cADDxgMBp7nu7u7T506hdfxAb1ev3PnzrKyMgAYHBxsbW29du1adnb2tWvXxsbGioqK8K7D4RgcHDx16hTJqKmpKcwQvV7P87zJZHr77bfNZrNUKiXFtG3bV++/v4zneZfL1dTU1N/fTxKG727cuBEzpKmpiWQXYjAYysvL8aMaGxstFguJFwBKS0tra2v1er0oiiUlJRqNhrwYVY96DAaDscKJ3elMjOUFPfoS7RT4dWaoTQEAh8MxPDyMp+whXq9XqVSiiohWxuC7OMAT3ZUoij6fjzwgkUhonRkADA8Po+IHA0dtGZ7qY7Va6ZDxNyqQAMBsNqN0IpFISOJJsvGLUD+EiiKyjomqPtQqHT58eP/+/Xl5eT6fLzMzUxAEFApRK8ZxHH5damoqhkzexZBRa4VKL5KrqPwjIaB0iNlF7mJW0CpGoJSXaWlpqE0EgMzMTPwhiiLmGMkKn89HCgI/mfhmwx/kLlH1kcCDP4pkHYORIJw4ccJutz/77LPxTgiDEWGYzowRGiI84e+AgZmYK6lUKiKEQdB5O+Qu/SJtyDW39sXhcNBnVsJsAykiN0CQ4ZQgCEQYChl78OcE2KfjamlycjIRUMgtDFmYfb4QhjDHJnlcYyXHHIWDluFC2vXj/+HONQp+K9wnB4RMm8EFHJHJdv4zGAxGLGE7ABhzgaJVsC+G4NE6WAgLCa2XgjCm6CQiOsAA2/zF+ckL92Q4GUgqlRJ1IMYYMl6Hw3HTNKAUS/4MaZ7PU2dABQtY4S7O8SH0lXnutwiQ0ubzCoPBYDAiCJPMGDeHFgsW540igLnFqflIWnOopuYZwnwYGxsbHR2lYwwZ8iJO5p6njBh8PUA+XnqMIQnORialMRgMRmxgkhnj5iyjta0Ipg2DkslkkQowIsQm8+fQvTEYcYSeIXCcLNFONGcwIgKTzBiMsKjVauJslvX7DEYcCW6ACgVPNrUAmzwwbiGYZMZghAa3jnq9XvyT9fsMRhyhzQlQShsbm+VuGoKMQRmMZQqTzBiMsIyNjeXk5MQ7FQwGAyDofFiFIvR5X2wSxVjuMMmMwQgN2vWnpaUBm4UzGIkEtke73R5woiuTyRi3BkwyYzBCIwjC5OSky+ViLu8ZjESAuJXB9lhQULBmzZrgpUw2j2Isd5inWQYjNKIobtmyZXJykvZYwUQ0BiOO4HkVer3ebDbn5OTk5eXxPG82m/HQC7wV7zQyGEtlFQSt1LCxh8EAAJVKVVdXR7blM7GMwYg7eLbsvn37nnnmmW3btj3xxBOCIDQ2Nmo0uaI4yXEycj4bg7F8WQXUbhdWoRkrGZyi/PrXv1ar1Xa7HQDq6+sBoLOzs7+/v7q6+tVXX922bVthYSFrLAxGvMC2KZfLf/CDH+zYsSMtLS0jI2NqSpBKeZtteBk1TDz/N96pYCQitwN1NiL4F+nZOj1jhWC1WoFSGzudTpPJdPHiRZfLdfTo0c7OTrxrMpk4jmttbU1NTcX2QsPaC4MRJch4RH4oFAqNRgMATz755NGjR1Uq1fj4OAAoFHxGRkZw80wcHA4H/TlMLGOEY1VfX99Pf/pTt9s9MzMDAJOTkzKZTKFQTE1NxTttDEbUkUqlADA2NrZ///6ysjJRFAEAVzDLy8tPnTpVVFSEbpN4nler1YODg2+88cbU1JRUKsX/OY5zu93x/QoG45YERyUAUKvVP/rRj3iex3NsnU4nAGzfvr2tra25uTkjIyMpKYnn+fHx8XfeeaejoyOeiQ7FzMwMjqr4AwA4jtu3b19hYWG8k8ZIRFY1NTWdOnUKG0BycjJQjYHBWCEkJyfv3LmzrKxMpVKJoqjR5Npsw5WVlQDwi1/8wmg0WiwaMtP94IMPrl27Fu8kMxgrCIVCUVlZuXHjxtHRUY7jfD6fXC6XyWR1dXXPP//8lStXamtrBUHw+XzXr19vamqKd3rDkpycjCOsQqHYtWsXk8wYIVm1Z88en883PT3N5v2MFYhGo7l8+bJUKpVKeYfDwXEc0RaPjQkPP/zQxYsX33jjjYKCAvL8Qw89hI1FLpe73W5RFDmOi9sHMBgrAJ1Od/r0aavVev36dZ1OV1hYeO3atcnJycLCwsrKyl27dn3jG98cGxMkEklJScn+/fsTbTjTaDQ2mw38nQb+YF6sGeFYhRvQ2E5jxsqE2PK/+ebJpqamioqK0tJShYK3WHzoYbyysrKiooLjOHwsNzf3xRdfBLZjhsGILUeOHAGA1atXFxUVAYDRaJTL5QBQVVX1ve99r6SkEAB0Om1ZWdnGjRsT0ISL9Bis62DclKT/+I//SEpK4jhOEARRFAVBkMlk8U4VgxEjsOZzHJecLLl48eKbb74piuJjjz128eLFdevWKRQKpVK5evXq2267bevWrRcvXiwsLMTxgLwY7y9gMFYEmzdvVqvVd911V1FRkSAIKJk5HA632/21r33tjjvuWLdunU6nA4AEHMJoaYx1GoybctsXX3xBe1VmMFYsZrPZ7Xbn5uaqVCrc4YUzb9rJOM/z6Iicbi9sEsxgRBWr1arVaukrIdtgwMGaiQbtJoN1Gow5uO2LL76IdxoYjDgTcnJC+npRFFFWS8AlEgZjRUE3VbPZ7PP5iBE9kXVYU2Usd9jpTIwVDe2KLHgW29fXp1QqsZdnfT2DEUeIxpr8efnyZavVSlooucWaKmO5w040Z6xoaFEsQCzjeb6xsdHj8QDzJctgJB5jY8LVq1fjnQoGI/IwyYyx0uH9BN8ymUw+ny/2SWIwGAGQjY3kT4WCT09PZxoyxq0Hk8wYjJvDbHUZjESAXs3EwznIn3FKEYMReZhkxmCEBc9RQVjXz2AkGkSlzeZOjFsJJpkxGKFxOBzs9FgGIzHB1Uw84pbBuMVgkhmDERr6dHNgk3IGI8HA1UymzGbcejDJjMEIjVarnZmZYZNyBiNxoN0+4w82ZWLcejDJjMEIjSAIk5OT8U4Fg8H4G0QOw9XMkM8wLRpjucMkMwYjEOzZRVGUyWTMawaDkZjY7faJiYng60yLxljuMMmMwQgEe3aO4xQKhc/nC15AYTAYcYfjZCkpKfFOBYMRedjpTAxGaERRxL2Z9AJKXFPEYDAAAMxmM/lttVp9Pp9er49jehiMyMIkMwYjNC6Xa2ZmJt6pYDAYsxAEobGxsbu72+VyTU9PX758Wa/X19fX6/X64KNvGYzlCJPMGIxAHA6HSqXSaDRqtTreaWEwGLPgeX5iYqKpqQn//OSTT3bu3In2oEwsY9waMMmMwZiFIAgul+uVV15ZvXr1Rx99BAA6nc5oNJaWlrJ+n8GIL6gVu++++06ePDk+Pj4zM5OcnLxp06bCwsJ4J43BiBhMMmMwApmcnHzrrbeGh4cBYGBgIDk5+Xvf+15ZWVm808VgxAgUgBJwcRDTs3HjxtLS0tbWVgDIyMjYvn17AiYVEjgbGQkO25vJYMyC5/msrCyDwQAAycnJAJCTk2M0GuOdLgYjdtCSRAJuSVapVAaDAZtnaWlpVlZW4og+gh/wnyOSOGljLBeYZMZgBKLVaktLSwEAdwCUlJTgnwzGCsHhcJDfiSlYrF+/XiqVAsCmTZu0Wm28k/M3eD8AwHEcJKRoy0hwmGTGYITAaDQqFAr8zSzMGCsNlUoFiSqTIaWlpSUlJQqFIqH02SiECYLgcDjYIiZj0TDJjMEIQVlZ2YYNGwAgNzcXrVjinSIGI6YQISPeCQmBIAharba8vHzDhg1FRUXkYnxTBX5Zlud5lUqFv5l8xlgEbAcAgxEag8HQ2tpaXFycn58f77QwGLHGZrPZbDYAcDqdEonE6/VOTk7KZLL4pkoikQDAyMhIXl6eUqksKiryeDwejwe9ZjidTgDw+Xz4GH20WvCVKIG5lJqa6vP53G631+tlm4cYC4VJZgxGaLZu3frWW2/t3LmTTXkZK43Ozs5Tp04BgNvtBgCpVIomU2jSHj0wlmBEUeQ4DmPnOM7tdsvlcrfb7XK5MIX0M3Qg5BX6z6imXxTFsbGx5ORkzDRRFHt7e5944omoxsu4xWCSGYMRmrKysvLy8h07dsQ7IQxGrMGVwcrKSo1GE0s92eTkZMjrqIUaHR3F33iRVoNJJBKfz4evx1exJ5FIUFjEZDQ2Nl66dCmO6WEsR5hkxogDgiD8+te/7urqwukv7rFKNPDQzIMHD5LkTU1NJWBSs7OzX3zxxXingnGrIZfLi4uL8TxK4gMiQKcVrJFSqVRWqxU3Sy7F8AuDoqMGgNzcXHIRH8DjOkhEJIXoRYxOMD4fnCSiRaOVghzHET9k9CsYILnI8zxuYqWTihdJMlavXj09Pb3ofGCsTJhkxogpxB7WbrevXbt2/fr1eH1sLP7WuzdFFCc5LvR0XBRDz/XDPT9HFCHfxesBoSkU/MWLF202GxkLGYxIgYoflG/wCq7NBfvoogUgFErIW7ToRi81CoLAcdwci4wcxzkcDjouDNZqtcJsbxQBwhZGYTab09LSAuRIDDDgIpG0AkQ0FLlIdHRSrVYrvbSKVzCdoijSYiL+TklJmWeeMxgIk8wYMYXsXbLZbJWVlWVlZXP7yA437Y627RedJJKGOSKNVDpvqmYIDtBms8XArpmx0pDL5cEXiYxCi1xECEPhCb15Wa1WnudpgYZ+jBZiiNwW8CQqogBAEASPxwN+V2Eo/OFjqDbDx/B5dFeRmZkJswU+WiCj4xIEwel0pqWlgV9KIwJcgDYOZouY+An0YyS6aFuzMW55mGTGiDXYd7vdbuxnF7c5Pxo75AN0A2RJglxfRKQRTCcZ+YAaJ4qLi1taWiIVBYMRDGkFwTMoWgTB+kmqqM/nC6mLIoIXUPO0gFqN8pbZbJZIJPgWKsCIMIeB0IuJ9PNarZaIa0SEAr+vDTpJZBUSgyKSIukBArKCFi5JMhBaI0hCwLfYaiZjoTDJjBEfpFIp9oNkwhqScHu1Ik7wGBP7NNwUeocawrRljKgSsCkS/AuRREEFALTSCO3MUBgiy5HBLYhuYrgUSIdPizjgl6gwOpvNplQqiWBEi2tk+dJqtfp8PrSQw8Q4HA6UAgOELaJ+C1hdpZnjIlGYEUkxnJaOwVgQTDJjxBr63BIAkEgkIS1zkdjscg93N/arEjfd3h+ggRgdHRVFETepMZ+WjAiSkpKCKijaKB5FHGJZRZRkRDIjDRmvk60AtKosYEmU1pzxPG82m2G2TT34Jare3t7e3t6qqirsMZxOJ1FikZrvdDobGxu3b9+Or2Aympqa1Gp1WVmZx+NJS0sj4hRJA0pmQOnt6JVNmN0wyVoqUdqhKi5gI4Lo38TAYCwUJpkxYg32v3SHOMeSXwzmnXNEQd8KN/uPEnOrGRCe51NTU8k4x3yOM6IBEURQCiHGVeAXuTwej0QiQSEMdVRmszkzMxN/kBXJ4BYUsEBJFi6J4EWCJYLd1atXcXMAPgn+pUzwdyaZmZkaTS6GT8K02+03btwAALQ/I5ZkAbo3lMbIIixu/CTCGXkS21dfXx8KZE6nEzux4O6C7QBgLA4mmTFiTYDcwAU5h4wLwTPjgAfinkIISpUgCF6vN/g6g7F0pqenca0cG6zVah0cHGxtbTWbzcXFxY8++ijHce+8886FCxc4jjMYDNXV1cPDw2+//faaNWtaW1s3bdqk0eR2dPyuoKBg+/bt+fn59MIfRjE8PNzW1tbd3S2VSrdt+2p1ddWbb560WK4MDQ1NTU2Vlpbu2bMHADo7O1taWuRyeUpKitvt9ng8DQ0Nly9flsvlL7zwQmdn5xtvvAEAJCKbbVin03Icd/78+dOnT69du9ZkMlVWVhIVFxEurVbrBx90dnV96Ha7t23bVlVVBQDNzc0tLS2iKBYUFDz99NO9vb1dXV0WiwUANBrN+vXrN27cCABNTU3bt2+Xy+WNjY3nzp1TKBRPPfUUOy+EERHYuZmMxGKOVbyArU+oeCPXyf8hQ8CHyY4wWm8XLpb53ApOAI49JPCAZNPPz/GxASEDZV5NHsDfqampAYEwhRkjsmB74Tju2LFjer3+ueeeGxoaGhwcPH/+fGtr6+7du+vr61taWs6fP+/1ek+ePKnVavfv39/e3v7ZZ58+9dRTFoulra0N/Lsmaev4trY2pVJ5/Phxo9H47ru/xcOg3nrrrW3bvvrcc891d3efP3/eZDK99tprBoPhkUceuXz5Mr74/vvvz8zM7Nq1q7e39+mnn66pqXnmmWcwIpvN1t7ebrFYOzs7X3vttd27d2/duvXKlStqtTrAgk0QhNHR0dOnG43GLQcOHLhw4cLo6KjL5WpoaKisrPzRj34EAEeOHAGAV155RS6XV1ZWrl69+uzZ/7+9u49p6773B/6Z2PWhYA41tkuwbOqauFCH9NZ4bVqqG4eFUiWDXCHaMWWL0kxpIt3eSa26qu3UJWuW30rudEU0Lr0qTdU7RY2atVHuBE20LhNLppKHySVTCIVAXBcsU2KCw8EQju+N8vvjM773xDyUEIJPwvv1R2T8cPyF+OF9Pt+nzyRJ6uzs7O7uJqKDBw+GQqG33367pqamoaGhvb2dN82kyf7fK1eupOx/Du5YqJmBLmjjxbT9hjN1gky9adrj87AYMd2SpiyeOfXppjYjaazM1EepU0bof+PvO7VemPRw1MMgJXicGU2+RD/++GMiWr16dVFR0a9//evR0dFdu3ZVVlZ6vV5Zlp944omWlhafz7d27dqqqqquri6Hw7Fu3Tqfz2ez2UZGRkRXO/d+cpdlbW1tf3//qVOnBgYGwuEwP115eXl1dZUsyxkZGby8Tl5eXnV1tdVqLS8vDwaDsVjsnnvuef755/1+/29/+8HKlSt58Z2NGzc2NjZWVFSYzWZVHfv8816Px8PNe+yxxzo6OrgkxulQ1M/S09NbW/84Pq7s2LHD5XK99dZbly9fJqLDhw9z9jKbzQ8++OCzzz7r8/mOHz9+9OhRVVXb2tqWLVuWm5t78uTJ9PT0P/3puKqO9ff384preqivwx0NyQxSiYd0zJJmVM0Edbpx/STS5CfOTNrFjZIkzZanG7MRTTekbOrlWYiD8EpOSeuPJ0n6fbX3nL2KNpeWACwsrgClpaWlp6eLrGaxWCRJunz5sqjR8sq0vHOGwWAYHx83Go3RaNRgMPCjOLKISQNEdPDgwe7u7mXLlmVnZ69cubK/v398/O/L6CuKwkfo7OyMxWKTJ0KZRJSZmcnrUPCb3WQyJa3UL2RnZ3N1vLCw8N577+UruZ7NA+B8Pt8LL7wQCoU/+eT3R48eramptdnyr169+tlnnxHRqlWrMjJkp/P/1nD2er15eXn79u279957i4uLeT+onJycUKjXYDA8+uij2iXcAOYNvZmgU7P0HtKUiEaT3RMzHY2H8c5e8ZoL8dWS1CTRHjEQeNreUvEQ7dFoSuqa+iz4uIfFl0gk+CUdDodXr17N24dHo9H9+/d/8MEHNpstFApFo9FwOBwKhcrLywsLCycmJhRF4bH5kUhEkqREIpFIJMRaG/x+sdvtXV1dx44dq6mpqaurKy4uPnfunNFoJKKBgQEiUhSFl7r1eDwmk6mnpycYDEYifbFYzGAw8EB+q9WakyP/9a9/DQQCqqp2dna6XK5IJJKRkZGXl3ffffeFQqF4PB6NRrn6pcXJMhAItLW1rV3r/93vfpeenh4K9arq2MqVK+vq6urq6tLS0rglV69e5eMQUWVl5b59+1pbW71er8FgWL58+QMPPLBz586tW7dmZ2c7HA6r1ar9NBCJEGDuUDODO4n4yFOnLDmWlJC096fJ0Vfa8b/SjbuyiMA3Uwlt2giVdB/S7PdHk0WCmR41SycmymOgK/xmKS8v37Nnz8TERF5e3rZt29xud319/Q9+8IPly5cTUWFhIRF5PJ6hoSGaLGVpRz2K9wK/78xmc3l5+VtvvXXo0CG+KT8/v6Ojy+Px8CmW0+mMx+MFBQU+n+/NN9/0+XxffvnlsmXL+vv78/Ly+Jher7e8vLypqYmIBgYG9u7dm5WVtX//fiJ6+umnv/rqK95S9sKFC1u2bNHua8nv09HR0ZGRkTfeeIOIJiYmamtri4qK3nrrre3bt8disYmJib17954/f95utxuNRn5fr1ixYsWKFWVlZTxp9KWXXqqvr9+wYQMR+Xw+g8GQVJsHmIdvXb9+PdVtgKXoueeeq6mp8fv9NK8goh0fJhafTJq4LohymuhJ4YLW5cuXzWYzTelenKl3ddrrteGPl7gkokQiYTabRe/q7KluLrRPrZ3N2tPT09DQsHv3buybCQuI50hu2rSJq1P82rbb7YFAgIhMJlNWVtbo6KjFYmlvb8/NzSWioqKicDgcj8dtNpssy11dXfwW6Orq4mt4L0uaXJmWB5zFYjGTyWSxWCKRCC8Bw9GNj2Cz2YhIVdW+vj6TyWQwGDjq8Vt+dHTU5XKFw+H29na3280lN1mWh4aGxDKziUQiKyurr68vPz+f3zL8WLEcBpf0iEj7hu3r64vH4w6Hg9f+EP2wHDqzsrLUyVk+Vqs1GAz29/fn5ubabDbxESTepB988IEIiABzhJoZ6Mi0ZaSZ8pCIOydOnFi9erXNZpsplhFRc3NzWlpaeXm51WrlU/bR0dHDhw9v2rRJ+0l6sy3UNjUQCDQ1NdlstkgkYjKZsrOzKyoqxPcB3Zio6JsKadPemlQpxDRMuE1ycuRQ6O+XVVWNRqODg4N2uz0/P58mS2h8k8fjEUVifldyL57NZuMHcixrbm7mbDc8rEQifURUXFy8YsUKn8/HS4IVFRXx+mFiyVaz2SzG6ft8Pu12mUVFRfyMvJhtIpHglc94og/HNVmW7XZ7MBiUJIkffvhwc06OPDAwIEmZPKCtrKyMn5eIOGNxFBNvVT6L41Gq4si83AZNbrvucrl4+wHtmeHs2wEDzA7JDFJspp5H7YAtmpxKqR3qKwJWIBDIy8uz2WxJ64Zrj/bYY4/F4/GsrCwxJTORSCSNPkmqS01t6tSBxuL+Vqu1s7Ozt7e3tHR1SUkJEb377ruhUIjn3mufIunpZpp5gIFlkFpiPTMOIj6fj0tH/KLlmCUm3IiFyqTJdcKISGypxO8aUdYtLi7mCxaLhY9psVj4UFx1Kyoq4ofws/BAN9ESzkBcGOODiwt8k6pZH4frW/wop9Pe3d0tSZk5OXJOjizL8tjYmNhLipskKmRcP+PsJYpzfGR+iOgVFdN9tGvl8JWKoqSlpWGlWbhZSGagF9zf4XK5eKVHIrLZbGvWrCkoKOCBIyMjI7FYbOPGjR6PZ3R0tL6+PhKJcH8HEfX09Hz00UfBYLC8vHz9+vVHjhwZGBi4evWqy+X6wQ9+QESdnZ1er1dRlPfee088cOq4NP7kbW5uvnLlSnd3d1nZU+vXVxDRkSOffvHFOSJyuVzbtm3jM3ux7nk4HObOlM2bf8jnysPDyjvvNHLXyb59+9rb21esWFFZWZmZmXn6dGDVKp/NZuNNY6qqqrii8Mwzz3z44YfcYeTz+crLyw0GA7fW6XRWV1fzN9ZMnbYAC4tf0vx6EyvOiAISBxSajGV042gBPoK4Dy9swfcUvZmi8CYmVvPBuXbFKVCEM9EGvt5isWjP1qadVSPOtTgz+f1+XkSDbjzTE1tCiTM3aXKbAc6C3AmbdBIl7klTxrlq73nt2jXsaA43C3MzQRf4A91gMAQCgc8//9zn823cuPH8+fNtbW2Dg4PNzc2hUGjdunUmk+nAgQNWq/XgwYNffvllZWWlwWDo7e2VZbmjo+vYsWNer9fn8x05cuTYsWMlJSVPPvlkS0tLT09PS0tLa2vr0NAQB53KyspIJHLhwgUxG0B8mCqK8qc/HW9tbTWbzWVlT7W1nThy5NPR0dGGhvqHHlr50EMrg8FgIBAQO7Twd4bdbs/NzR0ZGWlubu7p6Tl+/Pgnn/z+wQcfNBqNb7/9digU2rRpk8FgaGhoIKJPPvl9a2srETU1Nb377ruKovAsfV5Xs7KysrKysq2trb+/P5FI7Nu3j4hKS0t5DQJVs+TsLHNRAW4d18yYiETiRajtquMJidrpzyJUiSvF+E6+IElSMBhM6rXnupTL5RoaGuJuRG4DHycpAIm4RkR8wKQTLT53ElFSlOVEnYyfjoOgw7XjgwAAH9FJREFU6JMVS1jzQ+x2OzeVf01ulfbPov37LNzfHpY01MxAF8SpLRGVlJTIspybm2symUKhUGZmpsViKS1dzdMF3n///XA4fPLkyZqa2qqqKrfbzRunjI8rNputtrbW5XI1NTWJvVY+//zzpqYmn88XiUQSicSJEycaGxuLiorcbnddXR1/7ovPeu6h+OKLc16vd9u2bUQUifR98cU5p9Nus9kikT6bLf/ll18mIi7v0WQ84lHAsVhs//79GRkZ/f39DofjN7/5zdDQ0B/+8IfXX3+9qqrK6/X+y7/8y+DgYFlZ2aVLl4aGhrKzs8fGxoaGhmKx2Lp16w4cONDb28vN6O/vb2trKy0t9Xq9r776qsvlEtUy8fWD/ZLhdktKTiLlaG/l4JKVlSVWDRTRjYfnDw8r3JNYWFjo9/vD4bAYpK91+fJlrmRzVOJeRe5GJM3gNiZ29RC38pwePg2rrKxcsWIF93KKPlbejl2MXeNrxCIXfM/Ozs7c3NyioqJgMCgmdHOJjiazHd048kH8vqKrV/tH46U3AG4KkhnoghibQkSff/75+fPnV6xYwaPpxX2i0Whubq4kSfF4PCcnh1eANBgM/GnOn4C8piX/yF8S9913n8FguHbtmqqqY2NjYo3KsbExvqf4pGaSJMVisYceWskPN5vNoVDI4XDs3Lmzqampvb39k09+/8ILL/j9fu0AFJfL1d/f73Q6X331VZ6qxpmvv7//wQcfXLFiBX+fpaenK4ri8XjOnj372muvPfPMM5cuXWpqajKZTA6HQ1XVzMxM3iJw+fLlxcXF/CheDopmXv8MYHEkreQs0pJ2VRrSzE2Jx+N79+41m80ulysYDB48ePDFF1/kUyYtniLQ0tKye/fuzs7O999/f8eOHWIrdB7Qph2hL0aViSFfRNTV1fXjH//YYrHk5eXt3bvX4XDs2LEjKytLdF+KoWN8SsPHpMliHj9XKBTu7u7mBmsfpT0RmqVWnVQ2wwwAmB8kM9AF0b/wpz8dDwQC//Zv/1ZUVLR9+3a+lVOU1Wrt6+uLxWJFRUWSJP35z3/2er39/f3Nzc1r1qzh9cE5DzmdzkAgwKPBPv7449raWr41Ho+vXLnyxIkT27Zt27dvX0dHB2m2aRLjdm02W2vrHzdv/mE0Gj127FhZWVksFvv000/feecdIvJ4PG1tbVzA4yAoTa7KYTab3W43xyb+OikoKBgfH9+/f//OnTuHhoY4fXo8HqfTeeTIkcbGxlOnTm3duvXFF1+0WCyFhYXd3d27d+8mon379tlstszMzJycnMHBQV5QQMQydeYNBgAWishG2m5KraSqmMPh4FmKfKs4F+IzGSJ68803Dx069Pjjj6uq2tzcTERpaWk+n8/n83322WeBQODUqVMdHR1nzpz5y19Obt78w2Aw2NjYaDabV69ebbVaDQZDe3u7oijDw4qqjq1fv54/NLq6ugYHB9va2lauXPnOO+9wkPqP//iPWCzGZbPDhw8PDAysWbOGK3bt7e2hUHh8XHnssccyMzN5GilvylRcXJSZmclpjNf693g83Piurq4TJ05cu3bt6aefFsPgRNWQpttpDWB+kMxAF8SJ79q1/tbWP9bX1xMRr3U0ODi4fPnynByZiOLxuMlkUhRl48aNR48efeWVV0wmk8vlMhqNfAde6bGioqKpqem1116LxWLLly9fv379e++9x/vcVVZWtrS0vPbaa19//bXP5xNje7Vnt5WVlQ0NDdu3b3c6nSaT6emnn04kEu3t7XzADRs2VFdX8xgampw+xjMAMjIyxGAarh/Y7fbvfe+f29pO8NqVmzZtqqqq4hhnMBhGR0dlWS4uLi4tLZVlubq6ur6+/o033uCP+4qKCiIaHx8vKCgQfSXcQowzg5TQpi6+3N7e/tZbb9nt9vLy8oKCAlFh4tIUx522tjYiCoXC58+f53Vq9u3bFwqFHnnkkUAgEAwGeTGO8fFx3gCAiCKRvuPHjx84cMBmsw0MDNTV1W3ZsqWgoOD111+3WCzr1q07ffp0MBisq6uLRqP19fU+n6+iomL79u2vvfbaunXrvF7vc889Zzabu7q6Dh48yDtEHThwgIiMRuOuXbsGBgY2bNhw5cqVUCjEZ1xvvPGG0+nkVhmNRh6QajKZeEio0Wj86KOPeC/RPXv2vPTSS7xMz9TuSy1FUa5du3a7/1Pg7oNkBrogoowsyz/5yU86OrqIaP36ir6+PrfbTUQOh4NLUC+99JIsy36/n+dslpaW5ubmGo3G/Px8t9stSVIkEsnPz//5z3/e3Nz80EMrq6uriGjTpk2JRMJms5nNZpvN9umnnz733HNEJEnS0NAQ5znxrePz+X7961+fOnWKiKqrq7lfo66u7vz580TE41eCwaCYKcaPdbvdW7Zs0c7V4jlo69dXrFrlO306kJMjV1VV8ffWpk2bKioqXC6XxWLZsWMH/3ZGo3H37t2nTp2SZVmscrlp06akPhF0aMLiEKMwxTXaCYnau3EnPncvkqbbfXBwMJFIHDp0qLu7+8KFC1euXOEXc2lpKY+hTEtLCwQCVqvV5XLxSdTFixdPnjxZUVFx5swZVVVfeuklVVVfeeWVUCjscDgSiURNTe3mzT/0eDy7du0KBAKRSCQWi/FW6zt37jx06NCuXbscDkdpaen69et7enrOnz+/a9cum83W2Nh49OjRf/3Xf7169eqGDRtefvnlvr6+N998s6ury2AwqKpaW1vb1NR06dKlwcHB8+fPv/rqqz6f77e//SA3N/fw4cPBYJCn47zyyiunTweqq21iIMTUKZkAtwLJDHRB0izulZ+f7/P5iEhRFI5lvJolJyHuJeQ7v/DCC/zhyA/nNS3FiJBnnnlGPIpH0PNzud1uPn40Go1EIqdPB3jZSSK6cuUKEdXW1losFp7nT0Q8uplTFE+zDwQCZ86cSUtLu3btmvjX5/P5/X4ep68ddsNDjDdvLqLJoc2c2LjSJkkSD1lTVZUHUPv9fv4V+EuuqqpK7PJEk+U9kWIX738IlqSkE4CkRSL4pe5yuXhF5aSkoiiK0Wh0uVxlZWXcb9ja2trY2Pi73/1OUZSWlpYDBw4MDAykp6fzo8bGxviBY2NjmZmZZ8+evXDhwo9+9KOcnJzh4WGeiOPz+dau9QeDQb/f73A44vF4OBxesWJFUVFRV1dXVVWV3+/v6emJRCLvvvsuvzFPnjxZX1+vqurw8HBeXt7g4KDFYnn22Wd5dyaPx3P48GGz2fzAAw/EYjGuip05cyYjI4M37ly71m+320dGRjo6Ol555ZXe3l6HwxGJ9CUtJIuuTFhASGaQYtoKkPgaSBporL0mab8jsRWm+FFMpJc0q3JrD6hdi8hgMBQXF8XjcSIyGo3xeJzH74s585Ikaadl8UA0k8nES9eKYxqNxtzcXHFY7fcZP5D/5UPxQZJKbtpfTdJsISXWkSLNFx56M+F24/VRk0ZQiTX8xOmQoigZGRmkeTOK+3NwuXz5ssfj4XOhnp6ey5cvHz9+fO/evTt27PB6vR988EFra6skSbxVGr/yBwYGuLatqupvfvMbRVEuXrxYUFBw8eLFc+fOibU8ysqeev311x988MGamhoiqq+vN5lMdXV1PHCtpaXlq6++uv/++9euXfvzn/9clmXeSGpwcDAnJycQCLjdbovF8uSTTx46dIiItmzZ4na7v/zyy8LCQrvdfvr0aV7e7OLFi+3t7US0YcOGn/3sZ3wNTU5T1fZmasMZh1RZljE3E+YByQx0KukrYepI26ndeVNHYs1yZMa1NO2zTD311z6Ka2aSJPEANdKkJXECPXUsjvjxG7sgk5qd9GtqL+MEHRYfn/bw65BLv8PDSn9//+joqNjUkjTzaXhudVtbW1tb28jIyNdff7169Wqv12s2m9va2kKhMA8X47Ghx44d4w2Uli9fvm/fvpKSkkgk0tjYSETNzc2vv/662+2+5557eFhCNBpdu9a/Z8//Gx4efvzxx4mosrJy//79b775ptO5PBTq7e3tbWxsNBgMR48e3b9/f3Fx8f79+7/3vX8uLi7q7++XpEx+m3u93r179xIRn5IxHhfxxhtvPPLIIzyFiBe1+fDDD69du/bxxx+/+OKLYjNN8Sj+gyzi/wbctdJ+8YtfpLoNsBT993//N09R5B+142QlSfr2t78trufLfAdx+dvT4TuIy1ra42tvFWlJPJyv1D6dFg/pFUdLqmbxY7WNZ9q28WMlSeIL0/6CWtpfMOm3kGV5YGDgzJkz3/3ud9GzCQvowoULAwMD//iP/8j1sKTXML/aMzMzVVXNzs6yWJb5fF5xbiNe4UT08MMPj4+PT0xMJBKJf/iHf/B6H62pqZYkyeFwdHR0/M//qGvWrHn44ZLr169x12Ra2rf8fn96ujEc7uO5AmfOnHE6nSUlJU899ZTJZLp8+fLatWtlWb527ZrVav3rX/+6du3aRx55JBqNFhYWZmdnDwwMtLcHTCbT5s2bv/Od78RisVWrVl28ePHSpUvFxcUbNlRmZ2enpaUtX+7Kycnh36WwsPD++wsee+w7RDQx8b9PPLHq4Ycf5nLXV1999f3vf7+ysrKwsJCIvvrqK0VRNm/e7PF4RMeuLMuxWIzX5RHvZZaZmRkIBGKxWHl5ear+K+FOhJoZ6MW0RaCp0Weme85illJTUhFr6o/ayDX7kad91NRrpjZeWw6cY7MBUkJbVOaikc1m27y5iMdEavcMuHz58tjYmNvt5uGe2oOEw2G/3+/xeHhsJU0uLbZ161YeXrl58w+JSFEUHjcmulAVRdm6dSsv1RGPx3/1q18NDw+Xl5eLrZaqqqp4ko12C12fz2cymXjLc36ubdu2iSXKeMia3098U3V1FdfFPR6P2MqJf7vHH3+cx4CKv4Cq2fWcMCkHFg6SGejCIiSP2ZNf0o/iQ1aEKmnKBuRa0/aiSjcuFD7LrdMeKunKqU+NrhNYfEljH7nX0m6383JfvFktj6O/9957c3NztSvp80N47otYdIYmR2WJ3kD+d2hoiO8vFvqXZVnMjDEYDMFg8Pnnn+cVy3iuz+joaFZWltiXk0cd8ELQ3IbR0VGx4Sb/CrzZgCg5cywbGhqyWCzqjbuVa3c6F1NwxOKC2iwo4B0K84NkBnqXNMKMNJkmaRQXzS1+TT34HB8y0+C2qZdFY5KuSRrQlhTdvjGezhTmABaHdiiVeCVzVjMajeXl5bw4raTZ4FIkOc4uvAElz7AWF7T7cIiBmzyUkyMRhzmOTYlEgtNYXV2d2LtJO59GJDDxnhL1LTEFh59Iu7OneLiqqrxzAO+qabfbRZsVRenq6uJNR1RVFRPDxfA7DCqABYEdzeFONVO562YPos1PST9+4/2Tnn2W2DT7A2e/Zi7HB1gEovQlxvjT5LowsizzsjLSjYvji5duOByORqO8bYaoRfEFmtx8k3dDIqLBwUGR5KTJPTY4vfGUSVH94qcWz8gNEKvkaMta3BLeK11EKO22m9pmc17kNMZxk4Oa0WgUxxTzhLT7qQPcOiQzWNKm7YVMmg457ZzK2TOc9gtppjg195g107PgBB0WmXhha1//Yhdz7d041tDkq5TTm9Vq5epX0lxmjkcc7LhA5Xa7OQnxdk8cp8TxVVXl7DU0NCRWB+S7cXtEZhLdjqLezKU4UTbjRqqTs01F40dHR4mI2yAey7+FODjfnyOayJQAtw69mZAakiTxKrL0TR150nTdhbMUlm62GTMdPOnLY5be0nk0adrnnfujuDFJ25wDLKCrV69yiBFFspnumTSYUtCu5Kf9d2oBWNJ002dlZSW91zifJTVD240o0hLfTWTHpMEPdOOgAnVyzcKkBnPS0h5KNDJpnUXtj9Jkh6ZY54yIeA4prwwHMHdIZrCotPOYenp6zGZzqls0jaRBYNLkVktT179NuczMTMLMTbgN7rnnntHRUa4DcfrhYV6pbpeuiSqaqJ9duXLl6tWrKW0U3HmQzGBRcSwTn+9iQPFNjehfQDM9r3rjCre6HeA1ODgYi8V02zy4c0UikYMHD5rNZknKHB9XMjJkVR1LdaPuGPxHI6JQKCRWbQSYIyQzSA1JkoaH/z5EN4VDNMQw4anXJ41rockT4hTiVolRz0TkcDh4dz+a0maAeeB3hM1mczqdoVBoZGQkOztb/IuOudnxiiF8mfc/sNlspaWlKW0U3HmQzGCx8Ue/yWSKRPoCgYB290ldSQptuso9ojGdnZ2iZqaf5sGdjreeFD/q6sV/p8AfDeYNyQwWG39aZWdnh0KhpqYm7jcUhZ8ki3mOnjQcJBaLnTt3buXKlbx8USQScTqd2lXOF59oYSwWIyKTyRSLxUwmE8aZwUIRC8NqK8RIGPMgRm6IPQwA5uhb169fT3UbYAkR55HhcHhwcJB3TZEkieeo6wFnL4PBEIvFGhoatmzZ4nA4Ut2oZKKR/CMvcU44TYeFhlcUwOJDzQwWlfiUt9vt4jxSt0sBDQ8POxwOkXv0T5ym49sUFoR4ISVV0WAu8E6E+cFKs5B6+vzwunMXCNDn3xPuaIhl84B3IswPkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAQAAAOgFkhkAAACAXiCZAcwmkUikugkAALCEIJkBAAAA6AWSGcBsDAZDqpsAAABLCJIZwGzQmwkAAIsJyQwAAABAL5DMAGaUnp6O3kwAAFhMSGYAAAAAeoFkBjA9WZZT3QQAAFhykMwApheNRjMyMjADAAAAFtO3rl+/nuo2AOiIoiiRSOS//uu/7rnnnubm5uLi4gceeKCkpKSqqkpRFBTSAADgtvp2qhsAoDtjY2Pvv/8+EQ0PD//tb39LT0//6U9/WlVVlep2AQDA3Q+9mQA3kGU5Pz9/1apVw8PDRJSenp6RkbFmzRrCyDMAALj9kMwA/o+iKIqiWK3WmppaIkpPTyciv9/v9/tT3TQAAFgSkMwAplFcXJSTk0NEExMTXq+Xr1QUJaWNAgCAux+SGSxpSWFL9Ffm5+evW7eOiJYtW1ZdXZ10KwAAwG2CZAZLmghb2ojGHZqFhYUTExNPPPFEUVERqmUAALA4kMwgBaLRaKqbkExENFmW+XJ1dXV6enp5ebluY9nUhum2qQAAMEdYNQNSwGq1ElE4HOYf7Xa7DiOFwWDYuHFjYWEhEcmyrCiKqqqSJN3WJ1VVlYhmeha+VYszrtVq5T8g+lsBAO50WGkWUuM///M/z549S0SxWMxkMi3UYadml280bQzi41y4cMFut3PzZs9MN9ue2bPX3J9FVdUHHnhg586dRISFcAEA7gKomcGiEunh7NmzTqeztLQ01S2ajdFojMfjqW7FDURxkf+MnZ2dra2twWDQ5XIhlgEA3AWQzGBRifQQi8VKS1fzOmHzGHY29/6+Wz+yqqqqqnKX660ff364/3fqTNKCggIuPQqonAEA3NGQzGCxcbzIyMjIyZH5xwUcvLVQh9IOLLNarSI73u7ezJlMG14VRWlvb4/FYhaL5aaOBgAAuoVkBouNQ48kSbIsc+CYR5xaqMQz03G4YZzMOErOr6m3mBS1zROH0o5Fc7vdGRkZ2uH/KJgBANzRkMwgBbh/kCbjxTzmPN7uOZLiWUQ7U9JLKP4+NPlXElmNfxwbG5MkiWPuIrcNAABuByQzSIGkUVPa/JF0ze1OYNrspX3GqY2RZXn29kxb31qoRk57JacxEXMBAOAugGQGS8K02WWm9TLml6sWp4wHAAB3NyQzWLq+MYRp62fcaSgSHnIYAADcDkhmsCRog9T80lVSjJvfwrMAAACzw76ZsETNMVRpu0ExnAsAAG431MxgSbipUKWd//iN90zq8Zz2VgAAgDlCzQyWEB4rRrPulXkrUFQDAIBbhGQGS4VIY+LCLGuAJUW3byx9zb3MBgAAMAv0ZsKSIDoWf/WrX8ViMVVVly1bRkTPPvtsfn4+ESmKYrfbg8EgEblcLiKKRqP8EN6miWMc3y0ajWqvkWWZd9UkIt7YQJKkoaEhbJoEAAA3CzUzWBLsdrssy5FIpLOz0+l01tTUPPnkk0S0Z88emly1NRAIuFwul8sVDoeDwSAvh8sJTAwmk2U5GAzy/UU44zrZ0NCQqqpig0vEMgAAmAfUzGBJ4CrX4OAgERUXF1dVVRGRzWbbvn376OioJEkffvhhIBCw2Wy1tbVGo/EPf/jD008/nZWVdfjw4by8vKqqquPHjyuK4na7BwcH9+/fT0QlJSWPP/54IpFobm6+dOmSwWDYtGkTJzYurYXDYWyaBAAANwU1M1gSrFar3W4vKChIT0/v6Ohobm5ubm4+c+aMzWazWCyNjY2BQKCystJgMNTX1xPR2bNn//KXk0TU1NTU0tJCRG1tbR0dHWNjY++//35JSYnTubylpaWvry8WizU0NEQikXvvvZdrabPPMwAAAJgFamawJHAnYyKRCAaD4XD45MmTRJSenv78888ritLe3l5eXl5VVeX1en/5y18eOXLE6XSGQr19fUVEFIvFgsFgKBTy+Xxnzpzp6OgoK3sqJ0fu7e1taGjYsmVLXl7exo0bvV6veCJJksQwNQAAgLlDMoMlgceEqaqanZ1dXl5eWlpqNBpNJpPL5Tp+/DgRFRYW0mSVKxgMPvvss01NTR999FFNTQ0RNTU1EdHq1asPHz48Pj4eifR98cXI6tWrS0pKuru7MzMzjUYjj/3XrnCGZAYAADcLvZmwJHBISiQSRGSz5fv9fp/PZ7FYFEXxeDwTExPd3d1c7urt7X3yySfdbjcRHTt2rKKiwmbL/+ijjx555BGz2TwyMvJP//RPW7du/dnPfnbffffJslxYWDg0NBSJRLhIJsuy1WoVkwMAAABuCmpmsCSI8lVmZmZOzt9XuxBrjz3//POHDh0aGBiIRCKPPvqo3++XZdlms507d87tdkcikUQi4fF4JEnatm3bnj17/v3f/z07O7u9vb2srKynp8disXi9Xu0SG6qqWq1WzAAAAICb9a3r16+nug2wFD333HM1NTV+v3/RnpEDE1/W9jNKkqQoyuDgYCQSkWW5oKCAp1WKu6mqGo/HDQaDxWKRZbmrq6unp4eI3G63zWbjx/KiaOKw89s0ffbGS5KU9K/Vag0EAg0NDbt377bb7QvyRAAAkFqomcESkrQNAGc1SZLsdrskSbm5uTQ5eJ8HpU19iKIoNpvNbDbT5CpopNn0CRsAAADALUIyg6VCW75KqmkpiiLSFd0YsPiyWFGWk5zVauVeS7Gu7OxPt7AwtwAA4C6GGQCwJMxUzRK1Lu2wM9FjOO39ufdz6gG11yxOcuL9oAAA4G6CmhksCTPtUM4JTFswoxsrakkJTFTLtMcRI9hQygIAgFuEmhksFarG7PfRXpM0V0AsJDvT/ZOOdquNBgCAJQY1M1iikqpc05bBRM1sasaaS3kMJTQAALhZSGawVCSNHuMfRT6b2t0pwhlfo01yU2Pc7VsvAwAAlhQkM0iNacd1Tb3p9j3pNz7RLHee+00Liw8uVvSQZTkejyMCAgDcTZDMIAXEIHreazLp1rmsCnG7h3DN1IDFGTo29dm1tTpxq6Ioubm5qqryrlMAAHAXQDKDxaYoiizL2u4/u91+swtApKpQpJMCVdKkUYPBkMLGAADAAkIyg0UlEpgIFolEgq/ETMa5E3+rsbExmlwIlyNvKpsFAAC3DKtmwKIS0WF4eJgvZGVlzb72BDDtumt8QZblzMxMmsy7iGUAAHcB1MxgsXGASE9P5x+tVms0GtVJL6FuaZOrLMui9Mg1s3g8nppmAQDAQkMygxRQFMXlcnV0dKAb7hZ1dnZKkoRxZgAAdw0kM1hUIoTdf//9R48eDYVC2gVdhXnPzVyo2tvN9q4uTs1PzM0UFwYGBnw+n8vl0t4NSRcA4M71revXr6e6DbBEYUPuW4cEBgBwl0EyAwAAANALzM0EAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9QDIDAAAA0AskMwAAAAC9+P9/pdjXTB4+FAAAAABJRU5ErkJggg==</encoded_png></node></node><node name="suspend过程分析" prog_lang="custom-colors" readonly="False" tags="" unique_id="24"><rich_text> 前面我们分析了休眠的第一个阶段即浅度休眠，现在我们继续看休眠的第二个阶段 — 深度休眠。在深度休眠的过程中系统会首先冻结所有可以冻结的进程，然后依次挂起所有设备的电源，挂起顺序与设备注册的顺序相反，这样保证了设备之间电源的依赖性；直至最后进入省电模式，等待用户或者RTC唤醒；在唤醒过程中则会按照设备注册的顺序依次恢复每个设备的电源进入正常工作状态，解冻相关的进程，然后再进行浅度休眠的唤醒流程。
</rich_text><rich_text scale="h2" weight="heavy"> 1、深度休眠入口</rich_text><rich_text>
 根据wake_lock一节的分析我们知道driver层进入深度休眠的入口有4个，分别为expire_timer、wake_lock、 wake_lock_timeout、wake_unlock，这几个入口函数将根据相应的条件启动suspend_work里面的 pm_suspend()函数进入深度休眠流程，代码在linux/kernel/power/suspend.c中：
 
1. // 进入深度休眠流程  
2. int enter_state(suspend_state_t state)  
3. {  
4.     int error;  
5.     // 判断平台是否支持该状态  
6.     if (!valid_state(state))  
7.         return -ENODEV;  
8.   
9.     if (!mutex_trylock(&amp;pm_mutex))  
10.         return -EBUSY;  
11.     // 同步缓存  
12.     printk(KERN_INFO &quot;PM: Syncing filesystems ... &quot;);  
13.     sys_sync();  
14.     printk(&quot;done.\n&quot;);  
15.   
16.     pr_debug(&quot;PM: Preparing system for %s sleep\n&quot;, pm_states[state]);  
17.     // 做好休眠准备  
18.     error = suspend_prepare();  
19.     if (error)  
20.         goto Unlock;  
21.     // suspend_test  
22.     if (suspend_test(TEST_FREEZER))  
23.         goto Finish;  
24.   
25.     pr_debug(&quot;PM: Entering %s sleep\n&quot;, pm_states[state]);  
26.     // 设备休眠  
27.     error = suspend_devices_and_enter(state);  
28.   
29.  Finish:  
30.     pr_debug(&quot;PM: Finishing wakeup.\n&quot;);  
31.     suspend_finish();  
32.  Unlock:  
33.     mutex_unlock(&amp;pm_mutex);  
34.     return error;  
35. }  
36.   
37. int pm_suspend(suspend_state_t state)  
38. {  
39.     if (state &gt; PM_SUSPEND_ON &amp;&amp; state &lt;= PM_SUSPEND_MAX)  
40.         return enter_state(state);  
41.     return -EINVAL;  
42. }  
43. EXPORT_SYMBOL(pm_suspend);  
 在enter_state()中首先进入状态的判断，根据平台的特性判断是否支持此状态；然后再同步缓存；接着调用suspend_prepare()冻结大部分进程；然后再通过suspend_devices_and_enter()开始挂起设备。
 
</rich_text><rich_text scale="h2" weight="heavy"> 2、冻结进程</rich_text><rich_text>

1. static int suspend_prepare(void)  
2. {  
3.     int error;  
4.   
5.     if (!suspend_ops || !suspend_ops-&gt;enter)  
6.         return -EPERM;  
7.   
8.     pm_prepare_console();  
9.   
10.     // 通知进行休眠准备  
11.     error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);  
12.     if (error)  
13.         goto Finish;  
14.     // 禁止usermodehelper  
15.     error = usermodehelper_disable();  
16.     if (error)  
17.         goto Finish;  
18.     // 冻结所有可以冻结的进程  
19.     error = suspend_freeze_processes();  
20.     if (!error)  
21.         return 0;  
22.   
23.     // 解冻所有进程  
24.     suspend_thaw_processes();  
25.     // 使能usermodehelper  
26.     usermodehelper_enable();  
27.  Finish:  
28.     // 通知休眠结束  
29.     pm_notifier_call_chain(PM_POST_SUSPEND);  
30.     pm_restore_console();  
31.     return error;  
32. }  
 这里有一个notifier机制后面要专门分析下。
 
</rich_text><rich_text scale="h2" weight="heavy"> 3、挂起设备</rich_text><rich_text>
1. int suspend_devices_and_enter(suspend_state_t state)  
2. {  
3.     int error;  
4.   
5.     if (!suspend_ops)  
6.         return -ENOSYS;  
7.     // 处理器的休眠开始函数  
8.     if (suspend_ops-&gt;begin) {  
9.         error = suspend_ops-&gt;begin(state);  
10.         if (error)  
11.             goto Close;  
12.     }  
13.     // 休眠串口  
14.     suspend_console();  
15.     suspend_test_start();  
16.     // 设备休眠  
17.     error = dpm_suspend_start(PMSG_SUSPEND);  
18.     if (error) {  
19.         printk(KERN_ERR &quot;PM: Some devices failed to suspend\n&quot;);  
20.         goto Recover_platform;  
21.     }  
22.     suspend_test_finish(&quot;suspend devices&quot;);  
23.     if (suspend_test(TEST_DEVICES))  
24.         goto Recover_platform;  
25.     // 处理器休眠  
26.     suspend_enter(state);  
27.   
28.  Resume_devices:  
29.     suspend_test_start();  
30.     // 设备唤醒  
31.     dpm_resume_end(PMSG_RESUME);  
32.     suspend_test_finish(&quot;resume devices&quot;);  
33.     // 唤醒串口  
34.     resume_console();  
35.  Close:  
36.     // 处理器的休眠结束函数  
37.     if (suspend_ops-&gt;end)  
38.         suspend_ops-&gt;end();  
39.     return error;  
40.   
41.  Recover_platform:  
42.     if (suspend_ops-&gt;recover)  
43.         suspend_ops-&gt;recover();  
44.     goto Resume_devices;  
45. }  
可以看到设备挂起流程先从处理器自身开始，平台一般不需要做特殊的处理；接着关闭串口，然后调用dpm_suspend_start()开始挂起设备，如果成功挂起所有设备则调用suspend_enter()挂起处理器。挂起设备部分的代码在linux/driver/base/power/main.c中 
1. int dpm_suspend_start(pm_message_t state)  
2. {  
3.     int error;  
4.   
5.     might_sleep();  
6.     error = dpm_prepare(state);  
7.     if (!error)  
8.         error = dpm_suspend(state);  
9.     return error;  
10. }  
11. EXPORT_SYMBOL_GPL(dpm_suspend_start);  
挂起设备分为2个步骤，首先执行设备的prepare函数，然后再执行suspend函数。
1. // 函数将会调用所有的非sysdev设备的prepare()接口  
2. static int dpm_prepare(pm_message_t state)  
3. {  
4.     struct list_head list;  
5.     int error = 0;  
6.   
7.     INIT_LIST_HEAD(&amp;list);  
8.     mutex_lock(&amp;dpm_list_mtx);  
9.     transition_started = true;  
10.     // 遍历设备链表  
11.     while (!list_empty(&amp;dpm_list)) {  
12.         // 从最先初始化的节点开始遍历  
13.         struct device *dev = to_device(dpm_list.next);  
14.         // 获取设备  
15.         get_device(dev);  
16.         // 更新设备状态  
17.         dev-&gt;power.status = DPM_PREPARING;  
18.         mutex_unlock(&amp;dpm_list_mtx);  
19.   
20.         pm_runtime_get_noresume(dev);  
21.         // 在系统休眠期间有可能受到唤醒请求  
22.         if (pm_runtime_barrier(dev) &amp;&amp; device_may_wakeup(dev)) {  
23.             /* Wake-up requested during system sleep transition. */  
24.             pm_runtime_put_noidle(dev);  
25.             error = -EBUSY;  
26.         } else {  // 执行prepare()函数  
27.             error = device_prepare(dev, state);  
28.         }  
29.   
30.         mutex_lock(&amp;dpm_list_mtx);  
31.         // 如果出错则跳出循环  
32.         if (error) {  
33.             dev-&gt;power.status = DPM_ON;  
34.             if (error == -EAGAIN) {  
35.                 put_device(dev);  
36.                 error = 0;  
37.                 continue;  
38.             }  
39.             printk(KERN_ERR &quot;PM: Failed to prepare device %s &quot;  
40.                 &quot;for power transition: error %d\n&quot;,  
41.                 kobject_name(&amp;dev-&gt;kobj), error);  
42.             put_device(dev);  
43.             break;  
44.         }  
45.         // 更新状态  
46.         dev-&gt;power.status = DPM_SUSPENDING;  
47.         if (!list_empty(&amp;dev-&gt;power.entry))  
48.             // 将设备节点移动到list链表中  
49.             list_move_tail(&amp;dev-&gt;power.entry, &amp;list);  
50.         put_device(dev);  
51.     }  
52.     // 拼接链表  
53.     list_splice(&amp;list, &amp;dpm_list);  
54.     mutex_unlock(&amp;dpm_list_mtx);  
55.     return error;  
56. }  
可以看到函数将遍历dpm_list链表，并执行每个设备的prepare函数，内核规定prepare函数的实现不能改变硬件的状态；系统中每一个设备注册时都将被加入dpm_list链表的尾部，所以链表排序为设备注册的顺序。
1. static int dpm_suspend(pm_message_t state)  
2. {  
3.     struct list_head list;  
4.     int error = 0;  
5.   
6.     INIT_LIST_HEAD(&amp;list);  
7.     mutex_lock(&amp;dpm_list_mtx);  
8.     while (!list_empty(&amp;dpm_list)) {  
9.         // 逆序遍历链表,即先suspend后注册的设备,符合设备与父设备电源挂起的先后原则  
10.         struct device *dev = to_device(dpm_list.prev);  
11.   
12.         get_device(dev);  
13.         mutex_unlock(&amp;dpm_list_mtx);  
14.   
15.         dpm_drv_wdset(dev);  
16.         error = device_suspend(dev, state);  
17.         dpm_drv_wdclr(dev);  
18.   
19.         mutex_lock(&amp;dpm_list_mtx);  
20.         if (error) {  
21.             pm_dev_err(dev, state, &quot;&quot;, error);  
22.             put_device(dev);  
23.             break;  
24.         }  
25.         dev-&gt;power.status = DPM_OFF;  
26.         if (!list_empty(&amp;dev-&gt;power.entry))  
27.             list_move(&amp;dev-&gt;power.entry, &amp;list);  
28.         put_device(dev);  
29.     }  
30.     list_splice(&amp;list, dpm_list.prev);  
31.     mutex_unlock(&amp;dpm_list_mtx);  
32.     return error;  
33. }  
 函数将设备按照注册顺序反向挂起，挂起执行的流程如下：
1. static int device_suspend(struct device *dev, pm_message_t state)  
2. {  
3.     int error = 0;  
4.   
5.     down(&amp;dev-&gt;sem);  
6.   
7.     if (dev-&gt;class) {  // 类的suspend优先  
8.         if (dev-&gt;class-&gt;pm) {  
9.             pm_dev_dbg(dev, state, &quot;class &quot;);  
10.             error = pm_op(dev, dev-&gt;class-&gt;pm, state);  
11.         } else if (dev-&gt;class-&gt;suspend) {  
12.             pm_dev_dbg(dev, state, &quot;legacy class &quot;);  
13.             error = dev-&gt;class-&gt;suspend(dev, state);  
14.             suspend_report_result(dev-&gt;class-&gt;suspend, error);  
15.         }  
16.         if (error)  
17.             goto End;  
18.     }  
19.   
20.     if (dev-&gt;type) {  // device_type次之  
21.         if (dev-&gt;type-&gt;pm) {  
22.             pm_dev_dbg(dev, state, &quot;type &quot;);  
23.             error = pm_op(dev, dev-&gt;type-&gt;pm, state);  
24.         }  
25.         if (error)  
26.             goto End;  
27.     }  
28.   
29.     if (dev-&gt;bus) {  // bus优先级最低  
30.         if (dev-&gt;bus-&gt;pm) {  
31.             pm_dev_dbg(dev, state, &quot;&quot;);  
32.             error = pm_op(dev, dev-&gt;bus-&gt;pm, state);  
33.         } else if (dev-&gt;bus-&gt;suspend) {  
34.             pm_dev_dbg(dev, state, &quot;legacy &quot;);  
35.             error = dev-&gt;bus-&gt;suspend(dev, state);  
36.             suspend_report_result(dev-&gt;bus-&gt;suspend, error);  
37.         }  
38.     }  
39.  End:  
40.     up(&amp;dev-&gt;sem);  
41.   
42.     return error;  
43. }  
可以看到类中的suspend优先级最高，之后是device_type的，最后是bus的，大部分设备只注册了bus下的suspend。

</rich_text><rich_text scale="h2" weight="heavy">4、挂起处理器</rich_text><rich_text>
1. static int suspend_enter(suspend_state_t state)  
2. {  
3.     int error;  
4.     // 处理器的休眠准备函数  
5.     if (suspend_ops-&gt;prepare) {  
6.         error = suspend_ops-&gt;prepare();  
7.         if (error)  
8.             return error;  
9.     }  
10.     // 执行非sysdev的late suspend函数  
11.     error = dpm_suspend_noirq(PMSG_SUSPEND);  
12.     if (error) {  
13.         printk(KERN_ERR &quot;PM: Some devices failed to power down\n&quot;);  
14.         goto Platfrom_finish;  
15.     }  
16.     // 处理器休眠最后的准备  
17.     if (suspend_ops-&gt;prepare_late) {  
18.         error = suspend_ops-&gt;prepare_late();  
19.         if (error)  
20.             goto Power_up_devices;  
21.     }  
22.   
23.     if (suspend_test(TEST_PLATFORM))  
24.         goto Platform_wake;  
25.     // 关闭非启动cpu  
26.     error = disable_nonboot_cpus();  
27.     if (error || suspend_test(TEST_CPUS))  
28.         goto Enable_cpus;  
29.     // 挂起中断  
30.     arch_suspend_disable_irqs();  
31.     BUG_ON(!irqs_disabled());  
32.     // 挂起sysdev  
33.     error = sysdev_suspend(PMSG_SUSPEND);  
34.     if (!error) {  
35.         if (!suspend_test(TEST_CORE))  
36.             // 处理器的休眠进入函数,休眠流程运行至此  
37.             error = suspend_ops-&gt;enter(state);  
38.         // 唤醒sysdev  
39.         sysdev_resume();  
40.     }  
41.     // 使能中断  
42.     arch_suspend_enable_irqs();  
43.     BUG_ON(irqs_disabled());  
44.   
45.  Enable_cpus:  
46.     // 使能非启动cpu  
47.     enable_nonboot_cpus();  
48.   
49.  Platform_wake:  
50.     // 处理器开始唤醒  
51.     if (suspend_ops-&gt;wake)  
52.         suspend_ops-&gt;wake();  
53.   
54.  Power_up_devices:  
55.     // 执行非sysdev的early resume函数  
56.     dpm_resume_noirq(PMSG_RESUME);  
57.   
58.  Platfrom_finish:  
59.     // 处理器休眠结束  
60.     if (suspend_ops-&gt;finish)  
61.         suspend_ops-&gt;finish();  
62.   
63.     return error;  
64. }  
 在这个阶段首先看处理器是否需要做一些准备，接下来执行非sysdev的late suspend函数，然后处理器做休眠前最后的准备、关闭非启动cpu、挂起中断，再挂起sysdev，最后进入处理器的挂起函数，至此休眠流程结束，处理器等待用户或者RTC唤醒。
 
</rich_text><rich_text scale="h2"> </rich_text><rich_text scale="h2" weight="heavy">附1、late suspend</rich_text><rich_text>
 在这里我们看到了一种新的suspend机制 — late  suspend，是在所有的suspend执行完后再开始执行，接口为dev-&gt;bus-&gt;pm-&gt;suspend_noirq；这样 early_suspend、suspend以及late suspend构成了suspend的三部曲，late suspend是在中断关闭的情况下进行的；前面我们分析的wake_lock就有用到，用于检测在suspend阶段是否有锁被激活。late suspend的实现如下：
 
 
1. int dpm_suspend_noirq(pm_message_t state)  
2. {  
3.     struct device *dev;  
4.     int error = 0;  
5.   
6.     suspend_device_irqs();  // 关闭除唤醒系统以外的所有中断  
7.     mutex_lock(&amp;dpm_list_mtx);  
8.     list_for_each_entry_reverse(dev, &amp;dpm_list, power.entry) {  
9.         // 执行所有设备的late suspend函数  
10.         error = device_suspend_noirq(dev, state);  
11.         if (error) {  
12.             pm_dev_err(dev, state, &quot; late&quot;, error);  
13.             break;  
14.         }  
15.         dev-&gt;power.status = DPM_OFF_IRQ;  
16.     }  
17.     mutex_unlock(&amp;dpm_list_mtx);  
18.     if (error)  
19.         dpm_resume_noirq(resume_event(state));  
20.     return error;  
21. }  
22. EXPORT_SYMBOL_GPL(dpm_suspend_noirq);  
 
</rich_text><rich_text scale="h2" weight="heavy"> 附2、中断关闭流程</rich_text><rich_text>
在late suspend机制中我们看到了休眠流程中关闭系统中断的地方： 
1. void suspend_device_irqs(void)  
2. {  
3.     struct irq_desc *desc;  
4.     int irq;  
5.   
6.     for_each_irq_desc(irq, desc) {  // 遍历系统的中断  
7.         unsigned long flags;  
8.   
9.         spin_lock_irqsave(&amp;desc-&gt;lock, flags);  
10.         __disable_irq(desc, irq, true);  // 关闭中断  
11.         spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);  
12.     }  
13.   
14.     for_each_irq_desc(irq, desc)  
15.         if (desc-&gt;status &amp; IRQ_SUSPENDED)  
16.             synchronize_irq(irq);  
17. }  
18. EXPORT_SYMBOL_GPL(suspend_device_irqs);  
函数调用了__disable_irq()来关闭中断，我们看一下这个函数的实现： 
 
1. void __disable_irq(struct irq_desc *desc, unsigned int irq, bool suspend)  
2. {  
3.     if (suspend) {  
4.         // 如果中断没有被激活或者中断的IRQF_TIMER标志被置位则不关闭中断  
5.         // 在以后的内核版本中这个标志位被换成了IRQF_NO_SUSPEND  
6.         // 新版的IRQF_TIMER = (__IRQF_TIMER | IRQF_NO_SUSPEND)  
7.         if (!desc-&gt;action || (desc-&gt;action-&gt;flags &amp; IRQF_TIMER))  
8.             return;  
9.         desc-&gt;status |= IRQ_SUSPENDED;  
10.     }  
11.     // 判断中断是否被打开  
12.     if (!desc-&gt;depth++) {  
13.         // 更新标志位  
14.         desc-&gt;status |= IRQ_DISABLED;  
15.         // 关闭中断  
16.         desc-&gt;chip-&gt;disable(irq);  
17.     }  
18. }  
可以看到如果该中断没有被激活或者中断的IRQF_TIMER标志被置位就不会关闭中断，在新的内核版本中增加了专门的 IRQF_NO_SUSPEND 标志位，用来置位在休眠状态下唤醒系统的中断，如RTC、按键等；如果是其他中断则将打开的中断关闭掉。 附3、dpm_list链表
 dpm_list是内核中用于设备电源管理的链表，设备注册时通过一系列的调用 device_register()  -&gt; device_add() -&gt; device_pm_add()  最后在device_pm_add()中将设备加入dpm_list链表中：
 
 
1. // 设备创建时都会调用的函数,将设备加入dpm_list链表  
2. void device_pm_add(struct device *dev)  
3. {  
4.     pr_debug(&quot;PM: Adding info for %s:%s\n&quot;,  
5.          dev-&gt;bus ? dev-&gt;bus-&gt;name : &quot;No Bus&quot;,  
6.          kobject_name(&amp;dev-&gt;kobj));  
7.     mutex_lock(&amp;dpm_list_mtx);  
8.     if (dev-&gt;parent) {  
9.         if (dev-&gt;parent-&gt;power.status &gt;= DPM_SUSPENDING)  
10.             dev_warn(dev, &quot;parent %s should not be sleeping\n&quot;,  
11.                  dev_name(dev-&gt;parent));  
12.     } else if (transition_started) {  
13.         /* 
14.          * We refuse to register parentless devices while a PM 
15.          * transition is in progress in order to avoid leaving them 
16.          * unhandled down the road 
17.          */  
18.         dev_WARN(dev, &quot;Parentless device registered during a PM transaction\n&quot;);  
19.     }  
20.     // 将设备节点添加到链表尾部,即设备按注册的先后顺序从链表头部到尾部  
21.     list_add_tail(&amp;dev-&gt;power.entry, &amp;dpm_list);  
22.     mutex_unlock(&amp;dpm_list_mtx);  
23. }  
而设备注销的时候会调用device_pm_remove()将设备从dpm_list链表中移除： 
 
1. // 设备注销时都会调用的函数,将设备从dpm_list链表中移除  
2. void device_pm_remove(struct device *dev)  
3. {  
4.     pr_debug(&quot;PM: Removing info for %s:%s\n&quot;,  
5.          dev-&gt;bus ? dev-&gt;bus-&gt;name : &quot;No Bus&quot;,  
6.          kobject_name(&amp;dev-&gt;kobj));  
7.     mutex_lock(&amp;dpm_list_mtx);  
8.     list_del_init(&amp;dev-&gt;power.entry);  
9.     mutex_unlock(&amp;dpm_list_mtx);  
10.     pm_runtime_remove(dev);  
11. }
</rich_text></node></node><node name="switch module" prog_lang="custom-colors" readonly="False" tags="" unique_id="25"><rich_text>
    switch是Android引进的一个新驱动，用于检测一些开关量。比如检测耳机插入和ＵＳＢ设备插入等。
 
</rich_text><rich_text scale="h2">Switch的构架原理</rich_text><rich_text>
    switch模块包含两部分内容：首先是switch class，它在Android中是作为一个module来实现的，可以进行动态加载；其次是 switch class中的一个具体的switch设备switch gpio，它表示针对gpio的一个switch设备，switch gpio  是基于platform device框架的，它们的实现分别位于下面两个源代码文件中：
 －　drivers\switch\switch_class.c
 －　drivers\swithc\switch_gpio.c
 switch的运作方式是在sysfs文件系统中创建相应的entry，用户可以通过sysfs与之交互，也可以通过uevent机制与之交互，从而检测switch的状态。
 
</rich_text><rich_text scale="h3">1.  Switch class的实现</rich_text><rich_text>
 switch class的实现对应于switch_class.c文件，首先需要分析switch设备的结构体，它位于include/linux/switch.h中，其结构体switch_dev的定义如下：
 struct switch_dev {
     const char *name;
     struct device *dev;
     int index;
     int state;
     ssize_t (*print_name)(struct switch_dev *sdev, char *buf);
     ssize_t (*print_state)(struct switch_dev *sdev, char *buf);
 };
 其中name表示设备的名称；dev表示具体的设备对象；由于系统中可能存在多个switch设备，index则表示该设备是index个被注册的 switch设备；state表示当前设备的状态；另外的两个函数指针都是用于操作sysfs文件系统的，其中print_name函数用于在sysfs 中显示设备名称不，而print_state函数则用于显示设备的状态。　该结构体非常简单，下面我们继续分析具体的实现机制。
 我们同样可以在switch_class.c中发现如下的初始化操作和退出操作：
 static int __init switch_class_init(void)
 {
    return create_switch_class();
 }
 
 static void __exit switch_clas_exit(void)
 {
    class_destroy(switch_class);
 }
 module_init(switch_class_init);
 module_exit(switch_class_exit);
 整个操作都非常简单，初始化函数switch_class_init会调用create_switch_class来创建一个设备类，其具体实现如下：
 static int craete_switch_class(void)
 {
     if (!switch_class) {
        switch_class =class_create(THIS_MODULE, &quot;switch&quot;);
        if (IS_ERR(switch_class))
            return PTR_ERR(switch_class);
            
        atomic_set(&amp;deivce_count, 0);
     }
     
     return 0;
 }
 该函数通过调用class_create函数来创建一个switch设备类文件，创建之后通过atomic_set函数来设备设备的计数。
 执行退出操作时，直接通过class_destroy函数来销毁初始化时创建的设备类。
 我们说过，switch_class只是一个供所有具体的switch设备使用的“基础类”，因此，它提供了switch设备注册和缷载的函数 switch_dev_register和switch_dev_unregister。这里首先来分析注册函数的实现，定义如下：
 int switch_dev_register(structswitch_dev *sdev)
 {
     int ret;
     
     //检测switch_class是否被创建
     if (!switch_class) {
         ret = create_switch_class();
         if (ret &lt; 0)
            return ret;
     }
     
     //保存索引
     sdev-&gt;index =atomic_inc_return(&amp;device_count);
     
     //创建设备
     sdev-&gt;dev =device_create(switch_class, NULL,MKDEV(0, sdev-&gt;index), NULL,sdev-&gt;name);
     if (IS_ERR(sdev-&gt;dev))
        return PTR_ERR(sdev-&gt;dev);
        
     //创建设备文件用于输出设备状态
     ret = device_create_file(sdev-&gt;dev,&amp;dev_attr_name);
     if (ret &lt; 0)
     goto err_create_file_2;
     
     //设置数据
     dev_set_drvdata(sdev-&gt;dev, sdev);
     sdev-&gt;state = 0;
     return 0;
     
     //出现错误，移除文件
err_create_file_2 :
     device_remove_file(sdev-&gt;dev,&amp;dev_attr_state);
     
     //出现错误，销毁switch_class
err_create_file_1:
     device_destroy(switch_class, MKDEV(0,sdev-&gt;index));
     printk(KERN_ERR &quot;switch: Failed toregister driver %s\n&quot;, sdev-&gt;name);
     
     return ret;
 }
 EXPORT_SYMBOL_GPL(switch_dev_register);
 
 该函数用于创建一个具体的switch设备，其流程是：首先，判断是否已经创建switch_class,如果没有，则创建switch_class；其 次，取得要创建的设备的索引，然后通过device_create创建设备；最后，通过device_create_file函数在sysfs中分别创建 两个entry，如果创建失败，则分别删除已经创建的文件或者switch_class，一个用于输出设备状态state；另一个用于输出设备名称 name。我们将详细介绍dev_set_drvdata，因为在linux内核中它也非常常见，它是一个内联函数，定义于include/linux /device.h中，代码如下：
 static inline void dev_set_drvdata(struct device *dev, void *data)
 {
    dev-&gt;driver_data = data;
 }
 所以，上面的switch_dev_register函数中使用它是表示sdev已经赋值到sdev-&gt;dev-&gt;driver_data中。分析完了注册函数，下面我们来看一下卸载函数switch_dev_unregister，其定义如下：
 void switch_dev_unregister(struct switch_dev *sdev)
 {
     device_remove_file(sdev-&gt;dev,&amp;dev_attr_name);
     device_remove_file(sdev-&gt;dev,&amp;dev_attr_state);
     device_destroy(switch_class, MKDEV(0,sdev-&gt;index));
     dev_set_drvdata(sdev-&gt;dev, NULL);
 }
 EXPORT_SYMBOL_GPL(switch_dev_unregister);
 该函数主要用于释放注册时所创建的设备和空间。首先，通过device_remove_file函数删除用于输出状态和名称的entry；然后，销毁 switch_class；最后，再次使用dev_set_drvdata将sdev-&gt;dev-&gt;driver_data设置为ＮＵＬＬ；
 在初始化时我们创建了输出设备状态和名称的文件，那么我们就需要实现显示名称和状态的两个函数state_show和name_show。当用户读取 sysfs中对应的switch entry(/sys/class/#dev_name/name和/sys/class/#dev_name /state)时，系统会自动调用这两个函数为用户返回switch设备的名称和状态，其函数定义如下：
 static ssize_t state_show(structdevice *dev, struct device_attribute *attr, char *buf)
 {
     //得到switch_dev设备数据
     struct switch_dev *sdev = (struct switch_dev *)dev_get_drvdata(dev);
     
     //安全性检查
     if (sdev-&gt;print_state) {
         //输出状态
         int ret = sdev-&gt;print_state(sdev,buf);
         if (ret &gt;= 0)
            return ret;
     }
     
     return sprintf(buf, &quot;%d\n&quot;,sdev-&gt;state);
 }
 
 static ssize_t name_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct switch_dev *sdev = (struct switch_dev *)dev_get_drvdata(dev);
     
     if (sdev-&gt;print_name) {
         //输出名字
         int ret = sdev-&gt;print_name(sdev,buf);
         if (ret &gt;= 0)
            return ret;
     }
     return sprintf(buf, &quot;%s\n&quot;, sdev-&gt;name);
 }
 static DEVICE_ATTR(state, S_IRUGO |S_IWUSR, state_show, NULL);
 static DEVICE_ATTR(name, S_IRUGO |S_IWUSR, name_show, NULL);
 
 这两个函数中都使用了dev_get_drvdata来取得switch设备数据，输出状态使用了print_state函数，输出名称使用了print_name函数。不知道大家是否还有印象，这两个函数是定义在switch_dev中的两个函数指针。
 既然switch设备有状态，那么就需要对状态进行操作，主要包括获取状态和设置状态。获取状态的操作很简单，它是switch.h中的一个内联函数，直接返回设备的状态，定义如下：
 static inline int switch_get_state(struct switch_dev *sdev)
 {
    return sdev-&gt;state;
 }
 
 设置状态的操作则稍微复杂一点，下面是设置设备状态的函数switch_set_state的实现：
 void switch_set_state(struct switch_dev *sdev, int state)
 {
     charname_buf[120];
     charstate_buf[120];
     char*prop_buf;
     char *envp[3];
     int env_offset= 0;
     int length;
     
     //判断当前状态
     if(sdev-&gt;state != state) {
         //改变状态
         sdev-&gt;state= state;
         prop_buf =(char *)get_zeroed_page(GFP_KERNEL);
         if (prop_buf) {
             //显示名称
             length =name_show(sdev-&gt;dev, NULL, prop_buf);
             if (length &gt;0) {
                 if (prop_buf[length – 1] == '\n')
                    prop_buf[length– 1] = 0;
                 sprintf(name_buf,sizeof(name_buf),&quot;SWITCH_NAME=%s&quot;, prop_buf);
                 envp[env_offset++]= name_buf;
             }
         
             //显示状态
             length =state_show(sdev-&gt;dev, NULL, prop_buf);
             if (length &gt;0) {
                 if (prop_buf[length – 1] == '\n')
                    prop_buf[length– 1] = 0;
                 snprintf(state_buf,sizeof(state_buf), &quot;SWITCH_STATE=%s&quot;, prop_buf);
                 envp[env_offset++]= state_buf;
             }
             envp[env_offset]= NULL;
             //触发uevent事件
             kobject_uevent_env(&amp;sdev-&gt;dev-&gt;kobj,KOBJ_CHANGE, envp);
             free_page((unsignedlong)prop_buf);
         } else {
             printk(KERN_ERR &quot;out of memory in switch_set_state\n&quot;);
             kobject_uevent(&amp;sdev-&gt;dev-&gt;kobj,KOBJ_CHANGE);
         }
    }
 }
 EXPORT_SYMBOL_GPL(switch_set_state);
 该函数用于设置当前设备的状态。开始之前，首先检测当前设备的状态是否与要设置的状态相同，如果相同，则不需要再次设置；否则，调用 get_zeroed_page()返回一片已经用０擦写过的内存页，并将其转化为指定的类型(char*)，用于显示状态和名称，并将其写入到 state_buf和name_buf缓冲区中一并作为uevent事件的信息，以用来通知用户的当前switch设备的名称和状态，最后通过 kobject_uevent_env和参数envp发送uevent事件。
 
</rich_text><rich_text scale="h3">1.  Gpio switch设备驱动</rich_text><rich_text>
 上面分析了switch模块中switch class的实现，下面就来分析一个具体的gpio的switch设备驱动的实现。首先，我们来看一下其设备信息的结构体，如下所示；
 struct gpio_switch_data {
     struct switch_dev sdev;
     unsigned gpio;
     const char *name_on;
     const char *name_off;
     const char *state_on;
     const char *state_off;
     int irq;
     struct work_struct work;
 };
 该结构体非常简单，这里需要说明的是其中４个char*的成员变量，它们是设备名称和状态的开关，判断是否需要输出设备的名称和状态。sdev表示一个 switch设备；gpio表示gpio电平；irq表示gpio终端指示；work用于表示gpio_switch_work工作，具体分析时我们还会介绍其细节。
 
 另外，还有一个结构体gpio_switch_platform_data用来储存gpio_switch设备的相关数据，其定义如下：
 struct gpio_switch_platform_data {
     const char *name; //设备名称
     unsigned gpio; //电平
     const char *name_on;
     const char *name_off;
     const char *state_on;
     const char *state_off;
 };
 该结构体的数据和gpio_switch_data中的数据所表达的意思几乎差不多，只是多了一个设备的名称，其实就是表示gpioswitch设备的platform_data数据。下面我们将分析其具体实现。　
 
 其初始化和退出过程就不详细介绍了，具体实现如下：
 static struct platform_driver gpio_switch_driver = {
     .probe = gpio_switch_probe,
     .remove =__devexit_p(gpio_switch_remove),
     .driver = {
        .name = “switch-gpio”,
        .owner = THIS_MODULE,
    },
 };
 static int __init gpio_switch_init(void)
 {
    return platform_driver_register(&amp;gpio_switch_driver);
 }
 
 static void __exit gpio_switch_exit(void)
 {
    platform_driver_unregister(&amp;gpio_switch_driver);
 }
 module_init(gpio_switch_init);
 module_exit(gpio_switch_exit);
 
 由于gpio_switch是基于platform device/driver框架的，因此初始化时会通过gpio_switch_init来调用 platform_driver_register，然后进入gpio_switch_driver所指定的gpio_switch_probe函数中完 成初始化过程。gpio_switch_driver中还指定了驱动的名称和owner，以及设备退出时需要处理gpio_switch_remove。 因为我们说过，switch class在Android中是作为一个module来实现的，所以”.owner”被指定为THIS_MODULE。
 我们主要来分析初始化函数gpio_switch_probe的实现，如下所示:
 static int gpio_switch_probe(struct platform_device *pdev)
 {
     //取得gpioswitch的platform_data数据的使用权
     struct gpio_switch_platform_data *pdata = pdev-&gt;dev.platform_data;
     struct gpio_switch_data *switch_data;
     int ret = 0;
     
     if (!pdata)
        return -EBUSY;
        
     //创建gpio_switch
     switch_data = kzalloc(sizeof(struct gpio_switch_data), GFP_KERNEL);
     if (switch_data)
        return -ENOMEM;
        
     //初始化gpio_switch
     switch_data-&gt;sdev.name =pdata-&gt;name;
     switch_data-&gt;gpio = pdata-&gt;gpio;
     switch_data-&gt;name_on =pdata-&gt;name_on;
     switch_data-&gt;name_off =pdata-&gt;name_off;
     switch_data-&gt;state_on =pdata-&gt;state_on;
     switch_data-&gt;state_off =pdata-&gt;state_off;
     switch_data-&gt;sdev.print_state =switch_gpio_print_state;
     //注册switch设备switch_dev
     ret =switch_dev_register(&amp;switch_data-&gt;sdev);
     if (ret &lt; 0)
        goto erro_request_gpio;
        
     //设置gpio方向为输入
     ret =gpio_direction_input(switch_data-&gt;gpio);
     if (ret &lt; 0)
        goto err_set_gpio_input;
        
     //指定gpio_switch_work
     INIT_WORK(&amp;switch_data-&gt;work,gpio_switch_work);
     //为gpio分配中断
     switch_data-&gt;irq =gpio_to_irq(switch_data-&gt;gpio);
     if (switch_data-&gt;irq &lt; 0) {
        ret = switch_data-&gt;irq;
        goto err_detect_irq_num_failed;
     }
     
     //指明中断服务程序
     ret = request_irq(switch_data-&gt;irq,gpio_irq_handle, IRQF_TRIGGER_LOW, pdev-&gt;name, switch_data);
     if (ret &lt; 0)
        goto err_request_irq;
        
     //初始化gpio_switch_work
     gpio_switch_work(&amp;switch_data-&gt;work);
     
     return 0;
     
     //错误处理
err_request_irq:
err_detect_irq_num_failed:
err_set_gpio_input:
     gpio_free(switch_data-&gt;gpio);
     
err_request_gpio:
     switch_dev_unregister(&amp;switch_data-&gt;sdev);
     
err_switch_dev_register:
     kfree(switch_data);
     
     return ret;
 }
 
 关于初始化函数的原理和要点，注解已经写得很清楚，这里就不再具体分析了。初始化的过程主要包括以下几个步骤：
 １）获取gpio数据使用权。
 ２）设置gpio方向为输入
 ３）注册switch_dev设备
 ４）为gpio分配中断，并指定中断服务程序；
 ５）初始化gpio_switch_work;
 ６）读取gpio初始状态。
 
 同理，退出函数也就很简单了，定义如下：
 static int __devexitgpio_switch_remove(struct platform_device *pdev)
 {
     struct gpio_switch_data *switch_data= platform_get_drvdata(pdev);
 
     //清除gpio_switch_work
     cancel_work_sync(&amp;switch_data-&gt;work);
     //释放gpio
     gpio_free(switch_data-&gt;gpio);
     //缷载gpio_switch_data
     switch_dev_unregister(&amp;switch_data-&gt;sdev);
     //释放空间
     kfree(switch_data);
 
     return 0;
 }
 初始化时我们指定了中断服务程序，当ＧＰＩＯ触发中断事件时，就会进入中断服务程序进行处理，其定义如下：
 
 static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
 {
     struct gpio_switch_data *switch_data= (struct gpio_switch_data *)dev_id;
     schedule_work(&amp;switch_data-&gt;work);

     return IRQ_HANDLED;
 }
 该函数很简单，取得gpio_switch_data并执行work。这里的work就是我们在初始化时指定的gpio_switch_work，其处理方式如下：
 
 static void gpio_switch_work(structwork_struct *work)
 {
     int state;
     struct gpio_switch_data *data =container_of (work, struct gpio_switch_data, work);
     
     //读取gpio
     state = gpio_get_value(data-&gt;gpio);
     switch_set_state(&amp;data-&gt;sdev,state);
 }
 该函数的处理过程很简单，先直接读取gpio电平，取得状态；然后通过switch_set_state来设置和改变状态，这时便会调用我们实现的 switch_gpio_print_state和switch_gpio_print_name函数。但是我们发现，源代码中并没有实现 switch_gpio_print_name函数，因此，这里只关心设备的状态，名称在注册之后没有更改过，暂时也就不会去处理它了。从前面的 name_show函数的实现我们可以看到，如果没有实现switch_gpio_print_name函数，设备的名字则会被输出到name_show 函数的参数buf的缓冲区里，但这并不影响什么。
 
 switch_gpio_print_state的具体实现如下：
 static ssize_t switch_gpio_print_state(struct switch_dev *sdev, char *buf)
 {
     struct gpio_switch_data *switch_data=
     container_of (sdev, struct gpio_switch_data, sdev);
     const char *state;
     if (switch_get_state(sdev))
         state = switch_data-&gt;state_on;
     else
         state = switch_data-&gt;state_off;

     if (state)
         return sprintf(buf, “%s\n”,state);

     return – 1;
 }
 该函数通过状态开(state_on)关(state_off)来确定是否将GPIO状态输出到sysfs。大家应该明白状态开关的用处了吧，名称的状态开关的作用也是一样，只不过这里没有实现罢了。到这里，对switch模块的完整分析就结束了。
</rich_text><node name="android耳机插入检测 " prog_lang="custom-colors" readonly="False" tags="" unique_id="26"><rich_text>在Android 中其实并没有耳机系统这个称呼，只是我为了方便解释而加的。在整个android系统中，跟耳机相关的部分有： 
1.      Linux 驱动：主要完成耳机的插入的检测，hook键的检测，其中hook键包括长按和短按。 
2.      在frameworks 中的耳机的观察的文件（HeadsetObserver.java ），这个文件主要是检测耳机是否插入和名字，并把相关的内容通过Intent 广播出去。 
3.      跟音频相关，改变音频输出的路径（这边涉及到播放音乐和电话部分）。
4.      跟事件的处理相关，这部分主要体现 hook 的功能，主要是接听电话，挂断电话等。
事件的处理又分为linux 的事件处理和android上的事件处理。 
 
 我将分块叙述，由于各种原因，我在这不便把源代码公布，如果你需要的我的帮助，可以发邮件给我，也可以在我blog 上留言，谢谢! 
 
</rich_text><rich_text foreground="#ffff00000000" scale="h2">Linux 驱动</rich_text><rich_text scale="h2"> </rich_text><rich_text>
首先要定义一个switch_dev（structswitch_dev sdev; ）并把它初始化，如（sdev.name=  ……）；然后注册一个switch device ： 
      ret= switch_dev_register(&amp;switch_data-&gt;sdev); 
      if(ret &lt; 0) 
     { 
        goto err_switch_dev_register; 
     } 
switch_dev_register这个函数在 switch_class.c 中实现 
int switch_dev_register(struct switch_dev*sdev) 
{ 
     int ret; 
     
      if (!switch_class) { 
        ret = create_switch_class(); 
        if (ret &lt; 0) 
            return ret; 
     } 
     
     sdev-&gt;index = atomic_inc_return(&amp;device_count); 
     sdev-&gt;dev = device_create(switch_class, NULL, 
     MKDEV(0, sdev-&gt;index), NULL, sdev-&gt;name); 
     if (IS_ERR(sdev-&gt;dev)) 
        return PTR_ERR(sdev-&gt;dev); 
     ret= device_create_file(sdev-&gt;dev, &amp;dev_attr_state); 
     if (ret &lt; 0) 
        goto err_create_file_1; 
     ret= device_create_file(sdev-&gt;dev, &amp;dev_attr_name); 
     if (ret &lt; 0) 
        goto err_create_file_2; 
     
     dev_set_drvdata(sdev-&gt;dev, sdev); 
     sdev-&gt;state = 0; 
     
     return 0; 
     
err_create_file_2: 
     device_remove_file(sdev-&gt;dev,&amp;dev_attr_state); 
err_create_file_1: 
     device_destroy(switch_class, MKDEV(0, sdev-&gt;index)); 
     printk(KERN_ERR &quot;switch: Failed to register driver %s\n&quot;,sdev-&gt;name); 
     
     return ret; 
} 
 
这个函数中主要是以下几个函数
l  create_switch_class() 
l  device_create(switch_class, NULL, MKDEV(0, sdev-&gt;index), NULL,sdev-&gt;name); 
l  device_create_file(sdev-&gt;dev, &amp;dev_attr_state); 
l  device_create_file(sdev-&gt;dev, &amp;dev_attr_name); 
经过以上函数后将会生成路径和被用户空间访问的节点 
 
&quot;/sys/class/switch/h2w/name&quot;; 
&quot;/sys/class/switch/h2w/state&quot;; 
这两个供用户空间访问 
 
在这个函数中要注意到 
static DEVICE_ATTR(state, S_IRUGO |S_IWUSR, state_show, NULL); 
static DEVICE_ATTR(name, S_IRUGO | S_IWUSR,name_show, NULL); 
这两项中用于设置节点state和name的属性 
 
DEVICE_ATTR 有四个参数，分别为名称、权限位、读函数、写函数
有此可以知道state 和name，虽然有读写权限，但都只有读函数，没有写函数。 
其中state 对headsetobserver.java 区分有无 mic和耳机是否插入起作用 
static ssize_t state_show(struct device*dev, struct device_attribute *attr, 
 char *buf) 
{ 
 struct switch_dev *sdev = (struct switch_dev *) dev_get_drvdata(dev); 
 
  if (sdev-&gt;print_state) {    // 如果用户有定义print_state函数，将调用用户定义的 
    int ret = sdev-&gt;print_state(sdev, buf); 
    if (ret &gt;= 0) 
        return ret; 
 } 
 
 return sprintf(buf, &quot;% d\n&quot;, sdev-&gt;state);// 把sdev-&gt;state 以%d的格式装如 buf 中 
} 
 
在这个函数得注意：如果你想你的frameworks 能区别出有没有mic，并且你用的是switch_gpio.c这个文件的话，你需要把switch_gpio.c中的sdev-&gt;print_state 的定义去掉。 
我就在这卡了半天的时间。State原先出来一直是1 ，后来才发现原来是自己定义了sdev-&gt;print_state 并只返回 0 和1 ，没有其他值。 
 
现重新回到driver，接下来时 input 子系统的内容 input_allocate_device(); 分配内存给新的输入设备  接下去初始化input_dev 这个结构体，给输入设备命名dev-&gt;name， 设置input 支持的键值  input_set_capability，如： 
 input_set_capability(ipdev, EV_KEY,KEY_MEDIA); 
 input_set_capability(ipdev, EV_SW,SW_HEADPHONE_INSERT); 
 input_set_capability(ipdev, EV_KEY, KEY_END); 
  注册input 设备 input_register_device(ipdev); 
   在驱动中还涉及到工作队列等问题，就请各位自己去看一下吧。 
接下来是对于中断的处理，这个中断方式我是从HTC 的驱动中学的，有点巧妙，想到了叶
就不算巧妙了，呵呵。 
  先申请为高电平中断，我的板子是插入耳机检测脚我高电平，在进入中断后再申请为低
电平中断，这个相对于上升和下降有个好处——当设置为上升或下降沿触发中断时，开机之
前插入耳机，当开机后，将识别不到耳机。而当设置为电平触发可以解决这个问题。 
  我的观点是在耳机在插槽内时，检测引脚直接被拉倒插入耳机稳定后的电平，而不会产
生上升和下降沿。中断申请的代码如下： 
request_irq(gpio_to_irq(18),gpio_irq_handler,IRQF_TRIGGER_HIGH,pdev-&gt;name,switch_data);
中断处理的代码如下： 
set_irq_type(gpio_to_irq(18),gpio_get_value(18) ? IRQF_TRIGGER_LOW : 
IRQF_TRIGGER_HIGH); 
由上可以看到C 语言的问号表达式的好处了吧，呵呵。C 语言博大精深！还有很多精
髓的问题，以后用了，慢慢体会，如果你觉得你的C 非常好了，呵呵，找一个C 语言的笔
试题来做做，哈哈，你真会发现又学到一堆的东西。呵呵。继续我们的驱动。 
  接下来是有无mic的判断和设置state 的值了，有 HeadsetObserver.java 这个文件中可以
得出state 的值： 
  有mic：state 等于1 
  没有mic：state 等于 2 
扯点题外，我原先以为在&quot;/sys/class/switch/h2w/state&quot;;下的state 只有 0 和1 ，我再问了我
的一些同事，他们也跟我说是bool类型。但我看到headsetobserver.java中又有1 和2，
后面觉得有点可疑。再看源代码之前，真的不想看源代码，看了源代码后，发现源代码
真好。哈哈。通过一步步跟，后面发现时可以大于1 的，呵呵。 
这个将要用到switch_get_state(&amp;data-&gt;sdev)这个函数，它也是在switch_class.c中实现的。 
void switch_set_state(struct switch_dev*sdev, int state) 
{ 
    char name_buf[120]; 
    char state_buf[120]; 
    char *prop_buf; 
    char *envp[3]; 
    int env_offset = 0; 
    int length; 
 
    if (sdev-&gt;state != state) { 
        sdev-&gt;state = state;  //实现你要设置的值 
        prop_buf = (char *)get_zeroed_page(GFP_KERNEL); 
        if (prop_buf) { 
            length = name_show(sdev-&gt;dev, NULL, prop_buf); //给HeadsetObserver.java 读取名字 
            if(length &gt; 0) { 
                if (prop_buf[length - 1] == '\n') 
                    prop_buf[length - 1] = 0; 
                snprintf(name_buf, sizeof(name_buf), 
                    &quot;SWITCH_NAME=%s&quot;, prop_buf);
     
                envp[env_offset++] = name_buf; 
           } 
            length = state_show(sdev-&gt;dev, NULL, prop_buf); // 给HeadsetObserver.java 读取状态，这个函数我们在前面分析过了，这个函数比较重要，关系到区分有无mic。  
            if(length &gt; 0) { 
                if (prop_buf[length - 1] == '\n') 
                    prop_buf[length - 1] = 0; 
                snprintf(state_buf, sizeof(state_buf), 
                    &quot;SWITCH_STATE=%s&quot;, prop_buf); 
                envp[env_offset++] = state_buf; 
            } 
            envp[env_offset] = NULL; 
            kobject_uevent_env(&amp;sdev-&gt;dev-&gt;kobj, KOBJ_CHANGE, envp); 
            free_page((unsigned long)prop_buf); 
        } else { 
            printk(KERN_ERR &quot;out of memory in switch_set_state\n&quot;); 
            kobject_uevent(&amp;sdev-&gt;dev-&gt;kobj, KOBJ_CHANGE); 
        } 
    } 
} 
EXPORT_SYMBOL_GPL(switch_set_state); //供外部所使用。 
由于hook 键和检测 mic的有关联，故如果有mic则要申请hook 的中断。 
具体mic的检测可以参考我的blog 中转载别人的的一篇文章，链接地址如下 
 
http://blog.chinaunix.net/u3/106866/showart_2273977.html
 
接下来是HOOK 键功能的处理了，在google 论坛里有些说实现 hook 键接听和挂断电
话的问题。Hook键只有一个，要实现两个功能就得要用时间来区分了， 
  短按：代表接听。 
  长按：代表拒接。 
这样两种功能就实现了，呵呵。对于长短的检测最好用纳秒，用秒的准确性比较低。存在误
判性比较高，可以利用把时间转换成纳秒来计算，我用如下实现检测时间的长短： 
do_gettimeofday(&amp;time);  
timens=timeval_to_ns(&amp;time);  
while(gpio_get_value(123)==0){}; 
do_gettimeofday(&amp;time); 
(timeval_to_ns(&amp;time)-timens)由这个式子可以得到比较准确的时间。 
在利用这个时间，你确定一个判断长短的依据，就可以了如： 
if ((timeval_to_ns(&amp;time)-timens)&lt;1000000000l) {//短按 
    if ( (timeval_to_ns(&amp;time)-timens) &gt; 50000000) { // 为了取出噪音，而设置一定的最低值
        input_report_key(switch_data-&gt;ipdev,KEY_MEDIA,1); 
        input_sync(switch_data-&gt;ipdev); 
        msleep(100); 
        input_report_key(switch_data-&gt;ipdev,KEY_MEDIA,0); 
        input_sync(switch_data-&gt;ipdev); 
    } 
} else {//长按 
    input_report_key(switch_data-&gt;ipdev,KEY_END,1); 
    input_sync(switch_data-&gt;ipdev); 
    msleep(100); 
    input_report_key(switch_data-&gt;ipdev,KEY_END,0); 
    input_sync(switch_data-&gt;ipdev); 
} 
在这传上去的是KEY_MEDIA和KEY_END，然而这两个键值又如何对应上层的接听和挂
断呢？其中KEY_END 在frameworks 层已经映射成挂机键了，然而 KEY_MEDIA 却要你自
己映射成HEADSETHOOK键，在你android的根目录下在 
sdk\emulator\keymaps下qwerty.kl 中加入 
key 226  HEADSETHOOK       WAKE 
 
在这说明一下有些地方说是 
./development/emulator/keymaps/qwerty.kl 
我的是android2.1 的版本，我在我的版本下没发现 qwerty.kl 。我想这可能是版本的差异吧。 
 
到此，linux 驱动层算是大体结束了。 
 
</rich_text><rich_text foreground="#ffff00000000" scale="h2">Frameworks 层耳机相关 </rich_text><rich_text>
启动服务在systemserver.java中 
public class SystemServer 
{ 
     public static void main(String[] args) 
     { 
        …… 
        init1(args); 
        …… 
    } 
    
    public static final void init2() { 
       Log.i(TAG, &quot;Entered the Android system server!&quot;); 
       Thread thr = new ServerThread(); 
       thr.setName(&quot;android.server.ServerThread&quot;); 
       thr.start(); 
    }
 
} 
 
init1 将会调用到 android_server_SystemServer_init1.cpp 
extern &quot;C&quot; int system_init(); 
static voidandroid_server_SystemServer_init1(JNIEnv* en v, jobject clazz) 
{ 
   system_init(); 
} 
由上可以得到，将调用到System_init.cpp
extern &quot;C&quot; status _tsystem_init() 
{ 
    …… 
    runtime-&gt;callStatic(&quot;com/android/server/SystemServer&quot;, &quot;init2&quot;); 
    …… 
} 
 
由上可以看出，此时将调回到systemserver.java，并且调用 
public static final void init2() { 
    Log.i(TAG, &quot;Entered the Android systemserver!&quot;); 
           Thread th r = new ServerThread(); 
           thr.setName(&quot;android.server.ServerThread&quot;); 
           thr.start(); 
} 
新建线程 
class ServerThread  extends Thread 
{ 
    …… 
    public void run() 
    { 
        …… 
        try { 
            Log.i(TAG, &quot;Headset Observer&quot;); 
            // Listen for wired headset changes 
            headset = new HeadsetObserver(context); //new a thread to observer headset status 
        } catch (Throwable e) { 
            Log.e(TAG, &quot;Failu re starting HeadsetObserver&quot;, e); 
        } 
    } 
} 
开始服务：HeadsetObserver.java
class HeadsetObserver extendsUeventObserver 
{ 
    …… 
    public HeadsetObserver(Context context)  
    { 
        …… 
        startObserving(HEADSET_UEVENT_MATCH); 
        
        init();  // set initial status 
    } 
} 
 
运行以上程序后会一直监测HEADSET_UEVENT_MATCH路径的事件， 
HEADSET_UEVENT_MATCH =&quot;DEVPATH=/devices/virtual/switch/h2w&quot;; 
如果有事件的变化，则会调用 
public void onUEvent(UEventObserver.UEventevent)   
{ 
    if (LOG) Log.v(TAG, &quot;Headset UEVENT:&quot; + event.toString()); 
     
    try { 
        update(event.get(&quot;SWITCH_ NAME&quot;),Integer.parseInt(event.get(&quot;SWITCH_STATE&quot;))); 
    } catch (NumberFormatException e) { 
        Log.e(TAG, &quot;Could not parse switch state from event &quot; +event); 
    }
} 
     
private synchronized final void update(String newName, int newState)   
{ 
    …… 
     mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,
                                                        mPrevHeadsetState, 
                                                        mHeadsetName),//send message 
} 

一下一段没有考证：但我猜应该是由于这个原因会调用到sendIntents 
private final Handler mHandler = newHandler() 
{ 
    @Override 
    public void handleMessage(Message msg)   
    { 
        sendIntents(msg.arg1, msg.arg2,(String)msg.obj); 
        mWakeLock.release(); 
    } 
}; 
如果有新的事件，将会调用 
private synchronized final void sendIntents 
再调用到 
private final void sendIntent 
此处填充Intent 。 
private final void sendIntent(int headset,int headsetState, int prevHeadsetState, String 
headsetName) 
{ 
    …… 
    Intent intent = new Intent(Intent.ACTION_HEADSET_PLUG); 
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    …… 
    if ((headset &amp; HEADSETS_WITH_MIC) !=0) { 
        microphone = 1;//  是否有 mic 
    } 
    if ((headsetState &amp; headset) != 0) { 
        state = 1; 
    } 
    intent.putExtra(&quot;state&quot;, state); 
    intent.putExtra(&quot;name&quot;, headsetName); 
    intent.putExtra(&quot;microphone&quot;,microphone); 
    …… 
    ActivityManagerNative.broadcastStickyIntent(intent,null);    //broadcast intent 
} 
 
</rich_text><rich_text foreground="#00000000ffff" scale="h3">跟音频相关 </rich_text><rich_text>
此时在AudioService.java中将接收Broadcast 
private class AudioServiceBroadcastReceiverextends BroadcastReceiver 
{ 
    public void onReceive(Context context,Intent intent) 
    { 
        …… 
        else if (action.equals(Intent.ACTION_HEADSET_PLUG)) { 
            …… 
            //if you first insert headset, will implement fellow code 
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,&quot;&quot;);
        } 
    } 
} 
调用setDeviceConnectionState由在android_media_AudioSystem.cpp中可以得到 
static JNINativeMethod gMethods[] = {  
    &quot;setDeviceConnectionState&quot;,&quot;(IILjava/lang/String;)I&quot;,(void*)android_media_AudioSystem_setDeviceConnectionState},  
}; 
所以将调用到android_media_AudioSystem_setDeviceConnectionState
android_media_AudioSystem_setDeviceConnectionState(JNIEnv*env, jobject thiz, jint device, 
    jint state, jstring device_address) 
{ 
    …… 
    Intstatus =check_AudioSystem_Command(AudioSystem::setDeviceConnectionState(static_cast&lt;AudioSystem::audio_devices&gt;(device), 
        static_cast &lt;AudioSystem::device_connection_state&gt;(state),c_address)); 
    …… 
} 
由上段程序可以看出，将会调用到AudioSystem.cpp中的setDeviceConnectionState 
status_t AudioSystem::setDeviceConnectionState(audio_devicesdevice, 
                                                 device_connection_state state, 
                                                 const char *device_address) 
{ 
    const sp&lt;IAudioPolicyService&gt;&amp; aps =AudioSystem::get_audio_policy_service(); 
   
    if (aps == 0) return PERMISSION_DENIED; 
 
    return aps-&gt;setDeviceConnectionState(device, state, device_address); 
} 
get_audio_policy_service();这个函数具体做什么我现在还没弄清楚。 
一下这边我没找到具体的联系，我通过打印得知会调用到AudioPolicyManager.cpp 的
setDeviceConnectionState 函数，以下的函数很重要，关系到设置输出路径等 
status_tAudioPolicyManager::setDeviceConnectionState(AudioSystem::audio_devices device,
                                         AudioSystem::device_connection_state state, 
                                                 const char *device_address) 
{ 
      …… 
      //handle output devices 
    if(AudioSystem::isOutputDevice(device)) { 
        switch (state) { 
            case AudioSystem::DEVICE_STATE_AVAILABLE: 
                …… 
                if (AudioSystem::isBluetoothScoDevice(device)) { 
                    …… 
                } else if (device == AudioSyste m::DEVICE_OUT_WIRED_HEADSET || 
                        device == AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) { 
                    if (getDeviceForStrategy(STRATEGY_PHONE) ==device &amp;&amp; 
                        (mPhoneState ==AudioSystem::MODE_IN_CALL || 
                        mOutputs.valueFor(mHardwareOutput)-&gt;isUsedByStrategy(STRATEGY_PHONE))) { 
                        newDevice = device; 
                    } else if ((getDeviceForStrategy(STRATEGY_SONIFICATION) &amp; device) &amp;&amp; 
                        mOutputs.valueFor(mHardwareOutput)-&gt;isUsedByStrategy(STRATEGY_SONIFICATION)) { 
                        newDevice =getDeviceForStrategy(STRATEGY_SONIFICATION); 
                    } else if ((getDeviceForStrategy(STRATEGY_MEDIA) == device) &amp;&amp;                          
                                mOutputs.valueFor(mHardwareOutput)-&gt;isUsedByStrategy(STRATEGY_MEDIA)) { 
                        newDevice = device; 
                    } else if (getDeviceForStrategy(STRATEGY_DTMF) == device &amp;&amp;           
                            mOutputs.valueFor(mHardwareOutput)-&gt;isUsedByStrategy(STRATEGY_DTMF)) { 
                        newDevice = device; 
                    } 
                } 
        }
    }   
} 
 
以上两个个主要函数是： 
getDeviceForStrategy ， 
mOutputs.valueFor(mHardwareOutput)-&gt;isUsedByStrategy(STRATEGY_PHONE)) 
存在以下疑问： 
1  ：getDeviceForStrategy 的作用是什么？ 
boolAudioPolicyManager::AudioOutputDescriptor::isUsedByStrategy(routing_strategystrategy) 
{ 
    for(int i = 0; i &lt; (int)Audio System::NUM_STREAM_TYPES; i++) { 
        if(AudioPolicyManager::getStrategy((AudioSystem::stream_type)i) == strategy&amp;&amp; 
           isUsedByStream((AudioSystem::stream_type)i)) { 
            return true; 
       } 
    } 
    
    return false; 
} 
这个函数很重要主要是为以后设置为耳机，蓝牙这类的输出. 
以上函数会调用到 
bool isUsedByStream(AudioSystem::stream_type stream) { 
    return mRefCount[stream] &gt;0 ? true : false; 
} 
 
这个函数也很重要. 这个函数用到mRefCount 这个数组， 
这个函数在voidAudioPolicyManager::AudioOutputDescriptor::changeRefCount 中改变 
然而changeRefCount将会在startOutput 调用。 
具体什么时候改变mRefCount这个数组，现不是非常的清楚。
 
上面的走完后将设置输出 
setOutputDevice(mHardw areOutput,newDevice); 
其中newDevice 决定什么样的输出。 
 
</rich_text><rich_text foreground="#00000000ffff" scale="h3">跟事件的处理相关 
文件流程流程 </rich_text><rich_text>
KeyinputQueue.java 
Com_android_server_KeyInputQueue.cpp 
Eventhub.cpp 
SystemService.java 
WindowManagerService.java 
 
从SystemService.java中启动服务： 
public class SystemServer 
{ 
    …… 
    native public static void init1(String[]args); 
     
    public static void main(String[] args) { 
        …… 
        init1(args); 
    }
     
    public static final void init2() { 
        Log.i(TAG, &quot;Entered the Android system server!&quot;); 
        Thread th r = new ServerThread(); 
        thr.setName(&quot;android.server.ServerThread&quot;); 
        thr.start(); 
    } 
} 
 
运行init1(args);  在com_android_server_SystemServer.cpp 中有 
static JNINativeMethod gMethods[] = { 
   /* name, signature, funcPtr */ 
    {&quot;init1&quot;, &quot;([Ljava/lang/String;)V&quot;, (void*)android_server_SystemServer_init1 }, 
}; 
 
而又有如下： 
extern &quot;C&quot; int system_init(); 
static voidandroid_server_SystemServer_init1(JNIEnv* en v, jobject clazz) 
{ 
    system_init(); 
} 
 
system_init()将调用在System_init.cpp  中 
extern &quot;C&quot; status _tsystem_init() 
{ 
    …… 
    runtime-&gt;callStatic(&quot;com/android/server/SystemServer&quot;,&quot;init2&quot;);// 这句后将跳会SystemService.java 中的 init2 。 
    ……  
} 
 
也即是如下代码 
public static final void init2()   
{ 
    Log.i(TAG, &quot;Entered the Android system server!&quot;); 
    Thread thr = new ServerThread(); //建立一个 service 的线程 
    thr.setName(&quot;android.server.ServerThread&quot;);
    thr.start(); 
} 
 
服务线程： 
class ServerThread  extends Thread 
{ 
    …… 
    public void run() { 
        …… 
        Log.i(TAG, &quot;Window Manager&quot;); 
        wm = WindowManagerService.main(context, power, 
                    factoryTest  != SystemServer.FACTORY_TEST_LOW_LEVEL); 
        ServiceManager.addService(Context.WINDOW_SERVICE, wm); 
        ((ActivityManagerService)ServiceManager.getService(&quot;activity&quot;)) 
                    .setWindowManager(wm); 
        …… 
    } 
    …… 
} 
 
将跳转到WindowManagerService.java的main 中 
public static WindowManagerServicemain(Context context, 
PowerManagerService pm, booleanhaveInputMethods)   
{ 
    WMThread thr = new WMThread(context, pm,haveInputMethods);//建立线程 
    thr.start(); 
    synchronized (thr) { 
         while (thr.mService == null) { 
          try { 
                thr.wait(); 
              } catch (InterruptedException e){} 
        } 
    }
    return thr.mService; 
} 

static class WMThread extends Thread 
{ 
    …… 
    public void run() { 
        …… 
        WindowManagerService s = newWindowManagerService(mContext, mPM, 
                        mHaveInputMethods); // 新建一个 WindowManagerService 的线程 
        …… 
    } 
} 
即将跳到WindowManagerService的构造函数 
private WindowManagerService(Contextcontext, PowerManagerService pm, 
           boolean haveInputMethods)  
{ 
    …… 
    mQueue = new KeyQ(); 
    …… 
} 
而 
private class KeyQ extends KeyInputQueue 
在KeyInputQueue的构造函数中 
KeyInputQueue(Context context,HapticFeedbackCallback   hapticFeedbackCallback) 
{ 
    …… 
    mThread.start(); 
} 
而 
Thread mThread = newThread(&quot;InputDeviceReader&quot;) 
{ 
    …… 
    readEvent(ev); 
    …… 
} 
private static native boolean readEvent(RawInputEventoutEvent);由这句可知readEvent在JNI
层 
在com_android_server_KeyInputQueue.cpp中有 
static JNINativeMethod gInputMethods[] = { 
   /* name, signature, funcPtr */ 
    {&quot;readEvent&quot;,      &quot;(Landroid/view/RawInputEvent;)Z&quot;,  (void*) android_server_KeyInputQueue_readEvent }, 
    …… 
} 
由以上可知在KeyInputQueue.java中调的 readEvent 将调用到
com_android_server_KeyInputQueue.cpp 的android_server_KeyInputQueue_readEvent。 
static jboolean   
android_server_KeyInputQueue_readEvent(JNIEnv*env, jobject clazz, jobject event) 
{ 
    …… 
    if (hub == NULL) { 
        hub = new EventHub; 
        gHub = hub; 
    } 
    …… 
    bool res = hub-&gt;getEvent(&amp;deviceId,&amp;type, &amp;scancode, &amp;keycode, 
               &amp;flags, &amp;value, &amp;when); 
    …… 
} 
hub-&gt;getEvent 将调用EventHub.cpp 的getEvent 函数 
bool EventHub::getEvent(int32_t*outDeviceId, int32_t* outType, 
       int32_t* outScancode, int32_t* outKeycode, uint32_t *outFlags, 
       int32_t* outValue, nsecs_t* outWhen) 
{ 
     …… 
     if (!mOpened) { 
           mError = openPlatformInput() ? NO_ERROR : UNKNOWN_ERROR; 
           mOpened = true; 
     }  
} 
 
openPlatformInput()将扫描/dev/input 下的所有 event并打开它 
/* 
  *Open the platform-specific input device. 
 */ 
bool EventHub::openPlatformInput(void) 
{ 
    …… 
    res= scan_dir(device_path);// 其中static const char *device_path = &quot;/dev/input&quot;; 
    …… 
} 

而 
int EventHub::scan_dir(const char *dirname)
{ 
    char devname[PATH_MAX]; 
    char *filename; 
    DIR *dir; 
    struct dirent *de; 
    dir = opendir(dirname); 
    if (dir == NULL) 
        return -1; 
    strcpy(devname, dirname); 
    filename = devname + strlen(devname); 
    *filename++ = '/'; 
    // 扫描/dev/input 下的所有event并打开它 
    while((de = readdir(dir))) { 
       if(de-&gt;d_name[0] == '.' &amp;&amp; 
          (de-&gt;d_name[1] == '\0' || 
           (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2] == '\0'))) 
           continue; 
       strcpy(filename, de-&gt;d_name); 
       open_device(devname);//打开event设备 
    }
    
    closedir(dir); 
    return 0; 
} 
 
int EventHub::open_device(const char*deviceName) 
{ 
    …… 
    fd = open(deviceName, O_RDWR); 
    …… 
    if ((device-&gt;classes&amp;CLASS_KEYBOARD)!= 0) { 
        char tmpfn[sizeof(name)]; 
        char keylayoutFilename[300]; 
     
        // a more descriptive name 
        device-&gt;name = name; 
     
        // replace all the spaces with underscores 
        strcpy(tmpfn, name); 
        for (char *p = strchr(tmpfn, ' '); p &amp;&amp; *p; p = strchr(tmpfn, '')) 
               *p = '_'; 
     
        // find the .kl file we need for this device 
       const char* root = getenv(&quot;ANDROID_ROOT&quot;); 
       snprintf(keylayoutFilename, sizeof(keylayoutFilename), 
                    &quot;%s/usr/keylayout/%s.kl&quot;, root, tmpfn); 
       bool defaultKeymap = false; 
       if (access(keylayoutFilename, R_OK)) { 
            snprintf(keylayoutFilename, sizeof(keylayoutFilename), 
                    &quot;%s/usr/keylayout/%s&quot;, root, &quot;qwerty.kl&quot;); 
            defaultKeymap = true; 
        } 
        device-&gt;layoutMap-&gt;load(keylayoutFilename); 
    } 
如果上面的操作都成功则把所有设备都打开了，根据注册的 input 设备的名字查找对应的.kl
文件，如果有该设备就用该.kl把扫描码映射键码。文件现回到EventHub::getEvent。 

release_wake_lock(WAKE_LOCK_ID); 

pollres = poll(mFDs, mFDCount, -1); 
 
acquire_wake_lock(PARTIA L_WAKE_LOCK, WAKE_LOCK_ID); 
在这边poll ，如果没有新事件将在这等待，如果有则开始下面的读事件 
     res = read(mFDs[i].f d, &amp;iev, sizeof(iev)); 
 
到此整个从上面开始的读过程结束。 
现在回到 
Thread mThread = newThread(&quot;InputDeviceReader&quot;) 
{ 
    …… 
    readEvent(ev); 
    …… 
    else { 
        send = preprocessEvent(di, ev); 
    } 
} 
由这个abstractboolean preprocessEvent(InputDevice device, RawInputEvent event);可以看出上
面调用的preprocessEvent将调到windowmanagerservice.java中的 
boolean preprocessEvent(InputDevice device,RawInputEvent event) 
boolean preprocessEvent(InputDevice device,RawInputEvent event) 
{ 
    if (mPolicy.preprocessInputEventTq(event)) { 
         return true; 
    }
 
   switch (event.type) { 
        case RawInputEvent.EV_KEY:  
        { 
            …… 
            if ((actions &amp; WindowManagerPolicy.ACTION_PASS_TO_USER) != 0) { // 这段代码不是很清楚，做什么用的                        
                if (event.value != 0 &amp;&amp;mPolicy.isAppSwitchKeyTqTiLwLi(event.keycode)) { 
                    filterQueue(this); 
                    mKeyWaiter.appSwitchComing(); 
                }
                 
                return true; 
            } else {
 
                return false; 
            } 
往事件队列里放入事件 
 
在WindowManagerService.java的构造函数中又有 
mInputThread = new InputDispatcherThread();
InputDispatcherThread  线程实际上从   KeyQ  的事件队列中读取按键事件 
mInputThread.start(); 
又有如下 
private final class InputDispatcherThread extends Thread { 
    // Time to wait when there isnothing to do: 9999 seconds. 
    static final int LONG_WAIT=9999*1000; 
    public InputDispatcherThread() { 
        super(&quot;InputDispatcher&quot;); 
    } 
    @Override 
    public void run() { 
        while (true) { 
            try { 
                process(); 
            } catch (Exception e) { 
                Log.e(TAG, &quot;Exceptionin input dispatcher&quot;, e); 
            } 
        } 
    } 
    private void process() { 
        …… 
        while (true) { 
            // Retrieve next event, waiting only aslong as the next 
            // repeat timeout.    If theconfiguration has changed, then 
            // don't wait at all -- we'll report the change as soon as 
            // we have processed all events. 
            QueuedEvent ev = mQueue.getEvent( 
                    (int)((!configChanged&amp;&amp; curTime &lt; nextKeyTime) 
                            ?(nextKeyTime-curTime) : 0)); 
            …… 
            switch (ev.classType) { 
                case RawInputEvent.CLASS_KEYBOARD: 
                    if (ke.isDown()) { 
                        lastKey = ke; 
                        downTime = curTime; 
                        keyRepeatCount = 0; 
                        lastKeyTime = curTime; 
                        nextKeyTime = lastKeyTime+ ViewConfiguration.getLongPressTimeout(); 
                        if (DEBUG_INPUT) Log.v(TAG, &quot;Received key down: first repeat @&quot;+nextKeyTime); 
                    } else { 
                        lastKey = null; 
                        downTime = 0; 
                        // Arbitrary long timeout. 
                        lastKeyTime = curTime; 
                        nextKeyTime = curTime + LONG_WAIT; 
                        if (DEBUG_INPUT) Log.v(TAG, &quot;Received key up: ignore repeat @&quot;+nextKeyTime); 
                    } 
                    dispatchKey((KeyEvent)ev.event, 0, 0);    //发布事件 
                    mQueue.recycleEvent(ev); 
                    break; 
                …… 
            } 
 
 
    /** 
     * @return Returns true if event was dispatched, false if it was droppedfor any reason 
     */ 
    private int dispatchKey(KeyEvent event, int pid, int uid) { 
       if (DEBUG_INPUT) Log. v(TAG, &quot;Dispatch key: &quot; + event); 
 
       Object focusObj = mKeyWaiter.waitForNextEventTarget(event, null, 
                null, false, false, pid, uid); 
       if (focusObj == null) { 
                        Log.w(TAG, &quot;Nofocus window, dropping: &quot; + event); 
           return INJECT_FAILED; 
       } 
       if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) { 
           return INJECT_SUCCEEDED; 
       } 
 
        // Okay we have finishedwaiting for the last event to be processed. 
        // First off, if this is a repeat event, check  to see if there is 
        // a corresponding up even t in the queue.    If there is, we will 
        // just drop the repeat, because it makes no sense to repeat after 
        // the user has released akey.    (This is especially important for
        // long presses.) 
        if (event.getRepeatCount() &gt; 0 &amp;&amp;mQueue.hasKeyUpEvent(event)) { 
            return INJECT_SUCCEEDED; 
        } 
        
       WindowState focus = (WindowState)focusObj;  
       if (DEBUG_INPUT) Log.v(TAG, &quot;Dispatchingto &quot; + focus + &quot;: &quot; + event);  
        if (uid != 0 &amp;&amp; uid !=focus.mSession.mUid) { 
           if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid, uid) 
                    !=PackageManager.PERMISSION_GRANTED) { 
                Log.w(TAG, &quot;Permissiondenied: injecting key event from pid &quot; 
                        + pid + &quot; uid&quot; + uid + &quot; to window &quot; + focus 
                        + &quot; owned by uid&quot; + focus.mSession.mUid); 
                return INJECT_NO_PERMISSION; 
           } 
       } 
 
       synchronized(mWindowMap) { 
           mKeyWaiter.bindTargetWindowLocked(focus); 
       } 
 
       // NOSHIP extra state logging 
       mKeyWaiter.recordDispatchState(event, focus); 
       // END NOSHIP 
 
       try { 
           if (DEBUG_INPUT || DEBUG_FOCUS) { 
                Log.v(TAG, &quot;Delivering key&quot; + event.getKeyCode() 
                       + &quot; to &quot;+ focus); 
           } 
           focus.mClient.dispatchKey(event); 
           return INJECT_SUCCEEDED; 
       } catch (android.os.RemoteException e) { 
                        Log.i(TAG, &quot;WINDOWDIED during key dispatch: &quot; + focus); 
           try { 
                removeWindow(focus.mSession,focus.mClient); 
           } catch (java.util.NoSuchElementException ex) { 
                // This will happen if thewindow has already been 
                // removed. 
            } 
       } 
 
       return INJECT_FAILED; 
} 
</rich_text></node></node></cherrytree>